L 1 "main.cpp"
L 1 "mbed/mbed_config.h" 1
N// Automatically generated configuration file.
N// DO NOT EDIT, content will be overwritten.
N
N#ifndef __MBED_CONFIG_DATA__
N#define __MBED_CONFIG_DATA__
N
N// Configuration parameters
N#define MBED_CONF_PLATFORM_STDIO_BAUD_RATE          9600 // set by library:platform
N#define MBED_CONF_PLATFORM_DEFAULT_SERIAL_BAUD_RATE 9600 // set by library:platform
N#define MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT      1    // set by library:platform
N#define MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES   0    // set by library:platform
N
N#endif
L 1 "main.cpp" 2
N#include "mbed.h"
L 1 "mbed/./mbed.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_H
N#define MBED_H
N
N#define MBED_LIBRARY_VERSION 141
N
N#if MBED_CONF_RTOS_PRESENT
S// RTOS present, this is valid only for mbed OS 5
S#define MBED_MAJOR_VERSION 5
S#define MBED_MINOR_VERSION 4
S#define MBED_PATCH_VERSION 4
S
N#else
N// mbed 2
N#define MBED_MAJOR_VERSION 2
N#define MBED_MINOR_VERSION 0
N#define MBED_PATCH_VERSION MBED_LIBRARY_VERSION
N#endif
N
N#define MBED_ENCODE_VERSION(major, minor, patch) ((major)*10000 + (minor)*100 + (patch))
N
N#define MBED_VERSION MBED_ENCODE_VERSION(MBED_MAJOR_VERSION, MBED_MINOR_VERSION, MBED_PATCH_VERSION)
N
N#if MBED_CONF_RTOS_PRESENT
S#include "rtos/rtos.h"
N#endif
N
N#if MBED_CONF_NSAPI_PRESENT
S#include "netsocket/nsapi.h"
N#endif
N
N#if MBED_CONF_EVENTS_PRESENT
S#include "events/mbed_events.h"
N#endif
N
N#if MBED_CONF_FILESYSTEM_PRESENT
S#include "filesystem/mbed_filesystem.h"
N#endif
N
N#include "platform/mbed_toolchain.h"
L 1 "mbed/./platform/mbed_toolchain.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_TOOLCHAIN_H
N#define MBED_TOOLCHAIN_H
N
N#include "mbed_preprocessor.h"
L 1 "mbed/./platform/mbed_preprocessor.h" 1
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PREPROCESSOR_H
N#define MBED_PREPROCESSOR_H
N
N
N/** MBED_CONCAT
N *  Concatenate tokens together
N *
N *  @note
N *  Expands tokens before concatenation
N *
N *  @code
N *  // Creates a unique label based on the line number
N *  int MBED_CONCAT(UNIQUE_LABEL_, __LINE__) = 1;
N *  @endcode
N */
N#define MBED_CONCAT(a, b) MBED_CONCAT_(a, b)
N#define MBED_CONCAT_(a, b) a##b
N
N/** MBED_STRINGIFY
N *  Converts tokens into strings
N *
N *  @note
N *  Expands tokens before stringification
N *
N *  @code
N *  // Creates a string based on the parameters
N *  const char *c = MBED_STRINGIFY(This is a ridiculous way to create a string)
N *  @endcode
N */
N#define MBED_STRINGIFY(a) MBED_STRINGIFY_(a)
N#define MBED_STRINGIFY_(a) #a
N
N
N#endif
N
N/** @}*/
L 23 "mbed/./platform/mbed_toolchain.h" 2
N
N
N// Warning for unsupported compilers
N#if !defined(__GNUC__)   /* GCC        */ \
N && !defined(__CC_ARM)   /* ARMCC      */ \
N && !defined(__clang__)  /* LLVM/Clang */ \
N && !defined(__ICCARM__) /* IAR        */
X#if !1L      && !1L      && !0L     && !0L  
S#warning "This compiler is not yet supported."
N#endif
N
N
N// Attributes
N
N/** MBED_PACKED
N *  Pack a structure, preventing any padding from being added between fields.
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *
N *  MBED_PACKED(struct) foo {
N *      char x;
N *      int y;
N *  };
N *  @endcode
N */
N#ifndef MBED_PACKED
N#if defined(__ICCARM__)
X#if 0L
S#define MBED_PACKED(struct) __packed struct
N#else
N#define MBED_PACKED(struct) struct __attribute__((packed))
N#endif
N#endif
N
N/** MBED_ALIGN(N)
N *  Declare a variable to be aligned on an N-byte boundary.
N *
N *  @note
N *  IAR does not support alignment greater than word size on the stack
N *  
N *  @code
N *  #include "mbed_toolchain.h"
N *
N *  MBED_ALIGN(16) char a;
N *  @endcode
N */
N#ifndef MBED_ALIGN
N#if defined(__ICCARM__)
X#if 0L
S#define MBED_ALIGN(N) _Pragma(MBED_STRINGIFY(data_alignment=N))
N#else
N#define MBED_ALIGN(N) __attribute__((aligned(N)))
N#endif
N#endif
N
N/** MBED_UNUSED
N *  Declare a function argument to be unused, suppressing compiler warnings
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *
N *  void foo(MBED_UNUSED int arg) {
N *
N *  }
N *  @endcode
N */
N#ifndef MBED_UNUSED
N#if defined(__GNUC__) || defined(__clang__) || defined(__CC_ARM)
X#if 1L || 0L || 1L
N#define MBED_UNUSED __attribute__((__unused__))
N#else
S#define MBED_UNUSED
N#endif
N#endif
N
N/** MBED_WEAK
N *  Mark a function as being weak.
N *  
N *  @note
N *  weak functions are not friendly to making code re-usable, as they can only
N *  be overridden once (and if they are multiply overridden the linker will emit
N *  no warning). You should not normally use weak symbols as part of the API to
N *  re-usable modules.
N *  
N *  @code
N *  #include "mbed_toolchain.h"
N *  
N *  MBED_WEAK void foo() {
N *      // a weak implementation of foo that can be overriden by a definition
N *      // without  __weak
N *  }
N *  @endcode
N */
N#ifndef MBED_WEAK
N#if defined(__ICCARM__)
X#if 0L
S#define MBED_WEAK __weak
N#else
N#define MBED_WEAK __attribute__((weak))
N#endif
N#endif
N
N/** MBED_PURE
N *  Hint to the compiler that a function depends only on parameters
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *
N *  MBED_PURE int foo(int arg){
N *      // no access to global variables
N *  }
N *  @endcode
N */
N#ifndef MBED_PURE
N#if defined(__GNUC__) || defined(__clang__) || defined(__CC_ARM)
X#if 1L || 0L || 1L
N#define MBED_PURE __attribute__((const))
N#else
S#define MBED_PURE
N#endif
N#endif
N
N/** MBED_FORCEINLINE
N *  Declare a function that must always be inlined. Failure to inline
N *  such a function will result in an error.
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *  
N *  MBED_FORCEINLINE void foo() {
N *  
N *  }
N *  @endcode
N */
N#ifndef MBED_FORCEINLINE
N#if defined(__GNUC__) || defined(__clang__) || defined(__CC_ARM)
X#if 1L || 0L || 1L
N#define MBED_FORCEINLINE static inline __attribute__((always_inline))
N#elif defined(__ICCARM__)
X#elif 0L
S#define MBED_FORCEINLINE _Pragma("inline=forced") static
S#else
S#define MBED_FORCEINLINE static inline
N#endif
N#endif
N
N/** MBED_NORETURN
N *  Declare a function that will never return.
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *  
N *  MBED_NORETURN void foo() {
N *      // must never return
N *      while (1) {}
N *  }
N *  @endcode
N */
N#ifndef MBED_NORETURN
N#if defined(__GNUC__) || defined(__clang__) || defined(__CC_ARM)
X#if 1L || 0L || 1L
N#define MBED_NORETURN __attribute__((noreturn))
N#elif defined(__ICCARM__)
X#elif 0L
S#define MBED_NORETURN __noreturn
S#else
S#define MBED_NORETURN
N#endif
N#endif
N
N/** MBED_UNREACHABLE
N *  An unreachable statement. If the statement is reached,
N *  behaviour is undefined. Useful in situations where the compiler
N *  cannot deduce the unreachability of code.
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *
N *  void foo(int arg) {
N *      switch (arg) {
N *          case 1: return 1;
N *          case 2: return 2;
N *          ...
N *      }
N *      MBED_UNREACHABLE;
N *  }
N *  @endcode
N */
N#ifndef MBED_UNREACHABLE
N#if (defined(__GNUC__) || defined(__clang__)) && !defined(__CC_ARM)
X#if (1L || 0L) && !1L
S#define MBED_UNREACHABLE __builtin_unreachable()
N#else
N#define MBED_UNREACHABLE while (1)
N#endif
N#endif
N
N/** MBED_DEPRECATED("message string")
N *  Mark a function declaration as deprecated, if it used then a warning will be
N *  issued by the compiler possibly including the provided message. Note that not
N *  all compilers are able to display the message.
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *  
N *  MBED_DEPRECATED("don't foo any more, bar instead")
N *  void foo(int arg);
N *  @endcode
N */
N#ifndef MBED_DEPRECATED
N#if defined(__CC_ARM)
X#if 1L
N#define MBED_DEPRECATED(M) __attribute__((deprecated))
N#elif defined(__GNUC__) || defined(__clang__)
X#elif 1L || 0L
S#define MBED_DEPRECATED(M) __attribute__((deprecated(M)))
S#else
S#define MBED_DEPRECATED(M)
N#endif
N#endif
N
N/** MBED_DEPRECATED_SINCE("version", "message string")
N *  Mark a function declaration as deprecated, noting that the declaration was
N *  deprecated on the specified version. If the function is used then a warning
N *  will be issued by the compiler possibly including the provided message.
N *  Note that not all compilers are able to display this message.
N *
N *  @code
N *  #include "mbed_toolchain.h"
N *
N *  MBED_DEPRECATED_SINCE("mbed-os-5.1", "don't foo any more, bar instead")
N *  void foo(int arg);
N *  @endcode
N */
N#define MBED_DEPRECATED_SINCE(D, M) MBED_DEPRECATED(M " [since " D "]")
N
N/** MBED_CALLER_ADDR()
N * Returns the caller of the current function.
N *
N * @note
N * This macro is only implemented for GCC and ARMCC.
N *
N * @code
N * #include "mbed_toolchain.h"
N *
N * printf("This function was called from %p", MBED_CALLER_ADDR());
N * @endcode
N *
N * @return Address of the calling function
N */
N#ifndef MBED_CALLER_ADDR
N#if (defined(__GNUC__) || defined(__clang__)) && !defined(__CC_ARM)
X#if (1L || 0L) && !1L
S#define MBED_CALLER_ADDR() __builtin_extract_return_addr(__builtin_return_address(0))
N#elif defined(__CC_ARM)
X#elif 1L
N#define MBED_CALLER_ADDR() __builtin_return_address(0)
N#else
S#define MBED_CALLER_ADDR() (NULL)
N#endif
N#endif
N
N#ifndef MBED_SECTION
N#if (defined(__GNUC__) || defined(__clang__)) || defined(__CC_ARM)
X#if (1L || 0L) || 1L
N#define MBED_SECTION(name) __attribute__ ((section (name)))
N#elif defined(__ICCARM__)
X#elif 0L
S#define MBED_SECTION(name) _Pragma(MBED_STRINGIFY(location=name))
S#else
S#error "Missing MBED_SECTION directive"
N#endif
N#endif
N
N// FILEHANDLE declaration
N#if defined(TOOLCHAIN_ARM)
X#if 1L
N#include <rt_sys.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rt_sys.h" 1
N/* rt_sys.h: prototypes for _sys_* functions and types
N *
N * Copyright 1999 ARM Limited. All rights reserved.
N *
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __RT_SYS_H
N#define __RT_SYS_H
N#define __ARMCLIB_VERSION 5060037
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/*
N * This type is used by the _sys_ I/O functions to denote an open
N * file.
N */
Ntypedef int FILEHANDLE;
N
N/*
N * Open a file. May return -1 if the file failed to open.
N */
Nextern FILEHANDLE _sys_open(const char * /*name*/, int /*openmode*/);
N/*
N * openmode is a bitmap, whose bits are given below. They
N * correspond directly to the ANSI mode specification.
N */
N#define OPEN_R 0
N#define OPEN_W 4
N#define OPEN_A 8
N#define OPEN_B 1
N#define OPEN_PLUS 2
N
N/*
N * These names should be special strings which will be recognised
N * by _sys_open and will cause it to return the standard I/O
N * handles, instead of opening a real file.
N */
Nextern const char __stdin_name[];
Nextern const char __stdout_name[];
Nextern const char __stderr_name[];
N
N/*
N * Close a file. Should return 0 on success or a negative value on error.
N */
Nextern int _sys_close(FILEHANDLE /*fh*/);
N
N/*
N * Write to a file. Returns 0 on success, negative on error, and
N * the number of characters _not_ written on partial success.
N * `mode' exists for historical reasons and must be ignored.
N */
Nextern int _sys_write(FILEHANDLE /*fh*/, const unsigned char * /*buf*/,
N                      unsigned /*len*/, int /*mode*/);
N
N/*
N * Read from a file. Can return:
N *  - zero if the read was completely successful
N *  - the number of bytes _not_ read, if the read was partially successful
N *  - the number of bytes not read, plus the top bit set (0x80000000), if
N *    the read was partially successful due to end of file
N *  - -1 if some error other than EOF occurred
N *
N * It is also legal to signal EOF by returning no data but
N * signalling no error (i.e. the top-bit-set mechanism need never
N * be used).
N *
N * So if (for example) the user is trying to read 8 bytes at a time
N * from a file in which only 5 remain, this routine can do three
N * equally valid things:
N *
N *  - it can return 0x80000003 (3 bytes not read due to EOF)
N *  - OR it can return 3 (3 bytes not read), and then return
N *    0x80000008 (8 bytes not read due to EOF) on the next attempt
N *  - OR it can return 3 (3 bytes not read), and then return
N *    8 (8 bytes not read, meaning 0 read, meaning EOF) on the next
N *    attempt
N *
N * `mode' exists for historical reasons and must be ignored.
N */
Nextern int _sys_read(FILEHANDLE /*fh*/, unsigned char * /*buf*/,
N                     unsigned /*len*/, int /*mode*/);
N
N/*
N * Write a character to the output channel. This function is used
N * for last-resort error message output.
N */
Nextern void _ttywrch(int /*ch*/);
N
N/*
N * Return non-zero if the argument file is connected to a terminal.
N */
Nextern int _sys_istty(FILEHANDLE /*fh*/);
N
N/*
N * Move the file position to a given offset from the file start.
N * Returns >=0 on success, <0 on failure.
N */
Nextern int _sys_seek(FILEHANDLE /*fh*/, long /*pos*/);
N
N/*
N * Flush any OS buffers associated with fh, ensuring that the file
N * is up to date on disk. Result is >=0 if OK, negative for an
N * error.
N */
Nextern int _sys_ensure(FILEHANDLE /*fh*/);
N
N/*
N * Return the current length of a file, or <0 if an error occurred.
N * _sys_flen is allowed to reposition the file pointer (so Unix can
N * implement it with a single lseek, for example), since it is only
N * called when processing SEEK_END relative fseeks, and therefore a
N * call to _sys_flen is always followed by a call to _sys_seek.
N */
Nextern long _sys_flen(FILEHANDLE /*fh*/);
N
N/*
N * Return the name for temporary file number sig in the buffer
N * name. Returns 0 on failure. maxlen is the maximum name length
N * allowed.
N */
Nextern int _sys_tmpnam(char * /*name*/, int /*sig*/, unsigned /*maxlen*/);
N
N/*
N * Terminate the program, passing a return code back to the user.
N * This function may not return.
N */
Nextern void _sys_exit(int /*returncode*/);   /* never returns */
N
N/*
N * Return a pointer to the command line used to invoke the program.
N * The supplied buffer may be used to store the string, but need
N * not be.
N */
Nextern char *_sys_command_string(char * /*cmd*/, int /*len*/);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
L 284 "mbed/./platform/mbed_toolchain.h" 2
N#endif
N
N#ifndef FILEHANDLE
Ntypedef int FILEHANDLE;
N#endif
N
N// Backwards compatibility
N#ifndef WEAK
N#define WEAK MBED_WEAK
N#endif
N
N#ifndef PACKED
N#define PACKED MBED_PACKED()
N#endif
N
N#ifndef EXTERN
N#define EXTERN extern
N#endif
N
N#endif
N
N/** @}*/
L 55 "mbed/./mbed.h" 2
N#include "platform/platform.h"
L 1 "mbed/./platform/platform.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PLATFORM_H
N#define MBED_PLATFORM_H
N
N#include <cstddef>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstddef" 1
N/*
N * C++ header for C header stddef.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N
N#ifndef __cstddef
N#define __cstddef
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STDDEF_NO_EXPORTS 1
N  #include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS ::std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S  /* unconditional in non-strict C for consistency of debug info */
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
S  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 201112L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
N    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
N    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 19 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstddef" 2
N  #undef __STDDEF_NO_EXPORTS
N
N  #undef __stddef_h  // later inclusion of stddef.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstddef */
N
N
L 23 "mbed/./platform/platform.h" 2
N#include <cstdlib>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdlib" 1
N/*
N * C++ header for C header stdlib.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstdlib
N#define __cstdlib
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STDLIB_NO_EXPORTS 1
N  #include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS ::std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S   /* unconditional in non-strict C for consistency of debug info */
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
S  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !1L
S#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 1L && 0L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 1L && 0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 1L && 0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) ldiv_t div(long int __numer, long int __denom) {
N       return ldiv(__numer, __denom);
N   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) long long abs(long long x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
N   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
X   extern "C++" inline __declspec(__nothrow) __attribute__((const)) lldiv_t div(long long __numer, long long __denom) {
N       return lldiv(__numer, __denom);
N   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
N    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
N    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdlib" 2
N  #undef __STDLIB_NO_EXPORTS
N
N  #undef __stdlib_h  // later inclusion of stdlib.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstdlib */
N
L 24 "mbed/./platform/platform.h" 2
N#include <cstdio>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdio" 1
N/*
N * C++ header for C header stdio.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstdio
N#define __cstdio
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STDIO_NO_EXPORTS 1
N  #include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
N      namespace std {
N      #define __CLIBNS ::std::
N        extern "C" {
N    #else /* ndef __cplusplus */
S      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 1L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !1L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (1L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !1L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
N    inline int getchar() { return getc(stdin); }
X    inline int getchar() { return getc((& ::std:: __stdin)); }
N#else
S    #define getchar() getc(stdin)
S    extern _ARMABI int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
N    inline int putchar(int __c) { return putc(__c, stdout); }
X    inline int putchar(int __c) { return putc(__c, (& ::std:: __stdout)); }
N#else
S    #define putchar(c) putc(c, stdout)
S    extern _ARMABI int (putchar)(int /*c*/);
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 1L && !1L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdio" 2
N  #undef __STDIO_NO_EXPORTS
N
N  #undef __stdio_h  // later inclusion of stdio.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __cstdio */
N
L 25 "mbed/./platform/platform.h" 2
N#include <cstring>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 1
N/*
N * C++ header for C header string.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstring
N#define __cstring
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STRING_NO_EXPORTS 1
N  #include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Nextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
Nextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Nextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
N    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Sextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strchr(char * __s, int __c)
N    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
N    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strrchr(char * __s, int __c)
N    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strstr(char * __s1, const char * __s2)
N    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
N    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 2
N  #undef __STRING_NO_EXPORTS
N
N  #undef __string_h  // later inclusion of string.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstring */
N
L 26 "mbed/./platform/platform.h" 2
N
N#include "platform/mbed_retarget.h"
L 1 "mbed/./platform/mbed_retarget.h" 1
N/*
N * mbed Microcontroller Library
N * Copyright (c) 2006-2016 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N */
N
N#ifndef RETARGET_H
N#define RETARGET_H
N
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.2.1 */
S
S    /* minimum values of exact-width signed integer types */
S#define INT8_MIN                   -128
S#define INT16_MIN                -32768
S#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
S#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
S
S    /* maximum values of exact-width signed integer types */
S#define INT8_MAX                    127
S#define INT16_MAX                 32767
S#define INT32_MAX            2147483647
S#define INT64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of exact-width unsigned integer types */
S#define UINT8_MAX                   255
S#define UINT16_MAX                65535
S#define UINT32_MAX           4294967295u
S#define UINT64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.2 */
S
S    /* minimum values of minimum-width signed integer types */
S#define INT_LEAST8_MIN                   -128
S#define INT_LEAST16_MIN                -32768
S#define INT_LEAST32_MIN          (~0x7fffffff)
S#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of minimum-width signed integer types */
S#define INT_LEAST8_MAX                    127
S#define INT_LEAST16_MAX                 32767
S#define INT_LEAST32_MAX            2147483647
S#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of minimum-width unsigned integer types */
S#define UINT_LEAST8_MAX                   255
S#define UINT_LEAST16_MAX                65535
S#define UINT_LEAST32_MAX           4294967295u
S#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.3 */
S
S    /* minimum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MIN           (~0x7fffffff)
S#define INT_FAST16_MIN          (~0x7fffffff)
S#define INT_FAST32_MIN          (~0x7fffffff)
S#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MAX             2147483647
S#define INT_FAST16_MAX            2147483647
S#define INT_FAST32_MAX            2147483647
S#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of fastest minimum-width unsigned integer types */
S#define UINT_FAST8_MAX            4294967295u
S#define UINT_FAST16_MAX           4294967295u
S#define UINT_FAST32_MAX           4294967295u
S#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.4 */
S
S    /* minimum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MIN INT64_MIN
S#else
S#define INTPTR_MIN INT32_MIN
S#endif
S
S    /* maximum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MAX INT64_MAX
S#else
S#define INTPTR_MAX INT32_MAX
S#endif
S
S    /* maximum value of pointer-holding unsigned integer type */
S#if __sizeof_ptr == 8
S#define UINTPTR_MAX UINT64_MAX
S#else
S#define UINTPTR_MAX UINT32_MAX
S#endif
S
S    /* 7.18.2.5 */
S
S    /* minimum value of greatest-width signed integer type */
S#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
S
S    /* maximum value of greatest-width signed integer type */
S#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
S
S    /* maximum value of greatest-width unsigned integer type */
S#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
S
S    /* 7.18.3 */
S
S    /* limits of ptrdiff_t */
S#if __sizeof_ptr == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
S#else
S#define PTRDIFF_MIN INT32_MIN
S#define PTRDIFF_MAX INT32_MAX
S#endif
S
S    /* limits of sig_atomic_t */
S#define SIG_ATOMIC_MIN (~0x7fffffff)
S#define SIG_ATOMIC_MAX   2147483647
S
S    /* limit of size_t */
S#if __sizeof_ptr == 8
S#define SIZE_MAX UINT64_MAX
S#else
S#define SIZE_MAX UINT32_MAX
S#endif
S
S    /* limits of wchar_t */
S    /* NB we have to undef and redef because they're defined in both
S     * stdint.h and wchar.h */
S#undef WCHAR_MIN
S#undef WCHAR_MAX
S
S#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
S#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
S#endif
S
S    /* limits of wint_t */
S#define WINT_MIN (~0x7fffffff)
S#define WINT_MAX 2147483647
S
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.4.1 macros for minimum-width integer constants */
S#define INT8_C(x)   (x)
S#define INT16_C(x)  (x)
S#define INT32_C(x)  (x)
S#define INT64_C(x)  __INT64_C(x)
S
S#define UINT8_C(x)  (x ## u)
S#define UINT16_C(x) (x ## u)
S#define UINT32_C(x) (x ## u)
S#define UINT64_C(x) __UINT64_C(x)
S
S    /* 7.18.4.2 macros for greatest-width integer constants */
S#define INTMAX_C(x)  __ESCAPE__(x ## ll)
S#define UINTMAX_C(x) __ESCAPE__(x ## ull)
S
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STDINT_NO_EXPORTS
N      using ::std::int8_t;
N      using ::std::int16_t;
N      using ::std::int32_t;
N      using ::std::int64_t;
N      using ::std::uint8_t;
N      using ::std::uint16_t;
N      using ::std::uint32_t;
N      using ::std::uint64_t;
N      using ::std::int_least8_t;
N      using ::std::int_least16_t;
N      using ::std::int_least32_t;
N      using ::std::int_least64_t;
N      using ::std::uint_least8_t;
N      using ::std::uint_least16_t;
N      using ::std::uint_least32_t;
N      using ::std::uint_least64_t;
N      using ::std::int_fast8_t;
N      using ::std::int_fast16_t;
N      using ::std::int_fast32_t;
N      using ::std::int_fast64_t;
N      using ::std::uint_fast8_t;
N      using ::std::uint_fast16_t;
N      using ::std::uint_fast32_t;
N      using ::std::uint_fast64_t;
N      using ::std::intptr_t;
N      using ::std::uintptr_t;
N      using ::std::intmax_t;
N      using ::std::uintmax_t;
N    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 23 "mbed/./platform/mbed_retarget.h" 2
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
S  #define __STDDEF_DECLS
S    #undef __CLIBNS
S    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
S    #else
S      #define __CLIBNS
S    #endif  /* __cplusplus */
S
S#if __sizeof_ptr == 8
S  typedef signed long ptrdiff_t;
S#else
S  typedef signed int ptrdiff_t;
S#endif
S
S#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
S /* unconditional in C++ and non-strict C for consistency of debug info */
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
S#endif
S
S#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S  /* unconditional in non-strict C for consistency of debug info */
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
S  #endif
S#endif
S
S#undef NULL  /* others (e.g. <stdio.h>) also define */
S#define NULL 0
S   /* null pointer constant. */
S
S#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
S#else
S  /* EDG uses __INTADDR__ to avoid errors when strict */
S  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
S#endif
S
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S  typedef long double max_align_t;
S#endif
S
S    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
S    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
N    #ifndef __STDDEF_NO_EXPORTS
N      using ::std::size_t;
N      using ::std::ptrdiff_t;
N      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X      #if !0L || (1L && 201103L <= 199711L)
N        using ::std::max_align_t;
N      #endif
N    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 24 "mbed/./platform/mbed_retarget.h" 2
N
N/* We can get the following standard types from sys/types for gcc, but we
N * need to define the types ourselves for the other compilers that normally
N * target embedded systems */
N#if defined(__ARMCC_VERSION) || defined(__ICCARM__)
X#if 1L || 0L
Ntypedef int ssize_t;    ///< Signed size type, usually encodes negative errors
Ntypedef long off_t;     ///< Offset in a data stream
Ntypedef int mode_t;     ///< Mode for opening files
N
N#define O_RDONLY 0
N#define O_WRONLY 1
N#define O_RDWR   2
N#define O_CREAT  0x0200
N#define O_TRUNC  0x0400
N#define O_APPEND 0x0008
N
N#define NAME_MAX 255    ///< Maximum size of a name in a file path
N
N#else
S#include <sys/fcntl.h>
S#include <sys/types.h>
S#include <sys/syslimits.h>
N#endif
N
N
N/* DIR declarations must also be here */
N#if __cplusplus
X#if 199711L
Nnamespace mbed { class Dir; }
Ntypedef mbed::Dir DIR;
N#else
Stypedef struct Dir DIR;
N#endif
N
N#if __cplusplus
X#if 199711L
Nextern "C" {
N#endif
N    DIR *opendir(const char*);
N    struct dirent *readdir(DIR *);
N    int closedir(DIR*);
N    void rewinddir(DIR*);
N    long telldir(DIR*);
N    void seekdir(DIR*, long);
N    int mkdir(const char *name, mode_t n);
N#if __cplusplus
X#if 199711L
N};
N#endif
N
N
N#if defined(__ARMCC_VERSION) || defined(__ICCARM__)
X#if 1L || 0L
N/* The intent of this section is to unify the errno error values to match
N * the POSIX definitions for the GCC_ARM, ARMCC and IAR compilers. This is
N * necessary because the ARMCC/IAR errno.h, or sys/stat.h are missing some
N * symbol definitions used by the POSIX filesystem API to return errno codes.
N * Note also that ARMCC errno.h defines some symbol values differently from
N * the GCC_ARM/IAR/standard POSIX definitions. The definitions guard against
N * this and future changes by changing the symbol definition as shown below. */
N#ifdef ENOENT
S#undef ENOENT
N#endif
N#define ENOENT      2       /* No such file or directory. */
N
N#ifdef EIO
S#undef EIO
N#endif
N#define EIO         5       /* I/O error */
N
N#ifdef ENXIO
S#undef ENXIO
N#endif
N#define ENXIO       6       /* No such device or address */
N
N#ifdef ENOEXEC
S#undef ENOEXEC
N#endif
N#define ENOEXEC     8       /* Exec format error */
N
N#ifdef EBADF
S#undef EBADF
N#endif
N#define EBADF       9       /* Bad file number */
N
N#ifdef ENOMEM
S#undef ENOMEM
N#endif
N#define ENOMEM      12      /* Not enough space */
N
N#ifdef EACCES
S#undef EACCES
N#endif
N#define EACCES      13      /* Permission denied */
N
N#ifdef EFAULT
S#undef EFAULT
N#endif
N#define EFAULT      14      /* Bad address */
N
N#ifdef EEXIST
S#undef EEXIST
N#endif
N#define EEXIST      17      /* File exists */
N
N#ifdef EINVAL
S#undef EINVAL
N#endif
N#define EINVAL      22      /* Invalid argument */
N
N#ifdef ENFILE
S#undef ENFILE
N#endif
N#define ENFILE      23      /* Too many open files in system */
N
N#ifdef EMFILE
S#undef EMFILE
N#endif
N#define EMFILE      24      /* File descriptor value too large */
N
N#ifdef ENOSYS
S#undef ENOSYS
N#endif
N#define ENOSYS      38      /* Function not implemented */
N
N/* Missing stat.h defines.
N * The following are sys/stat.h definitions not currently present in the ARMCC
N * errno.h. Note, ARMCC errno.h defines some symbol values differing from
N * GCC_ARM/IAR/standard POSIX definitions. Guard against this and future
N * changes by changing the symbol definition for filesystem use. */
N#define     _IFDIR  0040000 /* directory */
N#define     _IFREG  0100000 /* regular */
N
N#define S_IFDIR     _IFDIR
N#define S_IFREG     _IFREG
N
N#define S_IRWXU     (S_IRUSR | S_IWUSR | S_IXUSR)
N#define     S_IRUSR 0000400 /* read permission, owner */
N#define     S_IWUSR 0000200 /* write permission, owner */
N#define     S_IXUSR 0000100/* execute/search permission, owner */
N#define S_IRWXG     (S_IRGRP | S_IWGRP | S_IXGRP)
N#define     S_IRGRP 0000040 /* read permission, group */
N#define     S_IWGRP 0000020 /* write permission, grougroup */
N#define     S_IXGRP 0000010/* execute/search permission, group */
N#define S_IRWXO     (S_IROTH | S_IWOTH | S_IXOTH)
N#define     S_IROTH 0000004 /* read permission, other */
N#define     S_IWOTH 0000002 /* write permission, other */
N#define     S_IXOTH 0000001/* execute/search permission, other */
N
N#endif /* defined(__ARMCC_VERSION) || defined(__ICCARM__) */
N
N
N/* The following are dirent.h definitions are declared here to garuntee
N * consistency where structure may be different with different toolchains */
Nstruct dirent {
N    char d_name[NAME_MAX+1];
X    char d_name[255+1];
N    uint8_t d_type;
N};
N
Nenum {
N    DT_UNKNOWN, // The file type could not be determined.
N    DT_FIFO,    // This is a named pipe (FIFO).
N    DT_CHR,     // This is a character device.
N    DT_DIR,     // This is a directory.
N    DT_BLK,     // This is a block device.
N    DT_REG,     // This is a regular file.
N    DT_LNK,     // This is a symbolic link.
N    DT_SOCK,    // This is a UNIX domain socket.
N};
N
N
N#endif /* RETARGET_H */
L 28 "mbed/./platform/platform.h" 2
N#include "platform/mbed_toolchain.h"
N#include "device.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/TARGET_MBED_LPC1768/device.h" 1
N// The 'features' section in 'target.json' is now used to create the device's hardware preprocessor switches.
N// Check the 'features' section of the target description in 'targets.json' for more details.
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_DEVICE_H
N#define MBED_DEVICE_H
N
N
N
N
N
N
N
N
N
N
N
N#define DEVICE_ID_LENGTH       32
N#define DEVICE_MAC_OFFSET      20
N
N
N
N
N
N#include "objects.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/objects.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_OBJECTS_H
N#define MBED_OBJECTS_H
N
N#include "cmsis.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/cmsis.h" 1
N/* mbed Microcontroller Library - CMSIS
N * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
N * 
N * A generic CMSIS include header, pulling in LPC1768 specifics
N */
N
N#ifndef MBED_CMSIS_H
N#define MBED_CMSIS_H
N
N#include "LPC17xx.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/LPC17xx.h" 1
N/**************************************************************************//**
N * @file     LPC17xx.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File for 
N *           NXP LPC17xx Device Series
N * @version: V1.09
N * @date:    17. March 2010
N
N *
N * @note
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __LPC17xx_H__
N#define __LPC17xx_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC17xx Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  SPI_IRQn                      = 13,       /*!< SPI Interrupt                                    */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  RIT_IRQn                      = 29,       /*!< Repetitive Interrupt Timer Interrupt             */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /* USB Activity interrupt                             */
N  CANActivity_IRQn              = 34,       /* CAN Activity interrupt                             */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
L 1 "mbed/TARGET_LPC1768/core_cm3.h" 1
N/**************************************************************************//**
N * @file     core_cm3.h
N * @brief    CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM3_H_GENERIC
N#define __CORE_CM3_H_GENERIC
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M3
N  @{
N */
N
N/*  CMSIS CM3 definitions */
N#define __CM3_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM3_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM3_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) |                                     __CM3_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x03)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
X#elif 1L
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __GNUC__ )
X#elif 1L
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI__VFP_SUPPORT____
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 "mbed/TARGET_LPC1768/core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060750 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0)
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x03) >= 0x03) || (__CORTEX_SC >= 300)
N  #define __RBIT                          __rbit
N#else
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S  return(result);
S}
N#endif
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x03) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function executes a exclusive LDR instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function executes a exclusive LDR instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function executes a exclusive LDR instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function executes a exclusive STR instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function executes a exclusive STR instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function executes a exclusive STR instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Rotate Right with Extend (32 bit)
N
N    This function moves each bit of a bitstring right by one bit.
N    The carry input is shifted in at the left end of the bitstring.
N
N    \param [in]    value  Value to rotate
N    \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  LDRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged LDRT instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged LDRT instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged LDRT instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/** \brief  STRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged STRT instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged STRT instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged STRT instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
X#elif 1L  
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb 0xF":::"memory");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb 0xF":::"memory");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__((always_inline)) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb 0xF":::"memory");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2));
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S#else
S  int32_t s = 4 /*sizeof(v)*/ * 8 - 1; // extra shift needed at end
S
S  result = value;                      // r will be reversed bits of v; first get LSB of v
S  for (value >>= 1; value; value >>= 1)
S  {
S    result <<= 1;
S    result |= value & 1;
S    s--;
S  }
S  result <<= s;                       // shift when v's highest bits are zero
S#endif
S  return(result);
S}
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ             __builtin_clz
S
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__((always_inline)) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit.
S    The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __RRX(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__((always_inline)) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
S{
S   __ASM volatile ("strbt %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
S{
S   __ASM volatile ("strht %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__((always_inline)) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
S{
S   __ASM volatile ("strt %1, %0" : "=Q" (*addr) : "r" (value) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 149 "mbed/TARGET_LPC1768/core_cm3.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 "mbed/TARGET_LPC1768/core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.10
N * @date     18. March 2015
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2015 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060750 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x03) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Set Base Priority with condition
N
N    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
N    or the new value increases the BASEPRI priority level.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
Xstatic __inline void __set_BASEPRI_MAX(uint32_t basePri)
N{
N  register uint32_t __regBasePriMax      __ASM("basepri_max");
X  register uint32_t __regBasePriMax      __asm("basepri_max");
N  __regBasePriMax = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
X#if       ((0x03) == 0x04) || ((0x03) == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
X#elif 1L  
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Set Base Priority with condition
S
S    This function assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S	or the new value increases the BASEPRI priority level.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI_MAX(uint32_t value)
S{
S  __ASM volatile ("MSR basepri_max, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 150 "mbed/TARGET_LPC1768/core_cm3.h" 2
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __CORE_CM3_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM3_H_DEPENDANT
N#define __CORE_CM3_H_DEPENDANT
N
N#ifdef __cplusplus
N extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM3_REV
S    #define __CM3_REV               0x0200
S    #warning "__CM3_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
N  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N#ifdef __cplusplus
N  #define   __IM    volatile             /*!< Defines 'read only' permissions                 */
N#else
S  #define   __IM    volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __OM    volatile             /*!< Defines 'write only' permissions                */
N#define     __IOM   volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M3 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N  - Core Debug Register
N  - Core MPU Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31                                             /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30                                             /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29                                             /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28                                             /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N#define APSR_Q_Pos                         27                                             /*!< APSR: Q Position */
N#define APSR_Q_Msk                         (1UL << APSR_Q_Pos)                            /*!< APSR: Q Mask */
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0                                             /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31                                             /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30                                             /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29                                             /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28                                             /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_Q_Pos                         27                                             /*!< xPSR: Q Position */
N#define xPSR_Q_Msk                         (1UL << xPSR_Q_Pos)                            /*!< xPSR: Q Mask */
N
N#define xPSR_IT_Pos                        25                                             /*!< xPSR: IT Position */
N#define xPSR_IT_Msk                        (3UL << xPSR_IT_Pos)                           /*!< xPSR: IT Mask */
N
N#define xPSR_T_Pos                         24                                             /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0                                             /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1                                             /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N#define CONTROL_nPRIV_Pos                   0                                             /*!< CONTROL: nPRIV Position */
N#define CONTROL_nPRIV_Msk                  (1UL /*<< CONTROL_nPRIV_Pos*/)                 /*!< CONTROL: nPRIV Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[8];                  
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
X  volatile uint32_t ICER[8];                  
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
X  volatile uint32_t ISPR[8];                  
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
X  volatile uint32_t ICPR[8];                  
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
X  volatile uint32_t IABR[8];                  
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
X  volatile uint8_t  IP[240];                  
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
X  volatile  uint32_t STIR;                     
N}  NVIC_Type;
N
N/* Software Triggered Interrupt Register Definitions */
N#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
N#define NVIC_STIR_INTID_Msk                (0x1FFUL /*<< NVIC_STIR_INTID_Pos*/)        /*!< STIR: INTLINESNUM Mask */
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
X  volatile uint32_t VTOR;                     
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
X  volatile uint8_t  SHP[12];                  
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
X  volatile uint32_t CFSR;                     
N  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
X  volatile uint32_t HFSR;                     
N  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
X  volatile uint32_t DFSR;                     
N  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
X  volatile uint32_t MMFAR;                    
N  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
X  volatile uint32_t BFAR;                     
N  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
X  volatile uint32_t AFSR;                     
N  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
X  volatile  uint32_t PFR[2];                   
N  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
X  volatile  uint32_t DFR;                      
N  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
X  volatile  uint32_t ADR;                      
N  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
X  volatile  uint32_t MMFR[4];                  
N  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
X  volatile  uint32_t ISAR[5];                  
N       uint32_t RESERVED0[5];
N  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
X  volatile uint32_t CPACR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
N#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Vector Table Offset Register Definitions */
N#if (__CM3_REV < 0x0201)                   /* core r2p1 */
N#define SCB_VTOR_TBLBASE_Pos               29                                             /*!< SCB VTOR: TBLBASE Position */
N#define SCB_VTOR_TBLBASE_Msk               (1UL << SCB_VTOR_TBLBASE_Pos)                  /*!< SCB VTOR: TBLBASE Mask */
N
N#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
N#define SCB_VTOR_TBLOFF_Msk                (0x3FFFFFUL << SCB_VTOR_TBLOFF_Pos)            /*!< SCB VTOR: TBLOFF Mask */
N#else
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
N#endif
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
N#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
N#define SCB_AIRCR_VECTRESET_Msk            (1UL /*<< SCB_AIRCR_VECTRESET_Pos*/)           /*!< SCB AIRCR: VECTRESET Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
N#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
N
N#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
N#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
N#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
N
N#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
N#define SCB_CCR_NONBASETHRDENA_Msk         (1UL /*<< SCB_CCR_NONBASETHRDENA_Pos*/)        /*!< SCB CCR: NONBASETHRDENA Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
N#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
N
N#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
N#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
N
N#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
N#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
N
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
N#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
N
N#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
N#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
N
N#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
N#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
N
N#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
N#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
N
N#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
N#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
N
N#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
N#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
N
N#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
N#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
N
N#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
N#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
N
N#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
N#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
N
N#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
N#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL /*<< SCB_SHCSR_MEMFAULTACT_Pos*/)         /*!< SCB SHCSR: MEMFAULTACT Mask */
N
N/* SCB Configurable Fault Status Registers Definitions */
N#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
N#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
N
N#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
N#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
N
N#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
N#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL /*<< SCB_CFSR_MEMFAULTSR_Pos*/)        /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
N
N/* SCB Hard Fault Status Registers Definitions */
N#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
N#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
N
N#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
N#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
N
N#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
N#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
N
N/* SCB Debug Fault Status Register Definitions */
N#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
N#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
N
N#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
N#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
N
N#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
N#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
N
N#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
N#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
N
N#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
N#define SCB_DFSR_HALTED_Msk                (1UL /*<< SCB_DFSR_HALTED_Pos*/)               /*!< SCB DFSR: HALTED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
N    \brief      Type definitions for the System Control and ID Register not in the SCB
N  @{
N */
N
N/** \brief  Structure type to access the System Control and ID Register not in the SCB.
N */
Ntypedef struct
N{
N       uint32_t RESERVED0[1];
N  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
X  volatile  uint32_t ICTR;                     
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register      */
N#else
N       uint32_t RESERVED1[1];
N#endif
N} SCnSCB_Type;
N
N/* Interrupt Controller Type Register Definitions */
N#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
N#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL /*<< SCnSCB_ICTR_INTLINESNUM_Pos*/)  /*!< ICTR: INTLINESNUM Mask */
N
N/* Auxiliary Control Register Definitions */
N
N#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
N#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
N
N#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
N#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
N
N#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
N#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL /*<< SCnSCB_ACTLR_DISMCYCINT_Pos*/)    /*!< ACTLR: DISMCYCINT Mask */
N
N/*@} end of group CMSIS_SCnotSCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
N    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
N  @{
N */
N
N/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
N */
Ntypedef struct
N{
N  __O  union
X  volatile  union
N  {
N    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
X    volatile  uint8_t    u8;                   
N    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
X    volatile  uint16_t   u16;                  
N    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
X    volatile  uint32_t   u32;                  
N  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
X  volatile uint32_t TER;                      
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
X  volatile uint32_t TPR;                      
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
X  volatile uint32_t TCR;                      
N       uint32_t RESERVED3[29];
N  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
X  volatile  uint32_t IWR;                      
N  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
X  volatile  uint32_t IRR;                      
N  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
X  volatile uint32_t IMCR;                     
N       uint32_t RESERVED4[43];
N  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
X  volatile  uint32_t LAR;                      
N  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
X  volatile  uint32_t LSR;                      
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
X  volatile  uint32_t PID4;                     
N  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
X  volatile  uint32_t PID5;                     
N  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
X  volatile  uint32_t PID6;                     
N  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
X  volatile  uint32_t PID7;                     
N  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
X  volatile  uint32_t PID0;                     
N  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
X  volatile  uint32_t PID1;                     
N  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
X  volatile  uint32_t PID2;                     
N  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
X  volatile  uint32_t PID3;                     
N  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
X  volatile  uint32_t CID0;                     
N  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
X  volatile  uint32_t CID1;                     
N  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
X  volatile  uint32_t CID2;                     
N  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
X  volatile  uint32_t CID3;                     
N} ITM_Type;
N
N/* ITM Trace Privilege Register Definitions */
N#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
N#define ITM_TPR_PRIVMASK_Msk               (0xFUL /*<< ITM_TPR_PRIVMASK_Pos*/)            /*!< ITM TPR: PRIVMASK Mask */
N
N/* ITM Trace Control Register Definitions */
N#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
N#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
N
N#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
N#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
N
N#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
N#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
N
N#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
N#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
N
N#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
N#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
N
N#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
N#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
N
N#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
N#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
N
N#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
N#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
N
N#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
N#define ITM_TCR_ITMENA_Msk                 (1UL /*<< ITM_TCR_ITMENA_Pos*/)                /*!< ITM TCR: ITM Enable bit Mask */
N
N/* ITM Integration Write Register Definitions */
N#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
N#define ITM_IWR_ATVALIDM_Msk               (1UL /*<< ITM_IWR_ATVALIDM_Pos*/)              /*!< ITM IWR: ATVALIDM Mask */
N
N/* ITM Integration Read Register Definitions */
N#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
N#define ITM_IRR_ATREADYM_Msk               (1UL /*<< ITM_IRR_ATREADYM_Pos*/)              /*!< ITM IRR: ATREADYM Mask */
N
N/* ITM Integration Mode Control Register Definitions */
N#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
N#define ITM_IMCR_INTEGRATION_Msk           (1UL /*<< ITM_IMCR_INTEGRATION_Pos*/)          /*!< ITM IMCR: INTEGRATION Mask */
N
N/* ITM Lock Status Register Definitions */
N#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
N#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
N
N#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
N#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
N
N#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
N#define ITM_LSR_Present_Msk                (1UL /*<< ITM_LSR_Present_Pos*/)               /*!< ITM LSR: Present Mask */
N
N/*@}*/ /* end of group CMSIS_ITM */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
N    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
N  @{
N */
N
N/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
X  volatile uint32_t CYCCNT;                   
N  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
X  volatile uint32_t CPICNT;                   
N  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
X  volatile uint32_t EXCCNT;                   
N  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
X  volatile uint32_t SLEEPCNT;                 
N  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
X  volatile uint32_t LSUCNT;                   
N  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
X  volatile uint32_t FOLDCNT;                  
N  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
X  volatile  uint32_t PCSR;                     
N  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
X  volatile uint32_t COMP0;                    
N  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
X  volatile uint32_t MASK0;                    
N  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
X  volatile uint32_t FUNCTION0;                
N       uint32_t RESERVED0[1];
N  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
X  volatile uint32_t COMP1;                    
N  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
X  volatile uint32_t MASK1;                    
N  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
X  volatile uint32_t FUNCTION1;                
N       uint32_t RESERVED1[1];
N  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
X  volatile uint32_t COMP2;                    
N  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
X  volatile uint32_t MASK2;                    
N  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
X  volatile uint32_t FUNCTION2;                
N       uint32_t RESERVED2[1];
N  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
X  volatile uint32_t COMP3;                    
N  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
X  volatile uint32_t MASK3;                    
N  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
X  volatile uint32_t FUNCTION3;                
N} DWT_Type;
N
N/* DWT Control Register Definitions */
N#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
N#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
N
N#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
N#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
N
N#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
N#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
N
N#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
N#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
N
N#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
N#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
N
N#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
N#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
N
N#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
N#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
N
N#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
N#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
N
N#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
N#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
N
N#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
N#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
N
N#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
N#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
N
N#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
N#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
N
N#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
N#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
N
N#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
N#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
N
N#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
N#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
N
N#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
N#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
N
N#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
N#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
N
N#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
N#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL /*<< DWT_CTRL_CYCCNTENA_Pos*/)       /*!< DWT CTRL: CYCCNTENA Mask */
N
N/* DWT CPI Count Register Definitions */
N#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
N#define DWT_CPICNT_CPICNT_Msk              (0xFFUL /*<< DWT_CPICNT_CPICNT_Pos*/)       /*!< DWT CPICNT: CPICNT Mask */
N
N/* DWT Exception Overhead Count Register Definitions */
N#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
N#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL /*<< DWT_EXCCNT_EXCCNT_Pos*/)       /*!< DWT EXCCNT: EXCCNT Mask */
N
N/* DWT Sleep Count Register Definitions */
N#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
N#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL /*<< DWT_SLEEPCNT_SLEEPCNT_Pos*/)   /*!< DWT SLEEPCNT: SLEEPCNT Mask */
N
N/* DWT LSU Count Register Definitions */
N#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
N#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL /*<< DWT_LSUCNT_LSUCNT_Pos*/)       /*!< DWT LSUCNT: LSUCNT Mask */
N
N/* DWT Folded-instruction Count Register Definitions */
N#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
N#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL /*<< DWT_FOLDCNT_FOLDCNT_Pos*/)     /*!< DWT FOLDCNT: FOLDCNT Mask */
N
N/* DWT Comparator Mask Register Definitions */
N#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
N#define DWT_MASK_MASK_Msk                  (0x1FUL /*<< DWT_MASK_MASK_Pos*/)           /*!< DWT MASK: MASK Mask */
N
N/* DWT Comparator Function Register Definitions */
N#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
N#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
N
N#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
N#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
N
N#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
N#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
N
N#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
N#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
N
N#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
N#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
N
N#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
N#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
N
N#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
N#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
N
N#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
N#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
N
N#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
N#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL /*<< DWT_FUNCTION_FUNCTION_Pos*/)    /*!< DWT FUNCTION: FUNCTION Mask */
N
N/*@}*/ /* end of group CMSIS_DWT */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
N    \brief      Type definitions for the Trace Port Interface (TPI)
N  @{
N */
N
N/** \brief  Structure type to access the Trace Port Interface Register (TPI).
N */
Ntypedef struct
N{
N  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
X  volatile uint32_t SSPSR;                    
N  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
X  volatile uint32_t CSPSR;                    
N       uint32_t RESERVED0[2];
N  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
X  volatile uint32_t ACPR;                     
N       uint32_t RESERVED1[55];
N  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
X  volatile uint32_t SPPR;                     
N       uint32_t RESERVED2[131];
N  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
X  volatile  uint32_t FFSR;                     
N  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
X  volatile uint32_t FFCR;                     
N  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
X  volatile  uint32_t FSCR;                     
N       uint32_t RESERVED3[759];
N  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
X  volatile  uint32_t TRIGGER;                  
N  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
X  volatile  uint32_t FIFO0;                    
N  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
X  volatile  uint32_t ITATBCTR2;                
N       uint32_t RESERVED4[1];
N  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
X  volatile  uint32_t ITATBCTR0;                
N  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
X  volatile  uint32_t FIFO1;                    
N  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
X  volatile uint32_t ITCTRL;                   
N       uint32_t RESERVED5[39];
N  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
X  volatile uint32_t CLAIMSET;                 
N  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
X  volatile uint32_t CLAIMCLR;                 
N       uint32_t RESERVED7[8];
N  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
X  volatile  uint32_t DEVID;                    
N  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
X  volatile  uint32_t DEVTYPE;                  
N} TPI_Type;
N
N/* TPI Asynchronous Clock Prescaler Register Definitions */
N#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
N#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL /*<< TPI_ACPR_PRESCALER_Pos*/)    /*!< TPI ACPR: PRESCALER Mask */
N
N/* TPI Selected Pin Protocol Register Definitions */
N#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
N#define TPI_SPPR_TXMODE_Msk                (0x3UL /*<< TPI_SPPR_TXMODE_Pos*/)          /*!< TPI SPPR: TXMODE Mask */
N
N/* TPI Formatter and Flush Status Register Definitions */
N#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
N#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
N
N#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
N#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
N
N#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
N#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
N
N#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
N#define TPI_FFSR_FlInProg_Msk              (0x1UL /*<< TPI_FFSR_FlInProg_Pos*/)        /*!< TPI FFSR: FlInProg Mask */
N
N/* TPI Formatter and Flush Control Register Definitions */
N#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
N#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
N
N#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
N#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
N
N/* TPI TRIGGER Register Definitions */
N#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
N#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL /*<< TPI_TRIGGER_TRIGGER_Pos*/)      /*!< TPI TRIGGER: TRIGGER Mask */
N
N/* TPI Integration ETM Data Register Definitions (FIFO0) */
N#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
N#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
N
N#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
N#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
N
N#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
N#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
N
N#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
N#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
N
N#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
N#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
N
N#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
N#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
N
N#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
N#define TPI_FIFO0_ETM0_Msk                 (0xFFUL /*<< TPI_FIFO0_ETM0_Pos*/)          /*!< TPI FIFO0: ETM0 Mask */
N
N/* TPI ITATBCTR2 Register Definitions */
N#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
N#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR2_ATREADY_Pos*/)    /*!< TPI ITATBCTR2: ATREADY Mask */
N
N/* TPI Integration ITM Data Register Definitions (FIFO1) */
N#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
N#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
N
N#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
N#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
N
N#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
N#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
N
N#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
N#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
N
N#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
N#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
N
N#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
N#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
N
N#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
N#define TPI_FIFO1_ITM0_Msk                 (0xFFUL /*<< TPI_FIFO1_ITM0_Pos*/)          /*!< TPI FIFO1: ITM0 Mask */
N
N/* TPI ITATBCTR0 Register Definitions */
N#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
N#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL /*<< TPI_ITATBCTR0_ATREADY_Pos*/)    /*!< TPI ITATBCTR0: ATREADY Mask */
N
N/* TPI Integration Mode Control Register Definitions */
N#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
N#define TPI_ITCTRL_Mode_Msk                (0x1UL /*<< TPI_ITCTRL_Mode_Pos*/)          /*!< TPI ITCTRL: Mode Mask */
N
N/* TPI DEVID Register Definitions */
N#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
N#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
N
N#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
N#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
N
N#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
N#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
N
N#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
N#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
N
N#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
N#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
N
N#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
N#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL /*<< TPI_DEVID_NrTraceInput_Pos*/)  /*!< TPI DEVID: NrTraceInput Mask */
N
N/* TPI DEVTYPE Register Definitions */
N#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
N#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
N
N#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
N#define TPI_DEVTYPE_SubType_Msk            (0xFUL /*<< TPI_DEVTYPE_SubType_Pos*/)      /*!< TPI DEVTYPE: SubType Mask */
N
N/*@}*/ /* end of group CMSIS_TPI */
N
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
N    \brief      Type definitions for the Memory Protection Unit (MPU)
N  @{
N */
N
N/** \brief  Structure type to access the Memory Protection Unit (MPU).
N */
Ntypedef struct
N{
N  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
X  volatile  uint32_t TYPE;                     
N  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
X  volatile uint32_t RNR;                      
N  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
X  volatile uint32_t RBAR;                     
N  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
X  volatile uint32_t RASR;                     
N  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
X  volatile uint32_t RBAR_A1;                  
N  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
X  volatile uint32_t RASR_A1;                  
N  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
X  volatile uint32_t RBAR_A2;                  
N  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
X  volatile uint32_t RASR_A2;                  
N  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
X  volatile uint32_t RBAR_A3;                  
N  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
X  volatile uint32_t RASR_A3;                  
N} MPU_Type;
N
N/* MPU Type Register */
N#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
N#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
N
N#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
N#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
N
N#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
N#define MPU_TYPE_SEPARATE_Msk              (1UL /*<< MPU_TYPE_SEPARATE_Pos*/)             /*!< MPU TYPE: SEPARATE Mask */
N
N/* MPU Control Register */
N#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
N#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
N
N#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
N#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
N
N#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
N#define MPU_CTRL_ENABLE_Msk                (1UL /*<< MPU_CTRL_ENABLE_Pos*/)               /*!< MPU CTRL: ENABLE Mask */
N
N/* MPU Region Number Register */
N#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
N#define MPU_RNR_REGION_Msk                 (0xFFUL /*<< MPU_RNR_REGION_Pos*/)             /*!< MPU RNR: REGION Mask */
N
N/* MPU Region Base Address Register */
N#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
N#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
N
N#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
N#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
N
N#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
N#define MPU_RBAR_REGION_Msk                (0xFUL /*<< MPU_RBAR_REGION_Pos*/)             /*!< MPU RBAR: REGION Mask */
N
N/* MPU Region Attribute and Size Register */
N#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
N#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
N
N#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
N#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
N
N#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
N#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
N
N#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
N#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
N
N#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
N#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
N
N#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
N#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
N
N#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
N#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
N
N#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
N#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
N
N#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
N#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
N
N#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
N#define MPU_RASR_ENABLE_Msk                (1UL /*<< MPU_RASR_ENABLE_Pos*/)               /*!< MPU RASR: Region enable bit Disable Mask */
N
N/*@} end of group CMSIS_MPU */
N#endif
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Type definitions for the Core Debug Registers
N  @{
N */
N
N/** \brief  Structure type to access the Core Debug Register (CoreDebug).
N */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
X  volatile uint32_t DHCSR;                    
N  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
X  volatile  uint32_t DCRSR;                    
N  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
X  volatile uint32_t DCRDR;                    
N  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
X  volatile uint32_t DEMCR;                    
N} CoreDebug_Type;
N
N/* Debug Halting Control and Status Register */
N#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
N#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
N
N#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
N#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
N
N#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
N#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
N
N#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
N#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
N
N#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
N#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
N
N#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
N#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
N
N#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
N#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
N
N#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
N#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
N
N#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
N#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
N
N#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
N#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
N
N#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
N#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
N
N#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
N#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL /*<< CoreDebug_DHCSR_C_DEBUGEN_Pos*/)     /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
N
N/* Debug Core Register Selector Register */
N#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
N#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
N
N#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
N#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL /*<< CoreDebug_DCRSR_REGSEL_Pos*/)     /*!< CoreDebug DCRSR: REGSEL Mask */
N
N/* Debug Exception and Monitor Control Register */
N#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
N#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
N
N#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
N#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
N
N#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
N#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
N
N#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
N#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
N
N#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
N#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
N
N#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
N#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
N
N#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
N#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
N
N#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
N#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
N
N#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
N#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
N
N#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
N#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
N
N#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
N#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
N
N#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
N#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
N
N#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
N#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL /*<< CoreDebug_DEMCR_VC_CORERESET_Pos*/)  /*!< CoreDebug DEMCR: VC_CORERESET Mask */
N
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
N#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
N#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
N#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
N#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
N
N#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
N#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
N#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
N
N#if (__MPU_PRESENT == 1)
X#if (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
N  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
N#endif
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Debug Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N  #define NVIC_GetActive              __NVIC_GetActive
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S   #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* CMSIS_VECTAB_VIRTUAL */
N
N/** \brief  Set Priority Grouping
N
N  The function sets the priority grouping field using the required unlock sequence.
N  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
N  Only values from 0..7 are used.
N  In case of a conflict between priority grouping and available
N  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]      PriorityGroup  Priority grouping field.
N */
N__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
N
N  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
X  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
N  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
X  reg_value &= ~((uint32_t)((0xFFFFUL << 16) | (7UL << 8)));              
N  reg_value  =  (reg_value                                   |
N                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X                ((uint32_t)0x5FAUL << 16) |
N                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
N  SCB->AIRCR =  reg_value;
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
N}
N
N
N/** \brief  Get Priority Grouping
N
N  The function reads the priority grouping field from the NVIC Interrupt Controller.
N
N    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t __NVIC_GetPriorityGrouping(void)
N{
N  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
X  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) >> 8));
N}
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N  __DSB();
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);
N  __ISB();
X  do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0);
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
N}
N
N
N/** \brief  Get Active Interrupt
N
N    The function reads the active register in NVIC and returns the active bit.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not active.
N    \return             1  Interrupt status is active.
N */
N__STATIC_INLINE uint32_t __NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)(((NVIC->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if((int32_t)IRQn < 0) {
N    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - 5)) & (uint32_t)0xFFUL);
N  }
N  else {
N    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - 5)) & (uint32_t)0xFFUL);
N  }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if((int32_t)IRQn < 0) {
N    return(((uint32_t)SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8 - 5)));
N  }
N  else {
N    return(((uint32_t)NVIC->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - __NVIC_PRIO_BITS)));
X    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8 - 5)));
N  }
N}
N
N
N/** \brief  Encode Priority
N
N    The function encodes the priority for an interrupt with the given priority group,
N    preemptive priority value, and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N
N    \param [in]     PriorityGroup  Used priority group.
N    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N    \param [in]       SubPriority  Subpriority value (starting from 0).
N    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(5)) ? (uint32_t)(5) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(5)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(5));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/** \brief  Decode Priority
N
N    The function decodes an interrupt priority value with a given priority group to
N    preemptive priority value and subpriority value.
N    In case of a conflict between priority grouping and available
N    priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N
N    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N    \param [in]     PriorityGroup  Used priority group.
N    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N    \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(5)) ? (uint32_t)(5) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(5)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(5));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void __NVIC_SystemReset(void)
Xstatic __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16)    |
N                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
X                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8)) |
N                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
X                            (1UL << 2)    );          
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0);                                                           
N  while(1) { __NOP(); }                                             /* wait until reset */
X  while(1) { __nop(); }                                              
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk) { return (1UL); }    /* Reload value impossible */
X  if ((ticks - 1UL) > (0xFFFFFFUL )) { return (1UL); }     
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 5) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N/* ##################################### Debug In/Output function ########################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_core_DebugFunctions ITM Functions
N    \brief   Functions that access the ITM debug interface.
N  @{
N */
N
Nextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
N#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
N
N
N/** \brief  ITM Send Character
N
N    The function transmits a character via the ITM channel 0, and
N    \li Just returns when no debugger is connected that has booked the output.
N    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
N
N    \param [in]     ch  Character to transmit.
N
N    \returns            Character to transmit.
N */
N__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (((ITM->TCR & ITM_TCR_ITMENA_Msk) != 0UL) &&      /* ITM enabled */
X  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
N      ((ITM->TER & 1UL               ) != 0UL)   )     /* ITM Port #0 enabled */
X      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
N  {
N    while (ITM->PORT[0].u32 == 0UL) { __NOP(); }
X    while (((ITM_Type *) (0xE0000000UL) )->PORT[0].u32 == 0UL) { __nop(); }
N    ITM->PORT[0].u8 = (uint8_t)ch;
X    ((ITM_Type *) (0xE0000000UL) )->PORT[0].u8 = (uint8_t)ch;
N  }
N  return (ch);
N}
N
N
N/** \brief  ITM Receive Character
N
N    The function inputs a character via the external variable \ref ITM_RxBuffer.
N
N    \return             Received character.
N    \return         -1  No character pending.
N */
N__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
Xstatic __inline int32_t ITM_ReceiveChar (void) {
N  int32_t ch = -1;                           /* no character available */
N
N  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer != 0x5AA55AA5) {
N    ch = ITM_RxBuffer;
N    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
X    ITM_RxBuffer = 0x5AA55AA5;        
N  }
N
N  return (ch);
N}
N
N
N/** \brief  ITM Check Character
N
N    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
N
N    \return          0  No character available.
N    \return          1  Character available.
N */
N__STATIC_INLINE int32_t ITM_CheckChar (void) {
Xstatic __inline int32_t ITM_CheckChar (void) {
N
N  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
X  if (ITM_RxBuffer == 0x5AA55AA5) {
N    return (0);                                 /* no character available */
N  } else {
N    return (1);                                 /*    character available */
N  }
N}
N
N/*@} end of CMSIS_core_DebugFunctions */
N
N
N
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __CORE_CM3_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 100 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/LPC17xx.h" 2
N#include "system_LPC17xx.h"                 /* System Header                                      */
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/system_LPC17xx.h" 1
N/******************************************************************************
N * @file:    system_LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Device Peripheral Access Layer Header File
N *           for the NXP LPC17xx Device Series 
N * @version: V1.02
N * @date:    27. July 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC17xx_H
N#define __SYSTEM_LPC17xx_H
N
N#ifdef __cplusplus
N extern "C" {
N#endif 
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock 
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif /* __SYSTEM_LPC17xx_H */
L 101 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/LPC17xx.h" 2
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;               /* Flash Accelerator Module           */
X  volatile uint32_t FLASHCFG;                
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                /* Clocking and Power Control         */
X  volatile uint32_t PLL0CON;                 
N  __IO uint32_t PLL0CFG;
X  volatile uint32_t PLL0CFG;
N  __I  uint32_t PLL0STAT;
X  volatile  uint32_t PLL0STAT;
N  __O  uint32_t PLL0FEED;
X  volatile  uint32_t PLL0FEED;
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;
X  volatile uint32_t PLL1CON;
N  __IO uint32_t PLL1CFG;
X  volatile uint32_t PLL1CFG;
N  __I  uint32_t PLL1STAT;
X  volatile  uint32_t PLL1STAT;
N  __O  uint32_t PLL1FEED;
X  volatile  uint32_t PLL1FEED;
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;
X  volatile uint32_t PCON;
N  __IO uint32_t PCONP;
X  volatile uint32_t PCONP;
N       uint32_t RESERVED3[15];
N  __IO uint32_t CCLKCFG;
X  volatile uint32_t CCLKCFG;
N  __IO uint32_t USBCLKCFG;
X  volatile uint32_t USBCLKCFG;
N  __IO uint32_t CLKSRCSEL;
X  volatile uint32_t CLKSRCSEL;
N  __IO uint32_t	CANSLEEPCLR;
X  volatile uint32_t	CANSLEEPCLR;
N  __IO uint32_t	CANWAKEFLAGS;
X  volatile uint32_t	CANWAKEFLAGS;
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                 /* External Interrupts                */
X  volatile uint32_t EXTINT;                  
N       uint32_t RESERVED5;
N  __IO uint32_t EXTMODE;
X  volatile uint32_t EXTMODE;
N  __IO uint32_t EXTPOLAR;
X  volatile uint32_t EXTPOLAR;
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                   /* Reset                              */
X  volatile uint32_t RSID;                    
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                    /* Syscon Miscellaneous Registers     */
X  volatile uint32_t SCS;                     
N  __IO uint32_t IRCTRIM;                /* Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                 
N  __IO uint32_t PCLKSEL0;
X  volatile uint32_t PCLKSEL0;
N  __IO uint32_t PCLKSEL1;
X  volatile uint32_t PCLKSEL1;
N       uint32_t RESERVED8[4];
N  __IO uint32_t USBIntSt;               /* USB Device/OTG Interrupt Register  */
X  volatile uint32_t USBIntSt;                
N  __IO uint32_t DMAREQSEL;
X  volatile uint32_t DMAREQSEL;
N  __IO uint32_t CLKOUTCFG;              /* Clock Output Configuration         */
X  volatile uint32_t CLKOUTCFG;               
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t PINSEL0;
X  volatile uint32_t PINSEL0;
N  __IO uint32_t PINSEL1;
X  volatile uint32_t PINSEL1;
N  __IO uint32_t PINSEL2;
X  volatile uint32_t PINSEL2;
N  __IO uint32_t PINSEL3;
X  volatile uint32_t PINSEL3;
N  __IO uint32_t PINSEL4;
X  volatile uint32_t PINSEL4;
N  __IO uint32_t PINSEL5;
X  volatile uint32_t PINSEL5;
N  __IO uint32_t PINSEL6;
X  volatile uint32_t PINSEL6;
N  __IO uint32_t PINSEL7;
X  volatile uint32_t PINSEL7;
N  __IO uint32_t PINSEL8;
X  volatile uint32_t PINSEL8;
N  __IO uint32_t PINSEL9;
X  volatile uint32_t PINSEL9;
N  __IO uint32_t PINSEL10;
X  volatile uint32_t PINSEL10;
N       uint32_t RESERVED0[5];
N  __IO uint32_t PINMODE0;
X  volatile uint32_t PINMODE0;
N  __IO uint32_t PINMODE1;
X  volatile uint32_t PINMODE1;
N  __IO uint32_t PINMODE2;
X  volatile uint32_t PINMODE2;
N  __IO uint32_t PINMODE3;
X  volatile uint32_t PINMODE3;
N  __IO uint32_t PINMODE4;
X  volatile uint32_t PINMODE4;
N  __IO uint32_t PINMODE5;
X  volatile uint32_t PINMODE5;
N  __IO uint32_t PINMODE6;
X  volatile uint32_t PINMODE6;
N  __IO uint32_t PINMODE7;
X  volatile uint32_t PINMODE7;
N  __IO uint32_t PINMODE8;
X  volatile uint32_t PINMODE8;
N  __IO uint32_t PINMODE9;
X  volatile uint32_t PINMODE9;
N  __IO uint32_t PINMODE_OD0;
X  volatile uint32_t PINMODE_OD0;
N  __IO uint32_t PINMODE_OD1;
X  volatile uint32_t PINMODE_OD1;
N  __IO uint32_t PINMODE_OD2;
X  volatile uint32_t PINMODE_OD2;
N  __IO uint32_t PINMODE_OD3;
X  volatile uint32_t PINMODE_OD3;
N  __IO uint32_t PINMODE_OD4;
X  volatile uint32_t PINMODE_OD4;
N  __IO uint32_t I2CPADCFG;
X  volatile uint32_t I2CPADCFG;
N} LPC_PINCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
Ntypedef struct
N{
N  union {
N    __IO uint32_t FIODIR;
X    volatile uint32_t FIODIR;
N    struct {
N      __IO uint16_t FIODIRL;
X      volatile uint16_t FIODIRL;
N      __IO uint16_t FIODIRH;
X      volatile uint16_t FIODIRH;
N    };
N    struct {
N      __IO uint8_t  FIODIR0;
X      volatile uint8_t  FIODIR0;
N      __IO uint8_t  FIODIR1;
X      volatile uint8_t  FIODIR1;
N      __IO uint8_t  FIODIR2;
X      volatile uint8_t  FIODIR2;
N      __IO uint8_t  FIODIR3;
X      volatile uint8_t  FIODIR3;
N    };
N  };
N  uint32_t RESERVED0[3];
N  union {
N    __IO uint32_t FIOMASK;
X    volatile uint32_t FIOMASK;
N    struct {
N      __IO uint16_t FIOMASKL;
X      volatile uint16_t FIOMASKL;
N      __IO uint16_t FIOMASKH;
X      volatile uint16_t FIOMASKH;
N    };
N    struct {
N      __IO uint8_t  FIOMASK0;
X      volatile uint8_t  FIOMASK0;
N      __IO uint8_t  FIOMASK1;
X      volatile uint8_t  FIOMASK1;
N      __IO uint8_t  FIOMASK2;
X      volatile uint8_t  FIOMASK2;
N      __IO uint8_t  FIOMASK3;
X      volatile uint8_t  FIOMASK3;
N    };
N  };
N  union {
N    __IO uint32_t FIOPIN;
X    volatile uint32_t FIOPIN;
N    struct {
N      __IO uint16_t FIOPINL;
X      volatile uint16_t FIOPINL;
N      __IO uint16_t FIOPINH;
X      volatile uint16_t FIOPINH;
N    };
N    struct {
N      __IO uint8_t  FIOPIN0;
X      volatile uint8_t  FIOPIN0;
N      __IO uint8_t  FIOPIN1;
X      volatile uint8_t  FIOPIN1;
N      __IO uint8_t  FIOPIN2;
X      volatile uint8_t  FIOPIN2;
N      __IO uint8_t  FIOPIN3;
X      volatile uint8_t  FIOPIN3;
N    };
N  };
N  union {
N    __IO uint32_t FIOSET;
X    volatile uint32_t FIOSET;
N    struct {
N      __IO uint16_t FIOSETL;
X      volatile uint16_t FIOSETL;
N      __IO uint16_t FIOSETH;
X      volatile uint16_t FIOSETH;
N    };
N    struct {
N      __IO uint8_t  FIOSET0;
X      volatile uint8_t  FIOSET0;
N      __IO uint8_t  FIOSET1;
X      volatile uint8_t  FIOSET1;
N      __IO uint8_t  FIOSET2;
X      volatile uint8_t  FIOSET2;
N      __IO uint8_t  FIOSET3;
X      volatile uint8_t  FIOSET3;
N    };
N  };
N  union {
N    __O  uint32_t FIOCLR;
X    volatile  uint32_t FIOCLR;
N    struct {
N      __O  uint16_t FIOCLRL;
X      volatile  uint16_t FIOCLRL;
N      __O  uint16_t FIOCLRH;
X      volatile  uint16_t FIOCLRH;
N    };
N    struct {
N      __O  uint8_t  FIOCLR0;
X      volatile  uint8_t  FIOCLR0;
N      __O  uint8_t  FIOCLR1;
X      volatile  uint8_t  FIOCLR1;
N      __O  uint8_t  FIOCLR2;
X      volatile  uint8_t  FIOCLR2;
N      __O  uint8_t  FIOCLR3;
X      volatile  uint8_t  FIOCLR3;
N    };
N  };
N} LPC_GPIO_TypeDef;
N
Ntypedef struct
N{
N  __I  uint32_t IntStatus;
X  volatile  uint32_t IntStatus;
N  __I  uint32_t IO0IntStatR;
X  volatile  uint32_t IO0IntStatR;
N  __I  uint32_t IO0IntStatF;
X  volatile  uint32_t IO0IntStatF;
N  __O  uint32_t IO0IntClr;
X  volatile  uint32_t IO0IntClr;
N  __IO uint32_t IO0IntEnR;
X  volatile uint32_t IO0IntEnR;
N  __IO uint32_t IO0IntEnF;
X  volatile uint32_t IO0IntEnF;
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;
X  volatile  uint32_t IO2IntStatR;
N  __I  uint32_t IO2IntStatF;
X  volatile  uint32_t IO2IntStatF;
N  __O  uint32_t IO2IntClr;
X  volatile  uint32_t IO2IntClr;
N  __IO uint32_t IO2IntEnR;
X  volatile uint32_t IO2IntEnR;
N  __IO uint32_t IO2IntEnF;
X  volatile uint32_t IO2IntEnF;
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile  uint32_t CR1;
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;
X  volatile uint32_t EMR;
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t IR;
X  volatile uint32_t IR;
N  __IO uint32_t TCR;
X  volatile uint32_t TCR;
N  __IO uint32_t TC;
X  volatile uint32_t TC;
N  __IO uint32_t PR;
X  volatile uint32_t PR;
N  __IO uint32_t PC;
X  volatile uint32_t PC;
N  __IO uint32_t MCR;
X  volatile uint32_t MCR;
N  __IO uint32_t MR0;
X  volatile uint32_t MR0;
N  __IO uint32_t MR1;
X  volatile uint32_t MR1;
N  __IO uint32_t MR2;
X  volatile uint32_t MR2;
N  __IO uint32_t MR3;
X  volatile uint32_t MR3;
N  __IO uint32_t CCR;
X  volatile uint32_t CCR;
N  __I  uint32_t CR0;
X  volatile  uint32_t CR0;
N  __I  uint32_t CR1;
X  volatile  uint32_t CR1;
N  __I  uint32_t CR2;
X  volatile  uint32_t CR2;
N  __I  uint32_t CR3;
X  volatile  uint32_t CR3;
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;
X  volatile uint32_t MR4;
N  __IO uint32_t MR5;
X  volatile uint32_t MR5;
N  __IO uint32_t MR6;
X  volatile uint32_t MR6;
N  __IO uint32_t PCR;
X  volatile uint32_t PCR;
N  __IO uint32_t LER;
X  volatile uint32_t LER;
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;
X  volatile uint32_t CTCR;
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*/
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[7];
N  __I  uint8_t  LSR;
X  volatile  uint8_t  LSR;
N       uint8_t  RESERVED2[7];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED3[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N  __IO uint8_t  ICR;
X  volatile uint8_t  ICR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  FDR;
X  volatile uint8_t  FDR;
N       uint8_t  RESERVED5[7];
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED6[39];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART0_TypeDef;
N
Ntypedef struct
N{
N  union {
N  __I  uint8_t  RBR;
X  volatile  uint8_t  RBR;
N  __O  uint8_t  THR;
X  volatile  uint8_t  THR;
N  __IO uint8_t  DLL;
X  volatile uint8_t  DLL;
N       uint32_t RESERVED0;
N  };
N  union {
N  __IO uint8_t  DLM;
X  volatile uint8_t  DLM;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  };
N  union {
N  __I  uint32_t IIR;
X  volatile  uint32_t IIR;
N  __O  uint8_t  FCR;
X  volatile  uint8_t  FCR;
N  };
N  __IO uint8_t  LCR;
X  volatile uint8_t  LCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  MCR;
X  volatile uint8_t  MCR;
N       uint8_t  RESERVED2[3];
N  __I  uint8_t  LSR;
X  volatile  uint8_t  LSR;
N       uint8_t  RESERVED3[3];
N  __I  uint8_t  MSR;
X  volatile  uint8_t  MSR;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  SCR;
X  volatile uint8_t  SCR;
N       uint8_t  RESERVED5[3];
N  __IO uint32_t ACR;
X  volatile uint32_t ACR;
N       uint32_t RESERVED6;
N  __IO uint32_t FDR;
X  volatile uint32_t FDR;
N       uint32_t RESERVED7;
N  __IO uint8_t  TER;
X  volatile uint8_t  TER;
N       uint8_t  RESERVED8[27];
N  __IO uint8_t  RS485CTRL;
X  volatile uint8_t  RS485CTRL;
N       uint8_t  RESERVED9[3];
N  __IO uint8_t  ADRMATCH;
X  volatile uint8_t  ADRMATCH;
N       uint8_t  RESERVED10[3];
N  __IO uint8_t  RS485DLY;
X  volatile uint8_t  RS485DLY;
N       uint8_t  RESERVED11[3];
N  __IO uint32_t FIFOLVL;
X  volatile uint32_t FIFOLVL;
N} LPC_UART1_TypeDef;
N
N/*------------- Serial Peripheral Interface (SPI) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t SPCR;
X  volatile uint32_t SPCR;
N  __I  uint32_t SPSR;
X  volatile  uint32_t SPSR;
N  __IO uint32_t SPDR;
X  volatile uint32_t SPDR;
N  __IO uint32_t SPCCR;
X  volatile uint32_t SPCCR;
N       uint32_t RESERVED0[3];
N  __IO uint32_t SPINT;
X  volatile uint32_t SPINT;
N} LPC_SPI_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
Ntypedef struct
N{
N  __IO uint32_t CR0;
X  volatile uint32_t CR0;
N  __IO uint32_t CR1;
X  volatile uint32_t CR1;
N  __IO uint32_t DR;
X  volatile uint32_t DR;
N  __I  uint32_t SR;
X  volatile  uint32_t SR;
N  __IO uint32_t CPSR;
X  volatile uint32_t CPSR;
N  __IO uint32_t IMSC;
X  volatile uint32_t IMSC;
N  __IO uint32_t RIS;
X  volatile uint32_t RIS;
N  __IO uint32_t MIS;
X  volatile uint32_t MIS;
N  __IO uint32_t ICR;
X  volatile uint32_t ICR;
N  __IO uint32_t DMACR;
X  volatile uint32_t DMACR;
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2CONSET;
X  volatile uint32_t I2CONSET;
N  __I  uint32_t I2STAT;
X  volatile  uint32_t I2STAT;
N  __IO uint32_t I2DAT;
X  volatile uint32_t I2DAT;
N  __IO uint32_t I2ADR0;
X  volatile uint32_t I2ADR0;
N  __IO uint32_t I2SCLH;
X  volatile uint32_t I2SCLH;
N  __IO uint32_t I2SCLL;
X  volatile uint32_t I2SCLL;
N  __O  uint32_t I2CONCLR;
X  volatile  uint32_t I2CONCLR;
N  __IO uint32_t MMCTRL;
X  volatile uint32_t MMCTRL;
N  __IO uint32_t I2ADR1;
X  volatile uint32_t I2ADR1;
N  __IO uint32_t I2ADR2;
X  volatile uint32_t I2ADR2;
N  __IO uint32_t I2ADR3;
X  volatile uint32_t I2ADR3;
N  __I  uint32_t I2DATA_BUFFER;
X  volatile  uint32_t I2DATA_BUFFER;
N  __IO uint32_t I2MASK0;
X  volatile uint32_t I2MASK0;
N  __IO uint32_t I2MASK1;
X  volatile uint32_t I2MASK1;
N  __IO uint32_t I2MASK2;
X  volatile uint32_t I2MASK2;
N  __IO uint32_t I2MASK3;
X  volatile uint32_t I2MASK3;
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t I2SDAO;
X  volatile uint32_t I2SDAO;
N  __IO uint32_t I2SDAI;
X  volatile uint32_t I2SDAI;
N  __O  uint32_t I2STXFIFO;
X  volatile  uint32_t I2STXFIFO;
N  __I  uint32_t I2SRXFIFO;
X  volatile  uint32_t I2SRXFIFO;
N  __I  uint32_t I2SSTATE;
X  volatile  uint32_t I2SSTATE;
N  __IO uint32_t I2SDMA1;
X  volatile uint32_t I2SDMA1;
N  __IO uint32_t I2SDMA2;
X  volatile uint32_t I2SDMA2;
N  __IO uint32_t I2SIRQ;
X  volatile uint32_t I2SIRQ;
N  __IO uint32_t I2STXRATE;
X  volatile uint32_t I2STXRATE;
N  __IO uint32_t I2SRXRATE;
X  volatile uint32_t I2SRXRATE;
N  __IO uint32_t I2STXBITRATE;
X  volatile uint32_t I2STXBITRATE;
N  __IO uint32_t I2SRXBITRATE;
X  volatile uint32_t I2SRXBITRATE;
N  __IO uint32_t I2STXMODE;
X  volatile uint32_t I2STXMODE;
N  __IO uint32_t I2SRXMODE;
X  volatile uint32_t I2SRXMODE;
N} LPC_I2S_TypeDef;
N
N/*------------- Repetitive Interrupt Timer (RIT) -----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t RICOMPVAL;
X  volatile uint32_t RICOMPVAL;
N  __IO uint32_t RIMASK;
X  volatile uint32_t RIMASK;
N  __IO uint8_t  RICTRL;
X  volatile uint8_t  RICTRL;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t RICOUNTER;
X  volatile uint32_t RICOUNTER;
N} LPC_RIT_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  ILR;
X  volatile uint8_t  ILR;
N       uint8_t  RESERVED0[7];
N  __IO uint8_t  CCR;
X  volatile uint8_t  CCR;
N       uint8_t  RESERVED1[3];
N  __IO uint8_t  CIIR;
X  volatile uint8_t  CIIR;
N       uint8_t  RESERVED2[3];
N  __IO uint8_t  AMR;
X  volatile uint8_t  AMR;
N       uint8_t  RESERVED3[3];
N  __I  uint32_t CTIME0;
X  volatile  uint32_t CTIME0;
N  __I  uint32_t CTIME1;
X  volatile  uint32_t CTIME1;
N  __I  uint32_t CTIME2;
X  volatile  uint32_t CTIME2;
N  __IO uint8_t  SEC;
X  volatile uint8_t  SEC;
N       uint8_t  RESERVED4[3];
N  __IO uint8_t  MIN;
X  volatile uint8_t  MIN;
N       uint8_t  RESERVED5[3];
N  __IO uint8_t  HOUR;
X  volatile uint8_t  HOUR;
N       uint8_t  RESERVED6[3];
N  __IO uint8_t  DOM;
X  volatile uint8_t  DOM;
N       uint8_t  RESERVED7[3];
N  __IO uint8_t  DOW;
X  volatile uint8_t  DOW;
N       uint8_t  RESERVED8[3];
N  __IO uint16_t DOY;
X  volatile uint16_t DOY;
N       uint16_t RESERVED9;
N  __IO uint8_t  MONTH;
X  volatile uint8_t  MONTH;
N       uint8_t  RESERVED10[3];
N  __IO uint16_t YEAR;
X  volatile uint16_t YEAR;
N       uint16_t RESERVED11;
N  __IO uint32_t CALIBRATION;
X  volatile uint32_t CALIBRATION;
N  __IO uint32_t GPREG0;
X  volatile uint32_t GPREG0;
N  __IO uint32_t GPREG1;
X  volatile uint32_t GPREG1;
N  __IO uint32_t GPREG2;
X  volatile uint32_t GPREG2;
N  __IO uint32_t GPREG3;
X  volatile uint32_t GPREG3;
N  __IO uint32_t GPREG4;
X  volatile uint32_t GPREG4;
N  __IO uint8_t  RTC_AUXEN;
X  volatile uint8_t  RTC_AUXEN;
N       uint8_t  RESERVED12[3];
N  __IO uint8_t  RTC_AUX;
X  volatile uint8_t  RTC_AUX;
N       uint8_t  RESERVED13[3];
N  __IO uint8_t  ALSEC;
X  volatile uint8_t  ALSEC;
N       uint8_t  RESERVED14[3];
N  __IO uint8_t  ALMIN;
X  volatile uint8_t  ALMIN;
N       uint8_t  RESERVED15[3];
N  __IO uint8_t  ALHOUR;
X  volatile uint8_t  ALHOUR;
N       uint8_t  RESERVED16[3];
N  __IO uint8_t  ALDOM;
X  volatile uint8_t  ALDOM;
N       uint8_t  RESERVED17[3];
N  __IO uint8_t  ALDOW;
X  volatile uint8_t  ALDOW;
N       uint8_t  RESERVED18[3];
N  __IO uint16_t ALDOY;
X  volatile uint16_t ALDOY;
N       uint16_t RESERVED19;
N  __IO uint8_t  ALMON;
X  volatile uint8_t  ALMON;
N       uint8_t  RESERVED20[3];
N  __IO uint16_t ALYEAR;
X  volatile uint16_t ALYEAR;
N       uint16_t RESERVED21;
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
Ntypedef struct
N{
N  __IO uint8_t  WDMOD;
X  volatile uint8_t  WDMOD;
N       uint8_t  RESERVED0[3];
N  __IO uint32_t WDTC;
X  volatile uint32_t WDTC;
N  __O  uint8_t  WDFEED;
X  volatile  uint8_t  WDFEED;
N       uint8_t  RESERVED1[3];
N  __I  uint32_t WDTV;
X  volatile  uint32_t WDTV;
N  __IO uint32_t WDCLKSEL;
X  volatile uint32_t WDCLKSEL;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t ADCR;
X  volatile uint32_t ADCR;
N  __IO uint32_t ADGDR;
X  volatile uint32_t ADGDR;
N       uint32_t RESERVED0;
N  __IO uint32_t ADINTEN;
X  volatile uint32_t ADINTEN;
N  __I  uint32_t ADDR0;
X  volatile  uint32_t ADDR0;
N  __I  uint32_t ADDR1;
X  volatile  uint32_t ADDR1;
N  __I  uint32_t ADDR2;
X  volatile  uint32_t ADDR2;
N  __I  uint32_t ADDR3;
X  volatile  uint32_t ADDR3;
N  __I  uint32_t ADDR4;
X  volatile  uint32_t ADDR4;
N  __I  uint32_t ADDR5;
X  volatile  uint32_t ADDR5;
N  __I  uint32_t ADDR6;
X  volatile  uint32_t ADDR6;
N  __I  uint32_t ADDR7;
X  volatile  uint32_t ADDR7;
N  __I  uint32_t ADSTAT;
X  volatile  uint32_t ADSTAT;
N  __IO uint32_t ADTRM;
X  volatile uint32_t ADTRM;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
Ntypedef struct
N{
N  __IO uint32_t DACR;
X  volatile uint32_t DACR;
N  __IO uint32_t DACCTRL;
X  volatile uint32_t DACCTRL;
N  __IO uint16_t DACCNTVAL;
X  volatile uint16_t DACCNTVAL;
N} LPC_DAC_TypeDef;
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
Ntypedef struct
N{
N  __I  uint32_t MCCON;
X  volatile  uint32_t MCCON;
N  __O  uint32_t MCCON_SET;
X  volatile  uint32_t MCCON_SET;
N  __O  uint32_t MCCON_CLR;
X  volatile  uint32_t MCCON_CLR;
N  __I  uint32_t MCCAPCON;
X  volatile  uint32_t MCCAPCON;
N  __O  uint32_t MCCAPCON_SET;
X  volatile  uint32_t MCCAPCON_SET;
N  __O  uint32_t MCCAPCON_CLR;
X  volatile  uint32_t MCCAPCON_CLR;
N  __IO uint32_t MCTIM0;
X  volatile uint32_t MCTIM0;
N  __IO uint32_t MCTIM1;
X  volatile uint32_t MCTIM1;
N  __IO uint32_t MCTIM2;
X  volatile uint32_t MCTIM2;
N  __IO uint32_t MCPER0;
X  volatile uint32_t MCPER0;
N  __IO uint32_t MCPER1;
X  volatile uint32_t MCPER1;
N  __IO uint32_t MCPER2;
X  volatile uint32_t MCPER2;
N  __IO uint32_t MCPW0;
X  volatile uint32_t MCPW0;
N  __IO uint32_t MCPW1;
X  volatile uint32_t MCPW1;
N  __IO uint32_t MCPW2;
X  volatile uint32_t MCPW2;
N  __IO uint32_t MCDEADTIME;
X  volatile uint32_t MCDEADTIME;
N  __IO uint32_t MCCCP;
X  volatile uint32_t MCCCP;
N  __IO uint32_t MCCR0;
X  volatile uint32_t MCCR0;
N  __IO uint32_t MCCR1;
X  volatile uint32_t MCCR1;
N  __IO uint32_t MCCR2;
X  volatile uint32_t MCCR2;
N  __I  uint32_t MCINTEN;
X  volatile  uint32_t MCINTEN;
N  __O  uint32_t MCINTEN_SET;
X  volatile  uint32_t MCINTEN_SET;
N  __O  uint32_t MCINTEN_CLR;
X  volatile  uint32_t MCINTEN_CLR;
N  __I  uint32_t MCCNTCON;
X  volatile  uint32_t MCCNTCON;
N  __O  uint32_t MCCNTCON_SET;
X  volatile  uint32_t MCCNTCON_SET;
N  __O  uint32_t MCCNTCON_CLR;
X  volatile  uint32_t MCCNTCON_CLR;
N  __I  uint32_t MCINTFLAG;
X  volatile  uint32_t MCINTFLAG;
N  __O  uint32_t MCINTFLAG_SET;
X  volatile  uint32_t MCINTFLAG_SET;
N  __O  uint32_t MCINTFLAG_CLR;
X  volatile  uint32_t MCINTFLAG_CLR;
N  __O  uint32_t MCCAP_CLR;
X  volatile  uint32_t MCCAP_CLR;
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
Ntypedef struct
N{
N  __O  uint32_t QEICON;
X  volatile  uint32_t QEICON;
N  __I  uint32_t QEISTAT;
X  volatile  uint32_t QEISTAT;
N  __IO uint32_t QEICONF;
X  volatile uint32_t QEICONF;
N  __I  uint32_t QEIPOS;
X  volatile  uint32_t QEIPOS;
N  __IO uint32_t QEIMAXPOS;
X  volatile uint32_t QEIMAXPOS;
N  __IO uint32_t CMPOS0;
X  volatile uint32_t CMPOS0;
N  __IO uint32_t CMPOS1;
X  volatile uint32_t CMPOS1;
N  __IO uint32_t CMPOS2;
X  volatile uint32_t CMPOS2;
N  __I  uint32_t INXCNT;
X  volatile  uint32_t INXCNT;
N  __IO uint32_t INXCMP;
X  volatile uint32_t INXCMP;
N  __IO uint32_t QEILOAD;
X  volatile uint32_t QEILOAD;
N  __I  uint32_t QEITIME;
X  volatile  uint32_t QEITIME;
N  __I  uint32_t QEIVEL;
X  volatile  uint32_t QEIVEL;
N  __I  uint32_t QEICAP;
X  volatile  uint32_t QEICAP;
N  __IO uint32_t VELCOMP;
X  volatile uint32_t VELCOMP;
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N       uint32_t RESERVED0[998];
N  __O  uint32_t QEIIEC;
X  volatile  uint32_t QEIIEC;
N  __O  uint32_t QEIIES;
X  volatile  uint32_t QEIIES;
N  __I  uint32_t QEIINTSTAT;
X  volatile  uint32_t QEIINTSTAT;
N  __I  uint32_t QEIIE;
X  volatile  uint32_t QEIIE;
N  __O  uint32_t QEICLR;
X  volatile  uint32_t QEICLR;
N  __O  uint32_t QEISET;
X  volatile  uint32_t QEISET;
N} LPC_QEI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
Ntypedef struct
N{
N  __IO uint32_t mask[512];              /* ID Masks                           */
X  volatile uint32_t mask[512];               
N} LPC_CANAF_RAM_TypeDef;
N
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;
X  volatile uint32_t AFMR;
N  __IO uint32_t SFF_sa;
X  volatile uint32_t SFF_sa;
N  __IO uint32_t SFF_GRP_sa;
X  volatile uint32_t SFF_GRP_sa;
N  __IO uint32_t EFF_sa;
X  volatile uint32_t EFF_sa;
N  __IO uint32_t EFF_GRP_sa;
X  volatile uint32_t EFF_GRP_sa;
N  __IO uint32_t ENDofTable;
X  volatile uint32_t ENDofTable;
N  __I  uint32_t LUTerrAd;
X  volatile  uint32_t LUTerrAd;
N  __I  uint32_t LUTerr;
X  volatile  uint32_t LUTerr;
N  __IO uint32_t FCANIE;
X  volatile uint32_t FCANIE;
N  __IO uint32_t FCANIC0;
X  volatile uint32_t FCANIC0;
N  __IO uint32_t FCANIC1;
X  volatile uint32_t FCANIC1;
N} LPC_CANAF_TypeDef;
N
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t CANTxSR;
X  volatile  uint32_t CANTxSR;
N  __I  uint32_t CANRxSR;
X  volatile  uint32_t CANRxSR;
N  __I  uint32_t CANMSR;
X  volatile  uint32_t CANMSR;
N} LPC_CANCR_TypeDef;
N
Ntypedef struct                          /* Controller Registers               */
N{
N  __IO uint32_t MOD;
X  volatile uint32_t MOD;
N  __O  uint32_t CMR;
X  volatile  uint32_t CMR;
N  __IO uint32_t GSR;
X  volatile uint32_t GSR;
N  __I  uint32_t ICR;
X  volatile  uint32_t ICR;
N  __IO uint32_t IER;
X  volatile uint32_t IER;
N  __IO uint32_t BTR;
X  volatile uint32_t BTR;
N  __IO uint32_t EWL;
X  volatile uint32_t EWL;
N  __I  uint32_t SR;
X  volatile  uint32_t SR;
N  __IO uint32_t RFS;
X  volatile uint32_t RFS;
N  __IO uint32_t RID;
X  volatile uint32_t RID;
N  __IO uint32_t RDA;
X  volatile uint32_t RDA;
N  __IO uint32_t RDB;
X  volatile uint32_t RDB;
N  __IO uint32_t TFI1;
X  volatile uint32_t TFI1;
N  __IO uint32_t TID1;
X  volatile uint32_t TID1;
N  __IO uint32_t TDA1;
X  volatile uint32_t TDA1;
N  __IO uint32_t TDB1;
X  volatile uint32_t TDB1;
N  __IO uint32_t TFI2;
X  volatile uint32_t TFI2;
N  __IO uint32_t TID2;
X  volatile uint32_t TID2;
N  __IO uint32_t TDA2;
X  volatile uint32_t TDA2;
N  __IO uint32_t TDB2;
X  volatile uint32_t TDB2;
N  __IO uint32_t TFI3;
X  volatile uint32_t TFI3;
N  __IO uint32_t TID3;
X  volatile uint32_t TID3;
N  __IO uint32_t TDA3;
X  volatile uint32_t TDA3;
N  __IO uint32_t TDB3;
X  volatile uint32_t TDB3;
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
Ntypedef struct                          /* Common Registers                   */
N{
N  __I  uint32_t DMACIntStat;
X  volatile  uint32_t DMACIntStat;
N  __I  uint32_t DMACIntTCStat;
X  volatile  uint32_t DMACIntTCStat;
N  __O  uint32_t DMACIntTCClear;
X  volatile  uint32_t DMACIntTCClear;
N  __I  uint32_t DMACIntErrStat;
X  volatile  uint32_t DMACIntErrStat;
N  __O  uint32_t DMACIntErrClr;
X  volatile  uint32_t DMACIntErrClr;
N  __I  uint32_t DMACRawIntTCStat;
X  volatile  uint32_t DMACRawIntTCStat;
N  __I  uint32_t DMACRawIntErrStat;
X  volatile  uint32_t DMACRawIntErrStat;
N  __I  uint32_t DMACEnbldChns;
X  volatile  uint32_t DMACEnbldChns;
N  __IO uint32_t DMACSoftBReq;
X  volatile uint32_t DMACSoftBReq;
N  __IO uint32_t DMACSoftSReq;
X  volatile uint32_t DMACSoftSReq;
N  __IO uint32_t DMACSoftLBReq;
X  volatile uint32_t DMACSoftLBReq;
N  __IO uint32_t DMACSoftLSReq;
X  volatile uint32_t DMACSoftLSReq;
N  __IO uint32_t DMACConfig;
X  volatile uint32_t DMACConfig;
N  __IO uint32_t DMACSync;
X  volatile uint32_t DMACSync;
N} LPC_GPDMA_TypeDef;
N
Ntypedef struct                          /* Channel Registers                  */
N{
N  __IO uint32_t DMACCSrcAddr;
X  volatile uint32_t DMACCSrcAddr;
N  __IO uint32_t DMACCDestAddr;
X  volatile uint32_t DMACCDestAddr;
N  __IO uint32_t DMACCLLI;
X  volatile uint32_t DMACCLLI;
N  __IO uint32_t DMACCControl;
X  volatile uint32_t DMACCControl;
N  __IO uint32_t DMACCConfig;
X  volatile uint32_t DMACCConfig;
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
Ntypedef struct
N{
N  __I  uint32_t HcRevision;             /* USB Host Registers                 */
X  volatile  uint32_t HcRevision;              
N  __IO uint32_t HcControl;
X  volatile uint32_t HcControl;
N  __IO uint32_t HcCommandStatus;
X  volatile uint32_t HcCommandStatus;
N  __IO uint32_t HcInterruptStatus;
X  volatile uint32_t HcInterruptStatus;
N  __IO uint32_t HcInterruptEnable;
X  volatile uint32_t HcInterruptEnable;
N  __IO uint32_t HcInterruptDisable;
X  volatile uint32_t HcInterruptDisable;
N  __IO uint32_t HcHCCA;
X  volatile uint32_t HcHCCA;
N  __I  uint32_t HcPeriodCurrentED;
X  volatile  uint32_t HcPeriodCurrentED;
N  __IO uint32_t HcControlHeadED;
X  volatile uint32_t HcControlHeadED;
N  __IO uint32_t HcControlCurrentED;
X  volatile uint32_t HcControlCurrentED;
N  __IO uint32_t HcBulkHeadED;
X  volatile uint32_t HcBulkHeadED;
N  __IO uint32_t HcBulkCurrentED;
X  volatile uint32_t HcBulkCurrentED;
N  __I  uint32_t HcDoneHead;
X  volatile  uint32_t HcDoneHead;
N  __IO uint32_t HcFmInterval;
X  volatile uint32_t HcFmInterval;
N  __I  uint32_t HcFmRemaining;
X  volatile  uint32_t HcFmRemaining;
N  __I  uint32_t HcFmNumber;
X  volatile  uint32_t HcFmNumber;
N  __IO uint32_t HcPeriodicStart;
X  volatile uint32_t HcPeriodicStart;
N  __IO uint32_t HcLSTreshold;
X  volatile uint32_t HcLSTreshold;
N  __IO uint32_t HcRhDescriptorA;
X  volatile uint32_t HcRhDescriptorA;
N  __IO uint32_t HcRhDescriptorB;
X  volatile uint32_t HcRhDescriptorB;
N  __IO uint32_t HcRhStatus;
X  volatile uint32_t HcRhStatus;
N  __IO uint32_t HcRhPortStatus1;
X  volatile uint32_t HcRhPortStatus1;
N  __IO uint32_t HcRhPortStatus2;
X  volatile uint32_t HcRhPortStatus2;
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;
X  volatile  uint32_t Module_ID;
N
N  __I  uint32_t OTGIntSt;               /* USB On-The-Go Registers            */
X  volatile  uint32_t OTGIntSt;                
N  __IO uint32_t OTGIntEn;
X  volatile uint32_t OTGIntEn;
N  __O  uint32_t OTGIntSet;
X  volatile  uint32_t OTGIntSet;
N  __O  uint32_t OTGIntClr;
X  volatile  uint32_t OTGIntClr;
N  __IO uint32_t OTGStCtrl;
X  volatile uint32_t OTGStCtrl;
N  __IO uint32_t OTGTmr;
X  volatile uint32_t OTGTmr;
N       uint32_t RESERVED1[58];
N
N  __I  uint32_t USBDevIntSt;            /* USB Device Interrupt Registers     */
X  volatile  uint32_t USBDevIntSt;             
N  __IO uint32_t USBDevIntEn;
X  volatile uint32_t USBDevIntEn;
N  __O  uint32_t USBDevIntClr;
X  volatile  uint32_t USBDevIntClr;
N  __O  uint32_t USBDevIntSet;
X  volatile  uint32_t USBDevIntSet;
N
N  __O  uint32_t USBCmdCode;             /* USB Device SIE Command Registers   */
X  volatile  uint32_t USBCmdCode;              
N  __I  uint32_t USBCmdData;
X  volatile  uint32_t USBCmdData;
N
N  __I  uint32_t USBRxData;              /* USB Device Transfer Registers      */
X  volatile  uint32_t USBRxData;               
N  __O  uint32_t USBTxData;
X  volatile  uint32_t USBTxData;
N  __I  uint32_t USBRxPLen;
X  volatile  uint32_t USBRxPLen;
N  __O  uint32_t USBTxPLen;
X  volatile  uint32_t USBTxPLen;
N  __IO uint32_t USBCtrl;
X  volatile uint32_t USBCtrl;
N  __O  uint32_t USBDevIntPri;
X  volatile  uint32_t USBDevIntPri;
N
N  __I  uint32_t USBEpIntSt;             /* USB Device Endpoint Interrupt Regs */
X  volatile  uint32_t USBEpIntSt;              
N  __IO uint32_t USBEpIntEn;
X  volatile uint32_t USBEpIntEn;
N  __O  uint32_t USBEpIntClr;
X  volatile  uint32_t USBEpIntClr;
N  __O  uint32_t USBEpIntSet;
X  volatile  uint32_t USBEpIntSet;
N  __O  uint32_t USBEpIntPri;
X  volatile  uint32_t USBEpIntPri;
N
N  __IO uint32_t USBReEp;                /* USB Device Endpoint Realization Reg*/
X  volatile uint32_t USBReEp;                 
N  __O  uint32_t USBEpInd;
X  volatile  uint32_t USBEpInd;
N  __IO uint32_t USBMaxPSize;
X  volatile uint32_t USBMaxPSize;
N
N  __I  uint32_t USBDMARSt;              /* USB Device DMA Registers           */
X  volatile  uint32_t USBDMARSt;               
N  __O  uint32_t USBDMARClr;
X  volatile  uint32_t USBDMARClr;
N  __O  uint32_t USBDMARSet;
X  volatile  uint32_t USBDMARSet;
N       uint32_t RESERVED2[9];
N  __IO uint32_t USBUDCAH;
X  volatile uint32_t USBUDCAH;
N  __I  uint32_t USBEpDMASt;
X  volatile  uint32_t USBEpDMASt;
N  __O  uint32_t USBEpDMAEn;
X  volatile  uint32_t USBEpDMAEn;
N  __O  uint32_t USBEpDMADis;
X  volatile  uint32_t USBEpDMADis;
N  __I  uint32_t USBDMAIntSt;
X  volatile  uint32_t USBDMAIntSt;
N  __IO uint32_t USBDMAIntEn;
X  volatile uint32_t USBDMAIntEn;
N       uint32_t RESERVED3[2];
N  __I  uint32_t USBEoTIntSt;
X  volatile  uint32_t USBEoTIntSt;
N  __O  uint32_t USBEoTIntClr;
X  volatile  uint32_t USBEoTIntClr;
N  __O  uint32_t USBEoTIntSet;
X  volatile  uint32_t USBEoTIntSet;
N  __I  uint32_t USBNDDRIntSt;
X  volatile  uint32_t USBNDDRIntSt;
N  __O  uint32_t USBNDDRIntClr;
X  volatile  uint32_t USBNDDRIntClr;
N  __O  uint32_t USBNDDRIntSet;
X  volatile  uint32_t USBNDDRIntSet;
N  __I  uint32_t USBSysErrIntSt;
X  volatile  uint32_t USBSysErrIntSt;
N  __O  uint32_t USBSysErrIntClr;
X  volatile  uint32_t USBSysErrIntClr;
N  __O  uint32_t USBSysErrIntSet;
X  volatile  uint32_t USBSysErrIntSet;
N       uint32_t RESERVED4[15];
N
N  union {
N  __I  uint32_t I2C_RX;                 /* USB OTG I2C Registers              */
X  volatile  uint32_t I2C_RX;                  
N  __O  uint32_t I2C_TX;
X  volatile  uint32_t I2C_TX;
N  };
N  __I  uint32_t I2C_STS;
X  volatile  uint32_t I2C_STS;
N  __IO uint32_t I2C_CTL;
X  volatile uint32_t I2C_CTL;
N  __IO uint32_t I2C_CLKHI;
X  volatile uint32_t I2C_CLKHI;
N  __O  uint32_t I2C_CLKLO;
X  volatile  uint32_t I2C_CLKLO;
N       uint32_t RESERVED5[824];
N
N  union {
N  __IO uint32_t USBClkCtrl;             /* USB Clock Control Registers        */
X  volatile uint32_t USBClkCtrl;              
N  __IO uint32_t OTGClkCtrl;
X  volatile uint32_t OTGClkCtrl;
N  };
N  union {
N  __I  uint32_t USBClkSt;
X  volatile  uint32_t USBClkSt;
N  __I  uint32_t OTGClkSt;
X  volatile  uint32_t OTGClkSt;
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
Ntypedef struct
N{
N  __IO uint32_t MAC1;                   /* MAC Registers                      */
X  volatile uint32_t MAC1;                    
N  __IO uint32_t MAC2;
X  volatile uint32_t MAC2;
N  __IO uint32_t IPGT;
X  volatile uint32_t IPGT;
N  __IO uint32_t IPGR;
X  volatile uint32_t IPGR;
N  __IO uint32_t CLRT;
X  volatile uint32_t CLRT;
N  __IO uint32_t MAXF;
X  volatile uint32_t MAXF;
N  __IO uint32_t SUPP;
X  volatile uint32_t SUPP;
N  __IO uint32_t TEST;
X  volatile uint32_t TEST;
N  __IO uint32_t MCFG;
X  volatile uint32_t MCFG;
N  __IO uint32_t MCMD;
X  volatile uint32_t MCMD;
N  __IO uint32_t MADR;
X  volatile uint32_t MADR;
N  __O  uint32_t MWTD;
X  volatile  uint32_t MWTD;
N  __I  uint32_t MRDD;
X  volatile  uint32_t MRDD;
N  __I  uint32_t MIND;
X  volatile  uint32_t MIND;
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;
X  volatile uint32_t SA0;
N  __IO uint32_t SA1;
X  volatile uint32_t SA1;
N  __IO uint32_t SA2;
X  volatile uint32_t SA2;
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                /* Control Registers                  */
X  volatile uint32_t Command;                 
N  __I  uint32_t Status;
X  volatile  uint32_t Status;
N  __IO uint32_t RxDescriptor;
X  volatile uint32_t RxDescriptor;
N  __IO uint32_t RxStatus;
X  volatile uint32_t RxStatus;
N  __IO uint32_t RxDescriptorNumber;
X  volatile uint32_t RxDescriptorNumber;
N  __I  uint32_t RxProduceIndex;
X  volatile  uint32_t RxProduceIndex;
N  __IO uint32_t RxConsumeIndex;
X  volatile uint32_t RxConsumeIndex;
N  __IO uint32_t TxDescriptor;
X  volatile uint32_t TxDescriptor;
N  __IO uint32_t TxStatus;
X  volatile uint32_t TxStatus;
N  __IO uint32_t TxDescriptorNumber;
X  volatile uint32_t TxDescriptorNumber;
N  __IO uint32_t TxProduceIndex;
X  volatile uint32_t TxProduceIndex;
N  __I  uint32_t TxConsumeIndex;
X  volatile  uint32_t TxConsumeIndex;
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;
X  volatile  uint32_t TSV0;
N  __I  uint32_t TSV1;
X  volatile  uint32_t TSV1;
N  __I  uint32_t RSV;
X  volatile  uint32_t RSV;
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;
X  volatile uint32_t FlowControlCounter;
N  __I  uint32_t FlowControlStatus;
X  volatile  uint32_t FlowControlStatus;
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;           /* Rx Filter Registers                */
X  volatile uint32_t RxFilterCtrl;            
N  __IO uint32_t RxFilterWoLStatus;
X  volatile uint32_t RxFilterWoLStatus;
N  __IO uint32_t RxFilterWoLClear;
X  volatile uint32_t RxFilterWoLClear;
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;
X  volatile uint32_t HashFilterL;
N  __IO uint32_t HashFilterH;
X  volatile uint32_t HashFilterH;
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;              /* Module Control Registers           */
X  volatile  uint32_t IntStatus;               
N  __IO uint32_t IntEnable;
X  volatile uint32_t IntEnable;
N  __O  uint32_t IntClear;
X  volatile  uint32_t IntClear;
N  __O  uint32_t IntSet;
X  volatile  uint32_t IntSet;
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;
X  volatile uint32_t PowerDown;
N       uint32_t RESERVED8;
N  __IO uint32_t Module_ID;
X  volatile uint32_t Module_ID;
N} LPC_EMAC_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#define LPC_GPIO_BASE         (0x2009C000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHB_BASE          (0x50000000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_SPI_BASE          (LPC_APB0_BASE + 0x20000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_PINCON_BASE       (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_RIT_BASE          (LPC_APB1_BASE + 0x30000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x04000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x04100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x04120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x04140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x04160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x04180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x041A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x041C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x041E0)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N
N/* GPIOs                                                                      */
N#define LPC_GPIO0_BASE        (LPC_GPIO_BASE + 0x00000)
N#define LPC_GPIO1_BASE        (LPC_GPIO_BASE + 0x00020)
N#define LPC_GPIO2_BASE        (LPC_GPIO_BASE + 0x00040)
N#define LPC_GPIO3_BASE        (LPC_GPIO_BASE + 0x00060)
N#define LPC_GPIO4_BASE        (LPC_GPIO_BASE + 0x00080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_RIT               ((LPC_RIT_TypeDef       *) LPC_RIT_BASE      )
N#define LPC_UART0             ((LPC_UART0_TypeDef     *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_SPI               ((LPC_SPI_TypeDef       *) LPC_SPI_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_PINCON            ((LPC_PINCON_TypeDef    *) LPC_PINCON_BASE   )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N
N#endif  // __LPC17xx_H__
L 11 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/cmsis.h" 2
N#include "cmsis_nvic.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/cmsis_nvic.h" 1
N/* mbed Microcontroller Library
N * CMSIS-style functionality to support dynamic vectors
N *******************************************************************************
N * Copyright (c) 2011 ARM Limited. All rights reserved.
N * All rights reserved.
N *
N * Redistribution and use in source and binary forms, with or without
N * modification, are permitted provided that the following conditions are met:
N *
N * 1. Redistributions of source code must retain the above copyright notice,
N *    this list of conditions and the following disclaimer.
N * 2. Redistributions in binary form must reproduce the above copyright notice,
N *    this list of conditions and the following disclaimer in the documentation
N *    and/or other materials provided with the distribution.
N * 3. Neither the name of ARM Limited nor the names of its contributors
N *    may be used to endorse or promote products derived from this software
N *    without specific prior written permission.
N *
N * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
N * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
N * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
N * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
N * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
N * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
N * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
N *******************************************************************************
N */
N
N#ifndef MBED_CMSIS_NVIC_H
N#define MBED_CMSIS_NVIC_H
N
N#include "cmsis.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/cmsis.h" 1
N/* mbed Microcontroller Library - CMSIS
N * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
N * 
N * A generic CMSIS include header, pulling in LPC1768 specifics
N */
N
N#ifndef MBED_CMSIS_H
S#define MBED_CMSIS_H
S
S#include "LPC17xx.h"
S#include "cmsis_nvic.h"
S
N#endif
L 36 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/cmsis_nvic.h" 2
N
N#define NVIC_NUM_VECTORS      (16 + 33)
N#define NVIC_USER_IRQ_OFFSET  16
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Nvoid NVIC_SetVector(IRQn_Type IRQn, uint32_t vector);
Xvoid __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector);
Nuint32_t NVIC_GetVector(IRQn_Type IRQn);
Xuint32_t __NVIC_GetVector(IRQn_Type IRQn);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
L 12 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/device/cmsis.h" 2
N
N#endif
L 20 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/objects.h" 2
N#include "PortNames.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/PortNames.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PORTNAMES_H
N#define MBED_PORTNAMES_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Ntypedef enum {
N    Port0 = 0,
N    Port1 = 1,
N    Port2 = 2,
N    Port3 = 3,
N    Port4 = 4
N} PortName;
N
N#ifdef __cplusplus
N}
N#endif
N#endif
L 21 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/objects.h" 2
N#include "PeripheralNames.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/PeripheralNames.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PERIPHERALNAMES_H
N#define MBED_PERIPHERALNAMES_H
N
N#include "cmsis.h"
N#include "PinNames.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/TARGET_MBED_LPC1768/PinNames.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PINNAMES_H
N#define MBED_PINNAMES_H
N
N#include "cmsis.h"
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Ntypedef enum {
N    PIN_INPUT,
N    PIN_OUTPUT
N} PinDirection;
N
N#define PORT_SHIFT  5
N
Ntypedef enum {
N    // LPC Pin Names
N    P0_0 = LPC_GPIO0_BASE,
X    P0_0 = ((0x2009C000UL) + 0x00000),
N          P0_1, P0_2, P0_3, P0_4, P0_5, P0_6, P0_7, P0_8, P0_9, P0_10, P0_11, P0_12, P0_13, P0_14, P0_15, P0_16, P0_17, P0_18, P0_19, P0_20, P0_21, P0_22, P0_23, P0_24, P0_25, P0_26, P0_27, P0_28, P0_29, P0_30, P0_31,
N    P1_0, P1_1, P1_2, P1_3, P1_4, P1_5, P1_6, P1_7, P1_8, P1_9, P1_10, P1_11, P1_12, P1_13, P1_14, P1_15, P1_16, P1_17, P1_18, P1_19, P1_20, P1_21, P1_22, P1_23, P1_24, P1_25, P1_26, P1_27, P1_28, P1_29, P1_30, P1_31,
N    P2_0, P2_1, P2_2, P2_3, P2_4, P2_5, P2_6, P2_7, P2_8, P2_9, P2_10, P2_11, P2_12, P2_13, P2_14, P2_15, P2_16, P2_17, P2_18, P2_19, P2_20, P2_21, P2_22, P2_23, P2_24, P2_25, P2_26, P2_27, P2_28, P2_29, P2_30, P2_31,
N    P3_0, P3_1, P3_2, P3_3, P3_4, P3_5, P3_6, P3_7, P3_8, P3_9, P3_10, P3_11, P3_12, P3_13, P3_14, P3_15, P3_16, P3_17, P3_18, P3_19, P3_20, P3_21, P3_22, P3_23, P3_24, P3_25, P3_26, P3_27, P3_28, P3_29, P3_30, P3_31,
N    P4_0, P4_1, P4_2, P4_3, P4_4, P4_5, P4_6, P4_7, P4_8, P4_9, P4_10, P4_11, P4_12, P4_13, P4_14, P4_15, P4_16, P4_17, P4_18, P4_19, P4_20, P4_21, P4_22, P4_23, P4_24, P4_25, P4_26, P4_27, P4_28, P4_29, P4_30, P4_31,
N
N    // mbed DIP Pin Names
N    p5 = P0_9,
N    p6 = P0_8,
N    p7 = P0_7,
N    p8 = P0_6,
N    p9 = P0_0,
N    p10 = P0_1,
N    p11 = P0_18,
N    p12 = P0_17,
N    p13 = P0_15,
N    p14 = P0_16,
N    p15 = P0_23,
N    p16 = P0_24,
N    p17 = P0_25,
N    p18 = P0_26,
N    p19 = P1_30,
N    p20 = P1_31,
N    p21 = P2_5,
N    p22 = P2_4,
N    p23 = P2_3,
N    p24 = P2_2,
N    p25 = P2_1,
N    p26 = P2_0,
N    p27 = P0_11,
N    p28 = P0_10,
N    p29 = P0_5,
N    p30 = P0_4,
N
N    // Other mbed Pin Names
N#ifdef MCB1700
S    LED1 = P1_28,
S    LED2 = P1_29,
S    LED3 = P1_31,
S    LED4 = P2_2,
N#else
N    LED1 = P1_18,
N    LED2 = P1_20,
N    LED3 = P1_21,
N    LED4 = P1_23,
N#endif
N    USBTX = P0_2,
N    USBRX = P0_3,
N
N    // Arch Pro Pin Names
N    D0 = P4_29,
N    D1 = P4_28,
N    D2 = P0_4,
N    D3 = P0_5,
N    D4 = P2_2,
N    D5 = P2_3,
N    D6 = P2_4,
N    D7 = P2_5,
N    D8 = P0_0,
N    D9 = P0_1,
N    D10 = P0_6,
N    D11 = P0_9,
N    D12 = P0_8,
N    D13 = P0_7,
N    D14 = P0_27,
N    D15 = P0_28,
N
N    A0 = P0_23,
N    A1 = P0_24,
N    A2 = P0_25,
N    A3 = P0_26,
N    A4 = P1_30,
N    A5 = P1_31,
N
N    // Not connected
N    NC = (int)0xFFFFFFFF,
N
N    I2C_SCL0 = NC,
N    I2C_SDA0 = NC,
N    I2C_SCL1 = p10,
N    I2C_SDA1 = p9,
N    I2C_SCL2 = p27, // pin used by application board
N    I2C_SDA2 = p28, // pin used by application board
N    I2C_SCL = I2C_SCL2,
N    I2C_SDA = I2C_SDA2,
N} PinName;
N
Ntypedef enum {
N    PullUp = 0,
N    PullDown = 3,
N    PullNone = 2,
N    Repeater = 1,
N    OpenDrain = 4,
N    PullDefault = PullDown
N} PinMode;
N
N// version of PINCON_TypeDef using register arrays
Ntypedef struct {
N  __IO uint32_t PINSEL[11];
X  volatile uint32_t PINSEL[11];
N       uint32_t RESERVED0[5];
N  __IO uint32_t PINMODE[10];
X  volatile uint32_t PINMODE[10];
N  __IO uint32_t PINMODE_OD[5];
X  volatile uint32_t PINMODE_OD[5];
N} PINCONARRAY_TypeDef;
N
N#define PINCONARRAY ((PINCONARRAY_TypeDef *)LPC_PINCON_BASE)
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
L 21 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/PeripheralNames.h" 2
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Ntypedef enum {
N    UART_0 = (int)LPC_UART0_BASE,
X    UART_0 = (int)((0x40000000UL) + 0x0C000),
N    UART_1 = (int)LPC_UART1_BASE,
X    UART_1 = (int)((0x40000000UL) + 0x10000),
N    UART_2 = (int)LPC_UART2_BASE,
X    UART_2 = (int)((0x40080000UL) + 0x18000),
N    UART_3 = (int)LPC_UART3_BASE
X    UART_3 = (int)((0x40080000UL) + 0x1C000)
N} UARTName;
N
Ntypedef enum {
N    ADC0_0 = 0,
N    ADC0_1,
N    ADC0_2,
N    ADC0_3,
N    ADC0_4,
N    ADC0_5,
N    ADC0_6,
N    ADC0_7
N} ADCName;
N
Ntypedef enum {
N    DAC_0 = 0
N} DACName;
N
Ntypedef enum {
N    SPI_0 = (int)LPC_SSP0_BASE,
X    SPI_0 = (int)((0x40080000UL) + 0x08000),
N    SPI_1 = (int)LPC_SSP1_BASE
X    SPI_1 = (int)((0x40000000UL) + 0x30000)
N} SPIName;
N
Ntypedef enum {
N    I2C_0 = (int)LPC_I2C0_BASE,
X    I2C_0 = (int)((0x40000000UL) + 0x1C000),
N    I2C_1 = (int)LPC_I2C1_BASE,
X    I2C_1 = (int)((0x40000000UL) + 0x5C000),
N    I2C_2 = (int)LPC_I2C2_BASE
X    I2C_2 = (int)((0x40080000UL) + 0x20000)
N} I2CName;
N
Ntypedef enum {
N    PWM_1 = 1,
N    PWM_2,
N    PWM_3,
N    PWM_4,
N    PWM_5,
N    PWM_6
N} PWMName;
N
Ntypedef enum {
N     CAN_1 = (int)LPC_CAN1_BASE,
X     CAN_1 = (int)((0x40000000UL) + 0x44000),
N     CAN_2 = (int)LPC_CAN2_BASE
X     CAN_2 = (int)((0x40000000UL) + 0x48000)
N} CANName;
N
N#define STDIO_UART_TX     USBTX
N#define STDIO_UART_RX     USBRX
N#define STDIO_UART        UART_0
N
N// Default peripherals
N#define MBED_SPI0         p5, p6, p7, p8
N#define MBED_SPI1         p11, p12, p13, p14
N
N#define MBED_UART0        p9, p10
N#define MBED_UART1        p13, p14
N#define MBED_UART2        p28, p27
N#define MBED_UARTUSB      USBTX, USBRX
N
N#define MBED_I2C0         p28, p27
N#define MBED_I2C1         p9, p10
N
N#define MBED_CAN0         p30, p29
N
N#define MBED_ANALOGOUT0   p18
N
N#define MBED_ANALOGIN0    p15
N#define MBED_ANALOGIN1    p16
N#define MBED_ANALOGIN2    p17
N#define MBED_ANALOGIN3    p18
N#define MBED_ANALOGIN4    p19
N#define MBED_ANALOGIN5    p20
N
N#define MBED_PWMOUT0      p26
N#define MBED_PWMOUT1      p25
N#define MBED_PWMOUT2      p24
N#define MBED_PWMOUT3      p23
N#define MBED_PWMOUT4      p22
N#define MBED_PWMOUT5      p21
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
L 22 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/objects.h" 2
N#include "PinNames.h"
N#include "gpio_object.h"
L 1 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/gpio_object.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_GPIO_OBJECT_H
N#define MBED_GPIO_OBJECT_H
N
N#include "mbed_assert.h"
L 1 "mbed/platform/mbed_assert.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_ASSERT_H
N#define MBED_ASSERT_H
N
N#include "mbed_preprocessor.h"
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Internal mbed assert function which is invoked when MBED_ASSERT macro failes.
N *  This function is active only if NDEBUG is not defined prior to including this
N *  assert header file.
N *  In case of MBED_ASSERT failing condition, error() is called with the assertation message.
N *  @param expr Expresion to be checked.
N *  @param file File where assertation failed.
N *  @param line Failing assertation line number.
N */
Nvoid mbed_assert_internal(const char *expr, const char *file, int line);
N
N#ifdef __cplusplus
N}
N#endif
N
N#ifdef NDEBUG
S#define MBED_ASSERT(expr) ((void)0)
S
N#else
N#define MBED_ASSERT(expr)                                \
Ndo {                                                     \
N    if (!(expr)) {                                       \
N        mbed_assert_internal(#expr, __FILE__, __LINE__); \
N    }                                                    \
N} while (0)
X#define MBED_ASSERT(expr)                                do {                                                         if (!(expr)) {                                               mbed_assert_internal(#expr, __FILE__, __LINE__);     }                                                    } while (0)
N#endif
N
N
N/** MBED_STATIC_ASSERT
N *  Declare compile-time assertions, results in compile-time error if condition is false
N *
N *  The assertion acts as a declaration that can be placed at file scope, in a
N *  code block (except after a label), or as a member of a C++ class/struct/union.
N *
N *  @note
N *  Use of MBED_STATIC_ASSERT as a member of a struct/union is limited:
N *  - In C++, MBED_STATIC_ASSERT is valid in class/struct/union scope.
N *  - In C, MBED_STATIC_ASSERT is not valid in struct/union scope, and
N *    MBED_STRUCT_STATIC_ASSERT is provided as an alternative that is valid
N *    in C and C++ class/struct/union scope.
N *
N *  @code
N *  MBED_STATIC_ASSERT(MBED_LIBRARY_VERSION >= 120,
N *          "The mbed library must be at least version 120");
N *
N *  int main() {
N *      MBED_STATIC_ASSERT(sizeof(int) >= sizeof(char),
N *              "An int must be larger than a char");
N *  }
N *  @endcode
N */
N#if defined(__cplusplus) && (__cplusplus >= 201103L || __cpp_static_assert >= 200410L)
X#if 1L && (199711L >= 201103L || __cpp_static_assert >= 200410L)
S#define MBED_STATIC_ASSERT(expr, msg) static_assert(expr, msg)
S#elif !defined(__cplusplus) && __STDC_VERSION__ >= 201112L
X#elif !1L && __STDC_VERSION__ >= 201112L
S#define MBED_STATIC_ASSERT(expr, msg) _Static_assert(expr, msg)
S#elif defined(__cplusplus) && defined(__GNUC__) && defined(__GXX_EXPERIMENTAL_CXX0X__) \
S    && (__GNUC__*100 + __GNUC_MINOR__) > 403L
X#elif 1L && 1L && 0L     && (4*100 + 7) > 403L
S#define MBED_STATIC_ASSERT(expr, msg) __extension__ static_assert(expr, msg)
S#elif !defined(__cplusplus) && defined(__GNUC__) && !defined(__CC_ARM) \
S    && (__GNUC__*100 + __GNUC_MINOR__) > 406L
X#elif !1L && 1L && !1L     && (4*100 + 7) > 406L
S#define MBED_STATIC_ASSERT(expr, msg) __extension__ _Static_assert(expr, msg)
S#elif defined(__ICCARM__)
X#elif 0L
S#define MBED_STATIC_ASSERT(expr, msg) static_assert(expr, msg)
N#else
N#define MBED_STATIC_ASSERT(expr, msg) \
N    enum {MBED_CONCAT(MBED_ASSERTION_AT_, __LINE__) = sizeof(char[(expr) ? 1 : -1])}
X#define MBED_STATIC_ASSERT(expr, msg)     enum {MBED_CONCAT(MBED_ASSERTION_AT_, __LINE__) = sizeof(char[(expr) ? 1 : -1])}
N#endif
N
N/** MBED_STRUCT_STATIC_ASSERT
N *  Declare compile-time assertions, results in compile-time error if condition is false
N *
N *  Unlike MBED_STATIC_ASSERT, MBED_STRUCT_STATIC_ASSERT can and must be used
N *  as a member of a C/C++ class/struct/union.
N *
N *  @code
N *  struct thing {
N *      MBED_STATIC_ASSERT(2 + 2 == 4,
N *              "Hopefully the universe is mathematically consistent");
N *  };
N *  @endcode
N */
N#define MBED_STRUCT_STATIC_ASSERT(expr, msg) int : (expr) ? 0 : -1
N
N
N#endif
N
N/** @}*/
L 20 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/gpio_object.h" 2
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Ntypedef struct {
N    PinName  pin;
N    uint32_t mask;
N
N    __IO uint32_t *reg_dir;
X    volatile uint32_t *reg_dir;
N    __IO uint32_t *reg_set;
X    volatile uint32_t *reg_set;
N    __IO uint32_t *reg_clr;
X    volatile uint32_t *reg_clr;
N    __I  uint32_t *reg_in;
X    volatile  uint32_t *reg_in;
N} gpio_t;
N
Nstatic inline void gpio_write(gpio_t *obj, int value) {
N    MBED_ASSERT(obj->pin != (PinName)NC);
X    do { if (!(obj->pin != (PinName)NC)) { mbed_assert_internal("obj->pin != (PinName)NC", "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/gpio_object.h", 36); } } while (0);
N    if (value)
N        *obj->reg_set = obj->mask;
N    else
N        *obj->reg_clr = obj->mask;
N}
N
Nstatic inline int gpio_read(gpio_t *obj) {
N    MBED_ASSERT(obj->pin != (PinName)NC);
X    do { if (!(obj->pin != (PinName)NC)) { mbed_assert_internal("obj->pin != (PinName)NC", "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/gpio_object.h", 44); } } while (0);
N    return ((*obj->reg_in & obj->mask) ? 1 : 0);
N}
N
Nstatic inline int gpio_is_connected(const gpio_t *obj) {
N    return obj->pin != (PinName)NC;
N}
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
L 24 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/objects.h" 2
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Nstruct gpio_irq_s {
N    uint32_t port;
N    uint32_t pin;
N    uint32_t ch;
N};
N
Nstruct port_s {
N    __IO uint32_t *reg_dir;
X    volatile uint32_t *reg_dir;
N    __IO uint32_t *reg_out;
X    volatile uint32_t *reg_out;
N    __I  uint32_t *reg_in;
X    volatile  uint32_t *reg_in;
N    PortName port;
N    uint32_t mask;
N};
N
Nstruct pwmout_s {
N    __IO uint32_t *MR;
X    volatile uint32_t *MR;
N    PWMName pwm;
N};
N
Nstruct serial_s {
N    LPC_UART_TypeDef *uart;
N    int index;
N};
N
Nstruct analogin_s {
N    ADCName adc;
N};
N
Nstruct dac_s {
N    DACName dac;
N};
N
Nstruct can_s {
N    LPC_CAN_TypeDef *dev;
N    int index;
N};
N
Nstruct i2c_s {
N    LPC_I2C_TypeDef *i2c;
N};
N
Nstruct spi_s {
N    LPC_SSP_TypeDef *spi;
N};
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
L 39 "mbed/TARGET_LPC1768/TARGET_NXP/TARGET_LPC176X/TARGET_MBED_LPC1768/device.h" 2
N
N#endif
L 30 "mbed/./platform/platform.h" 2
N#include "PinNames.h"
N#include "PeripheralNames.h"
N
N#endif
N
N/** @}*/
L 56 "mbed/./mbed.h" 2
N#include "platform/mbed_application.h"
L 1 "mbed/./platform/mbed_application.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2017-2017 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_APPLICATION_H
N#define MBED_APPLICATION_H
N
N#include<stdint.h>
N
N#define MBED_APPLICATION_SUPPORT (defined(__CORTEX_M3) || defined(__CORTEX_M4) || defined(__CORTEX_M7))
N#if MBED_APPLICATION_SUPPORT
X#if (1L || 0L || 0L)
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/**
N *  Start the application at the given address. This function does
N *  not return. It is the applications responsibility for flushing to
N *  or powering down external components such as filesystems or
N *  socket connections before calling this function. For Cortex-M
N *  devices this function powers down generic system components such as
N *  the NVIC and set the vector table to that of the new image followed
N *  by jumping to the reset handler of the new image.
N *
N *  @param address    Starting address of next application to run
N */
Nvoid mbed_start_application(uintptr_t address);
N
N#ifdef __cplusplus
N}
N#endif
N#endif
N
N#endif
N
N/** @}*/
L 57 "mbed/./mbed.h" 2
N
N// Useful C libraries
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF inline
N#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 1L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
S#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
N      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
N      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
N      namespace std {
N#       define __CLIBNS ::std::
N        extern "C" {
N#   else
S#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 0L
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 1L && ((!0L || 0L) || 0L)
N  extern "C++" {
N    inline int (fpclassify)(double __x) { return fpclassify(__x); }
X    inline int (fpclassify)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_fpclassifyf(__x) : __ARM_fpclassify(__x)); }
N    inline bool (isfinite)(double __x) { return isfinite(__x); }
X    inline bool (isfinite)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isfinitef(__x) : __ARM_isfinite(__x)); }
N    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
X    inline bool (isgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x20000000)); }
N    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
X    inline bool (isgreaterequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x30000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0x30000000) == 0x20000000)); }
N    inline bool (isinf)(double __x) { return isinf(__x); }
X    inline bool (isinf)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isinff(__x) : __ARM_isinf(__x)); }
N    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
X    inline bool (isless)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x80000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x80000000)); }
N    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
X    inline bool (islessequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xc0000000) != 0) : ((__ARM_dcmp4((__x), (__y)) & 0xc0000000) != 0)); }
N    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
X    inline bool (islessgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? __ARM_islessgreaterf((__x), (__y)) : __ARM_islessgreater((__x), (__y))); }
N    inline bool (isnan)(double __x) { return isnan(__x); }
X    inline bool (isnan)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnanf(__x) : __ARM_isnan(__x)); }
N    inline bool (isnormal)(double __x) { return isnormal(__x); }
X    inline bool (isnormal)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnormalf(__x) : __ARM_isnormal(__x)); }
N    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
X    inline bool (isunordered)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x10000000) == 0x10000000) : ((__ARM_dcmp4((__x), (__y)) & 0x10000000) == 0x10000000)); }
N
N  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 1L && !0L
N  extern "C++" {
N    inline float abs(float __x)   { return fabsf(__x); }
N    inline float acos(float __x)  { return acosf(__x); }
N    inline float asin(float __x)  { return asinf(__x); }
N    inline float atan(float __x)  { return atanf(__x); }
N    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
N    inline float ceil(float __x)  { return ceilf(__x); }
N    inline float cos(float __x)   { return cosf(__x); }
N    inline float cosh(float __x)  { return coshf(__x); }
N    inline float exp(float __x)   { return expf(__x); }
N    inline float fabs(float __x)  { return fabsf(__x); }
N    inline float floor(float __x) { return floorf(__x); }
N    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
N    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
N    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
N    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
N    inline float log(float __x)   { return logf(__x); }
N    inline float log10(float __x) { return log10f(__x); }
N    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
N    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
N    inline float pow(float __x, float __y)      { return powf(__x,__y); }
N    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
N    inline float sin(float __x)   { return sinf(__x); }
N    inline float sinh(float __x)  { return sinhf(__x); }
N    inline float sqrt(float __x)  { return sqrtf(__x); }
N    inline float _sqrt(float __x) { return _sqrtf(__x); }
N    inline float tan(float __x)   { return tanf(__x); }
N    inline float tanh(float __x)  { return tanhf(__x); }
N
N    inline double abs(double __x) { return fabs(__x); }
N    inline double pow(double __x, int __y)
N                { return pow(__x, (double) __y); }
N
N#ifdef __HAVE_LONGDOUBLE
N    inline long double abs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double acos(long double __x)
N                { return (long double)acosl(__x); }
N    inline long double asin(long double __x)
N                { return (long double)asinl(__x); }
N    inline long double atan(long double __x)
N                { return (long double)atanl(__x); }
N    inline long double atan2(long double __y, long double __x)
N                { return (long double)atan2l(__y, __x); }
N    inline long double ceil(long double __x)
N                { return (long double)ceill( __x); }
N    inline long double cos(long double __x)
N                { return (long double)cosl(__x); }
N    inline long double cosh(long double __x)
N                { return (long double)coshl(__x); }
N    inline long double exp(long double __x)
N                { return (long double)expl(__x); }
N    inline long double fabs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double floor(long double __x)
N                { return (long double)floorl(__x); }
N    inline long double fmod(long double __x, long double __y)
N                { return (long double)fmodl(__x, __y); }
N    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
N    inline long double frexp(long double __x, int* __p)
N                { return (long double)frexpl(__x, __p); }
N    inline long double ldexp(long double __x, int __exp)
N                { return (long double)ldexpl(__x, __exp); }
N    inline long double log(long double __x)
N                { return (long double)logl(__x); }
N    inline long double log10(long double __x)
N                { return (long double)log10l(__x); }
N    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
N    inline long double modf(long double __x, long double* __p)
N                { return (long double)modfl(__x, __p); }
N    inline long double pow(long double __x, long double __y)
N                { return (long double)powl(__x, __y); }
N    inline long double pow(long double __x, int __y)
N                { return (long double)powl(__x, __y); }
N    inline long double sin(long double __x)
N                { return (long double)sinl(__x); }
N    inline long double sinh(long double __x)
N                { return (long double)sinhl(__x); }
N    inline long double sqrt(long double __x)
N                { return (long double)sqrtl(__x); }
N    inline long double _sqrt(long double __x)
N                { return (long double)_sqrt((double) __x); }
N    inline long double tan(long double __x)
N                { return (long double)tanl(__x); }
N    inline long double tanh(long double __x)
N                { return (long double)tanhl(__x); }
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N    inline float acosh(float __x) { return acoshf(__x); }
N    inline float asinh(float __x) { return asinhf(__x); }
N    inline float atanh(float __x) { return atanhf(__x); }
N    inline float cbrt(float __x) { return cbrtf(__x); }
N    inline float erf(float __x) { return erff(__x); }
N    inline float erfc(float __x) { return erfcf(__x); }
N    inline float expm1(float __x) { return expm1f(__x); }
N    inline float log1p(float __x) { return log1pf(__x); }
N    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
N    inline float lgamma(float __x) { return lgammaf(__x); }
N    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
N    inline float rint(float __x) { return rintf(__x); }
N#endif
N
N#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
N#endif
N
N  }
N#endif
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 1L && !0L
N    using ::std::__use_accurate_range_reduction;
N    #ifndef __ARMCOMPILER_LIBCXX
N      using ::std::abs;
N    #endif
N    using ::std::acos;
N    using ::std::asin;
N    using ::std::atan2;
N    using ::std::atan;
N    using ::std::ceil;
N    using ::std::cos;
N    using ::std::cosh;
N    using ::std::exp;
N    using ::std::fabs;
N    using ::std::floor;
N    using ::std::fmod;
N    using ::std::frexp;
N    using ::std::ldexp;
N    using ::std::log10;
N    using ::std::log;
N    using ::std::modf;
N    using ::std::pow;
N    using ::std::sin;
N    using ::std::sinh;
N    using ::std::sqrt;
N    using ::std::_sqrt;
N    using ::std::_sqrtf;
N    using ::std::tan;
N    using ::std::tanh;
N    using ::std::_fabsf;
N    /* C99 float and long double versions in already-C89-reserved namespace */
N    using ::std::acosf;
N    using ::std::acosl;
N    using ::std::asinf;
N    using ::std::asinl;
N    using ::std::atan2f;
N    using ::std::atan2l;
N    using ::std::atanf;
N    using ::std::atanl;
N    using ::std::ceilf;
N    using ::std::ceill;
N    using ::std::cosf;
N    using ::std::coshf;
N    using ::std::coshl;
N    using ::std::cosl;
N    using ::std::expf;
N    using ::std::expl;
N    using ::std::fabsf;
N    using ::std::fabsl;
N    using ::std::floorf;
N    using ::std::floorl;
N    using ::std::fmodf;
N    using ::std::fmodl;
N    using ::std::frexpf;
N    using ::std::frexpl;
N    using ::std::ldexpf;
N    using ::std::ldexpl;
N    using ::std::log10f;
N    using ::std::log10l;
N    using ::std::logf;
N    using ::std::logl;
N    using ::std::modff;
N    using ::std::modfl;
N    using ::std::powf;
N    using ::std::powl;
N    using ::std::sinf;
N    using ::std::sinhf;
N    using ::std::sinhl;
N    using ::std::sinl;
N    using ::std::sqrtf;
N    using ::std::sqrtl;
N    using ::std::tanf;
N    using ::std::tanhf;
N    using ::std::tanhl;
N    using ::std::tanl;
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 0L
N      /* C99 additions which for historical reasons appear in non-strict mode */
N      using ::std::acosh;
N      using ::std::asinh;
N      using ::std::atanh;
N      using ::std::cbrt;
N      using ::std::copysign;
N      using ::std::copysignf;
N      using ::std::erf;
N      using ::std::erfc;
N      using ::std::expm1;
N      using ::std::hypot;
N      using ::std::ilogb;
N      using ::std::ilogbf;
N      using ::std::ilogbl;
N      using ::std::lgamma;
N      using ::std::log1p;
N      using ::std::logb;
N      using ::std::logbf;
N      using ::std::logbl;
N      using ::std::nextafter;
N      using ::std::nextafterf;
N      using ::std::nextafterl;
N      using ::std::nexttoward;
N      using ::std::nexttowardf;
N      using ::std::nexttowardl;
N      using ::std::remainder;
N      using ::std::rint;
N      using ::std::scalbln;
N      using ::std::scalblnf;
N      using ::std::scalblnl;
N      using ::std::scalbn;
N      using ::std::scalbnf;
N      using ::std::scalbnl;
N      using ::std::math_errhandling;
N      using ::std::acoshf;
N      using ::std::acoshl;
N      using ::std::asinhf;
N      using ::std::asinhl;
N      using ::std::atanhf;
N      using ::std::atanhl;
N      using ::std::copysignl;
N      using ::std::cbrtf;
N      using ::std::cbrtl;
N      using ::std::erff;
N      using ::std::erfl;
N      using ::std::erfcf;
N      using ::std::erfcl;
N      using ::std::expm1f;
N      using ::std::expm1l;
N      using ::std::log1pf;
N      using ::std::log1pl;
N      using ::std::hypotf;
N      using ::std::hypotl;
N      using ::std::lgammaf;
N      using ::std::lgammal;
N      using ::std::remainderf;
N      using ::std::remainderl;
N      using ::std::rintf;
N      using ::std::rintl;
N      /* New in C99. */
N      using ::std::float_t;
N      using ::std::double_t;
N    #endif
N    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X    #if (0L && !0L) || 0L
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
N    #endif
N
N    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X    #if !0L || 0L
N      using ::std::fpclassify;
N      using ::std::isfinite;
N      using ::std::isgreater;
N      using ::std::isgreaterequal;
N      using ::std::isinf;
N      using ::std::isless;
N      using ::std::islessequal;
N      using ::std::islessgreater;
N      using ::std::isnan;
N      using ::std::isnormal;
N      using ::std::isunordered;
N    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 60 "mbed/./mbed.h" 2
N#include <time.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\time.h" 1
N/* time.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.12 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                      */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * time.h declares two macros, four types and several functions for
N * manipulating time. Many functions deal with a calendar time that
N * represents the current date (according to the Gregorian
N * calendar) and time. Some functions deal with local time, which
N * is the calendar time expressed for some specific time zone, and
N * with Daylight Savings Time, which is a temporary change in the
N * algorithm for determining local time.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __time_h
N#define __time_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N  #ifndef __TIME_DECLS
N  #define __TIME_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N    /* CLOCKS_PER_SEC: the number per second of the value returned by the
N     * clock function. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S  extern const int __aeabi_CLOCKS_PER_SEC;
S  #define CLOCKS_PER_SEC (__aeabi_CLOCKS_PER_SEC)
N#else
N  #ifdef __CLK_TCK
S    #define CLOCKS_PER_SEC  __CLK_TCK
N  #else
N    #define CLOCKS_PER_SEC  100
N  #endif
N#endif
N
N#ifndef __STRICT_ANSI__
N  #define CLK_TCK CLOCKS_PER_SEC
N#endif
N
Ntypedef unsigned int clock_t;    /* cpu time type */
Ntypedef unsigned int time_t;     /* date/time in unix secs past 1-Jan-70 */
N
N#pragma push
N#pragma anon_unions
N
Nstruct tm {
N    int tm_sec;   /* seconds after the minute, 0 to 60
N                     (0 - 60 allows for the occasional leap second) */
N    int tm_min;   /* minutes after the hour, 0 to 59 */
N    int tm_hour;  /* hours since midnight, 0 to 23 */
N    int tm_mday;  /* day of the month, 1 to 31 */
N    int tm_mon;   /* months since January, 0 to 11 */
N    int tm_year;  /* years since 1900 */
N    int tm_wday;  /* days since Sunday, 0 to 6 */
N    int tm_yday;  /* days since January 1, 0 to 365 */
N    int tm_isdst; /* Daylight Savings Time flag */
N    union {       /* ABI-required extra fields, in a variety of types */
N        struct {
N            int __extra_1, __extra_2;
N        };
N        struct {
N            long __extra_1_long, __extra_2_long;
N        };
N        struct {
N            char *__extra_1_cptr, *__extra_2_cptr;
N        };
N        struct {
N            void *__extra_1_vptr, *__extra_2_vptr;
N        };
N    };
N};
N
N#pragma pop
N
N   /* struct tm holds the components of a calendar time, called the broken-down
N    * time. The value of tm_isdst is positive if Daylight Savings Time is in
N    * effect, zero if Daylight Savings Time is not in effect, and negative if
N    * the information is not available.
N    */
N
Nextern _ARMABI clock_t clock(void);
Xextern __declspec(__nothrow) clock_t clock(void);
N   /* determines the processor time used.
N    * Returns: the implementation's best approximation to the processor time
N    *          used by the program since program invocation. The time in
N    *          seconds is the value returned divided by the value of the macro
N    *          CLK_TCK. The value (clock_t)-1 is returned if the processor time
N    *          used is not available.
N    */
Nextern _ARMABI double difftime(time_t /*time1*/, time_t /*time0*/);
Xextern __declspec(__nothrow) double difftime(time_t  , time_t  );
N   /*
N    * computes the difference between two calendar times: time1 - time0.
N    * Returns: the difference expressed in seconds as a double.
N    */
Nextern _ARMABI time_t mktime(struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) time_t mktime(struct tm *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the broken-down time, expressed as local time, in the structure
N    * pointed to by timeptr into a calendar time value with the same encoding
N    * as that of the values returned by the time function. The original values
N    * of the tm_wday and tm_yday components of the structure are ignored, and
N    * the original values of the other components are not restricted to the
N    * ranges indicated above. On successful completion, the values of the
N    * tm_wday and tm_yday structure components are set appropriately, and the
N    * other components are set to represent the specified calendar time, but
N    * with their values forced to the ranges indicated above; the final value
N    * of tm_mday is not set until tm_mon and tm_year are determined.
N    * Returns: the specified calendar time encoded as a value of type time_t.
N    *          If the calendar time cannot be represented, the function returns
N    *          the value (time_t)-1.
N    */
Nextern _ARMABI time_t time(time_t * /*timer*/);
Xextern __declspec(__nothrow) time_t time(time_t *  );
N   /*
N    * determines the current calendar time. The encoding of the value is
N    * unspecified.
N    * Returns: the implementations best approximation to the current calendar
N    *          time. The value (time_t)-1 is returned if the calendar time is
N    *          not available. If timer is not a null pointer, the return value
N    *          is also assigned to the object it points to.
N    */
N
Nextern _ARMABI char *asctime(const struct tm * /*timeptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *asctime(const struct tm *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI char *_asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *_asctime_r(const struct tm *  ,
N                                char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *asctime_r(const struct tm * /*timeptr*/,
Xextern __declspec(__nothrow) char *asctime_r(const struct tm *  ,
N                               char * __restrict /*buf*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the broken-down time in the structure pointed to by timeptr into
N    * a string in the form "Sun Sep 16 01:03:52 1973\n\0".
N    * Returns: a pointer to the string containing the date and time.
N    */
Nextern _ARMABI char *ctime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *ctime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer to local time in the form
N    * of a string. It is equivalent to asctime(localtime(timer));
N    * Returns: the pointer returned by the asctime function with that
N    *          broken-down time as argument.
N    */
Nextern _ARMABI struct tm *gmtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *gmtime(const time_t *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed as Greenwich Mean Time (GMT).
N    * Returns: a pointer to that object or a null pointer if GMT not available.
N    */
Nextern _ARMABI struct tm *localtime(const time_t * /*timer*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) struct tm *localtime(const time_t *  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI struct tm *_localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *_localtime_r(const time_t * __restrict  ,
N                                       struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI struct tm *localtime_r(const time_t * __restrict /*timer*/,
Xextern __declspec(__nothrow) struct tm *localtime_r(const time_t * __restrict  ,
N                                      struct tm * __restrict /*result*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * converts the calendar time pointed to by timer into a broken-down time,
N    * expressed a local time.
N    * Returns: a pointer to that object.
N    */
Nextern _ARMABI size_t strftime(char * __restrict /*s*/, size_t /*maxsize*/,
Xextern __declspec(__nothrow) size_t strftime(char * __restrict  , size_t  ,
N                       const char * __restrict /*format*/,
N                       const struct tm * __restrict /*timeptr*/) __attribute__((__nonnull__(1,3,4)));
N   /*
N    * places characters into the array pointed to by s as controlled by the
N    * string pointed to by format. The format string consists of zero or more
N    * directives and ordinary characters. A directive consists of a % character
N    * followed by a character that determines the directive's behaviour. All
N    * ordinary characters (including the terminating null character) are copied
N    * unchanged into the array. No more than maxsize characters are placed into
N    * the array. Each directive is replaced by appropriate characters  as
N    * described in the following list. The appropriate characters are
N    * determined by the LC_TIME category of the current locale and by the
N    * values contained in the structure pointed to by timeptr.
N    * %a is replaced by the locale's abbreviated weekday name.
N    * %A is replaced by the locale's full weekday name.
N    * %b is replaced by the locale's abbreviated month name.
N    * %B is replaced by the locale's full month name.
N    * %c is replaced by the locale's appropriate date and time representation.
N    * %d is replaced by the day of the month as a decimal number (01-31).
N    * %H is replaced by the hour (24-hour clock) as a decimal number (00-23).
N    * %I is replaced by the hour (12-hour clock) as a decimal number (01-12).
N    * %j is replaced by the day of the year as a decimal number (001-366).
N    * %m is replaced by the month as a decimal number (01-12).
N    * %M is replaced by the minute as a decimal number (00-59).
N    * %p is replaced by the locale's equivalent of either AM or PM designations
N    *       associated with a 12-hour clock.
N    * %S is replaced by the second as a decimal number (00-61).
N    * %U is replaced by the week number of the year (Sunday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %w is replaced by the weekday as a decimal number (0(Sunday) - 6).
N    * %W is replaced by the week number of the year (Monday as the first day of
N    *       week 1) as a decimal number (00-53).
N    * %x is replaced by the locale's appropriate date representation.
N    * %X is replaced by the locale's appropriate time representation.
N    * %y is replaced by the year without century as a decimal number (00-99).
N    * %Y is replaced by the year with century as a decimal number.
N    * %Z is replaced by the timezone name or abbreviation, or by no characters
N    *       if no time zone is determinable.
N    * %% is replaced by %.
N    * If a directive is not one of the above, the behaviour is undefined.
N    * Returns: If the total number of resulting characters including the
N    *          terminating null character is not more than maxsize, the
N    *          strftime function returns the number of characters placed into
N    *          the array pointed to by s not including the terminating null
N    *          character. otherwise, zero is returned and the contents of the
N    *          array are indeterminate.
N    */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __TIME_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
N    #ifndef __TIME_NO_EXPORTS
N      using ::std::clock_t;
N      using ::std::time_t;
N      using ::std::tm;
N      using ::std::tm;
N      using ::std::clock;
N      using ::std::difftime;
N      using ::std::mktime;
N      using ::std::time;
N      using ::std::asctime;
N      using ::std::_asctime_r;
N#ifndef __STRICT_ANSI__
N      using ::std::asctime_r;
N#endif
N      using ::std::ctime;
N      using ::std::gmtime;
N      using ::std::localtime;
N      using ::std::_localtime_r;
N#ifndef __STRICT_ANSI__
N      using ::std::localtime_r;
N#endif
N      using ::std::strftime;
N      using ::std::size_t;
N    #endif /* __TIME_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of time.h */
N
L 61 "mbed/./mbed.h" 2
N
N// mbed Debug libraries
N#include "platform/mbed_error.h"
L 1 "mbed/./platform/mbed_error.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_ERROR_H
N#define MBED_ERROR_H
N
N/** To generate a fatal compile-time error, you can use the pre-processor #error directive.
N *
N * @code
N * #error "That shouldn't have happened!"
N * @endcode
N *
N * If the compiler evaluates this line, it will report the error and stop the compile.
N *
N * For example, you could use this to check some user-defined compile-time variables:
N *
N * @code
N * #define NUM_PORTS 7
N * #if (NUM_PORTS > 4)
N *     #error "NUM_PORTS must be less than 4"
N * #endif
N * @endcode
N *
N * Reporting Run-Time Errors:
N * To generate a fatal run-time error, you can use the mbed error() function.
N *
N * @code
N * error("That shouldn't have happened!");
N * @endcode
N *
N * If the mbed running the program executes this function, it will print the
N * message via the USB serial port, and then die with the blue lights of death!
N *
N * The message can use printf-style formatting, so you can report variables in the
N * message too. For example, you could use this to check a run-time condition:
N *
N * @code
N * if(x >= 5) {
N *     error("expected x to be less than 5, but got %d", x);
N * }
N * #endcode
N */
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Nvoid error(const char* format, ...);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 64 "mbed/./mbed.h" 2
N#include "platform/mbed_interface.h"
L 1 "mbed/./platform/mbed_interface.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_INTERFACE_H
N#define MBED_INTERFACE_H
N
N#include <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS ::std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
N     /* be cooperative with glibc */
N     typedef __CLIBNS va_list __gnuc_va_list;
X     typedef ::std:: va_list __gnuc_va_list;
N     #define __GNUC_VA_LIST
N     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STDARG_NO_EXPORTS
N      using ::std::va_list;
N    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 23 "mbed/./platform/mbed_interface.h" 2
N
N#include "device.h"
N
N/* Mbed interface mac address
N * if MBED_MAC_ADD_x are zero, interface uid sets mac address,
N * otherwise MAC_ADD_x are used.
N */
N#define MBED_MAC_ADDR_INTERFACE 0x00
N#define MBED_MAC_ADDR_0  MBED_MAC_ADDR_INTERFACE
N#define MBED_MAC_ADDR_1  MBED_MAC_ADDR_INTERFACE
N#define MBED_MAC_ADDR_2  MBED_MAC_ADDR_INTERFACE
N#define MBED_MAC_ADDR_3  MBED_MAC_ADDR_INTERFACE
N#define MBED_MAC_ADDR_4  MBED_MAC_ADDR_INTERFACE
N#define MBED_MAC_ADDR_5  MBED_MAC_ADDR_INTERFACE
N#define MBED_MAC_ADDRESS_SUM (MBED_MAC_ADDR_0 | MBED_MAC_ADDR_1 | MBED_MAC_ADDR_2 | MBED_MAC_ADDR_3 | MBED_MAC_ADDR_4 | MBED_MAC_ADDR_5)
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N#if DEVICE_SEMIHOST
X#if 1
N
N/** Functions to control the mbed interface
N *
N * mbed Microcontrollers have a built-in interface to provide functionality such as
N * drag-n-drop download, reset, serial-over-usb, and access to the mbed local file
N * system. These functions provide means to control the interface suing semihost
N * calls it supports.
N */
N
N/** Determine whether the mbed interface is connected, based on whether debug is enabled
N *
N *  @returns
N *    1 if interface is connected,
N *    0 otherwise
N */
Nint mbed_interface_connected(void);
N
N/** Instruct the mbed interface to reset, as if the reset button had been pressed
N *
N *  @returns
N *    1 if successful,
N *    0 otherwise (e.g. interface not present)
N */
Nint mbed_interface_reset(void);
N
N/** This will disconnect the debug aspect of the interface, so semihosting will be disabled.
N * The interface will still support the USB serial aspect
N *
N *  @returns
N *    0 if successful,
N *   -1 otherwise (e.g. interface not present)
N */
Nint mbed_interface_disconnect(void);
N
N/** This will disconnect the debug aspect of the interface, and if the USB cable is not
N * connected, also power down the interface. If the USB cable is connected, the interface
N * will remain powered up and visible to the host
N *
N *  @returns
N *    0 if successful,
N *   -1 otherwise (e.g. interface not present)
N */
Nint mbed_interface_powerdown(void);
N
N/** This returns a string containing the 32-character UID of the mbed interface
N *  This is a weak function that can be overwritten if required
N *
N *  @param uid A 33-byte array to write the null terminated 32-byte string
N *
N *  @returns
N *    0 if successful,
N *   -1 otherwise (e.g. interface not present)
N */
Nint mbed_interface_uid(char *uid);
N
N#endif
N
N/** This returns a unique 6-byte MAC address, based on the interface UID
N * If the interface is not present, it returns a default fixed MAC address (00:02:F7:F0:00:00)
N *
N * This is a weak function that can be overwritten if you want to provide your own mechanism to
N * provide a MAC address.
N *
N *  @param mac A 6-byte array to write the MAC address
N */
Nvoid mbed_mac_address(char *mac);
N
N/** Cause the mbed to flash the BLOD (Blue LEDs Of Death) sequence
N */
Nvoid mbed_die(void);
N
N/** Print out an error message.  This is typically called when
N * hanlding a crash.
N *
N * @Note Synchronization level: Interrupt safe
N */
Nvoid mbed_error_printf(const char* format, ...);
N
N/** Print out an error message.  Similar to mbed_error_printf
N * but uses a va_list.
N *
N * @Note Synchronization level: Interrupt safe
N */
Nvoid mbed_error_vfprintf(const char * format, va_list arg);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 65 "mbed/./mbed.h" 2
N#include "platform/mbed_assert.h"
N
N// mbed Peripheral components
N#include "drivers/DigitalIn.h"
L 1 "mbed/./drivers/DigitalIn.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_DIGITALIN_H
N#define MBED_DIGITALIN_H
N
N#include "platform/platform.h"
N
N#include "hal/gpio_api.h"
L 1 "mbed/./hal/gpio_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_GPIO_API_H
N#define MBED_GPIO_API_H
N
N#include <stdint.h>
N#include "device.h"
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/**
N * \defgroup hal_gpio GPIO HAL functions
N * @{
N */
N
N/** Set the given pin as GPIO
N *
N * @param pin The pin to be set as GPIO
N * @return The GPIO port mask for this pin
N **/
Nuint32_t gpio_set(PinName pin);
N/* Checks if gpio object is connected (pin was not initialized with NC)
N * @param pin The pin to be set as GPIO
N * @return 0 if port is initialized with NC
N **/
Nint gpio_is_connected(const gpio_t *obj);
N
N/** Initialize the GPIO pin
N *
N * @param obj The GPIO object to initialize
N * @param pin The GPIO pin to initialize
N */
Nvoid gpio_init(gpio_t *obj, PinName pin);
N
N/** Set the input pin mode
N *
N * @param obj  The GPIO object
N * @param mode The pin mode to be set
N */
Nvoid gpio_mode(gpio_t *obj, PinMode mode);
N
N/** Set the pin direction
N *
N * @param obj       The GPIO object
N * @param direction The pin direction to be set
N */
Nvoid gpio_dir(gpio_t *obj, PinDirection direction);
N
N/** Set the output value
N *
N * @param obj   The GPIO object
N * @param value The value to be set
N */
Nvoid gpio_write(gpio_t *obj, int value);
N
N/** Read the input value
N *
N * @param obj The GPIO object
N * @return An integer value 1 or 0
N */
Nint gpio_read(gpio_t *obj);
N
N// the following functions are generic and implemented in the common gpio.c file
N// TODO: fix, will be moved to the common gpio header file
N
N/** Init the input pin and set mode to PullDefault
N *
N * @param obj The GPIO object
N * @param pin The pin name
N */
Nvoid gpio_init_in(gpio_t* gpio, PinName pin);
N
N/** Init the input pin and set the mode
N *
N * @param obj  The GPIO object
N * @param pin  The pin name
N * @param mode The pin mode to be set
N */
Nvoid gpio_init_in_ex(gpio_t* gpio, PinName pin, PinMode mode);
N
N/** Init the output pin as an output, with predefined output value 0
N *
N * @param obj The GPIO object
N * @param pin The pin name
N * @return An integer value 1 or 0
N */
Nvoid gpio_init_out(gpio_t* gpio, PinName pin);
N
N/** Init the pin as an output and set the output value
N *
N * @param obj   The GPIO object
N * @param pin   The pin name
N * @param value The value to be set
N */
Nvoid gpio_init_out_ex(gpio_t* gpio, PinName pin, int value);
N
N/** Init the pin to be in/out
N *
N * @param obj       The GPIO object
N * @param pin       The pin name
N * @param direction The pin direction to be set
N * @param mode      The pin mode to be set
N * @param value     The value to be set for an output pin
N */
Nvoid gpio_init_inout(gpio_t* gpio, PinName pin, PinDirection direction, PinMode mode, int value);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 22 "mbed/./drivers/DigitalIn.h" 2
N#include "platform/mbed_critical.h"
L 1 "mbed/./platform/mbed_critical.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/*
N * Copyright (c) 2015-2016, ARM Limited, All Rights Reserved
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the "License"); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __MBED_UTIL_CRITICAL_H__
N#define __MBED_UTIL_CRITICAL_H__
N
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
S    #define bool _Bool
S    #define true 1
S    #define false 0
N  #else
N    #ifdef __GNUC__
N      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
N         compatibility by defining _Bool */
N      #define _Bool bool
N    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 25 "mbed/./platform/mbed_critical.h" 2
N#include <stdint.h>
N#include <stddef.h>
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N
N/** Determine the current interrupts enabled state
N  *
N  * This function can be called to determine whether or not interrupts are currently enabled.
N  * \note
N  * NOTE:
N  * This function works for both cortex-A and cortex-M, although the underlyng implementation
N  * differs.
N  * @return true if interrupts are enabled, false otherwise
N  */
Nbool core_util_are_interrupts_enabled(void);
N
N/** Mark the start of a critical section
N  *
N  * This function should be called to mark the start of a critical section of code.
N  * \note
N  * NOTES:
N  * 1) The use of this style of critical section is targetted at C based implementations.
N  * 2) These critical sections can be nested.
N  * 3) The interrupt enable state on entry to the first critical section (of a nested set, or single
N  *    section) will be preserved on exit from the section.
N  * 4) This implementation will currently only work on code running in privileged mode.
N  */
Nvoid core_util_critical_section_enter(void);
N
N/** Mark the end of a critical section
N  *
N  * This function should be called to mark the end of a critical section of code.
N  * \note
N  * NOTES:
N  * 1) The use of this style of critical section is targetted at C based implementations.
N  * 2) These critical sections can be nested.
N  * 3) The interrupt enable state on entry to the first critical section (of a nested set, or single
N  *    section) will be preserved on exit from the section.
N  * 4) This implementation will currently only work on code running in privileged mode.
N  */
Nvoid core_util_critical_section_exit(void);
N
N/**
N * Atomic compare and set. It compares the contents of a memory location to a
N * given value and, only if they are the same, modifies the contents of that
N * memory location to a given new value. This is done as a single atomic
N * operation. The atomicity guarantees that the new value is calculated based on
N * up-to-date information; if the value had been updated by another thread in
N * the meantime, the write would fail due to a mismatched expectedCurrentValue.
N *
N * Refer to https://en.wikipedia.org/wiki/Compare-and-set [which may redirect
N * you to the article on compare-and swap].
N *
N * @param  ptr                  The target memory location.
N * @param[in,out] expectedCurrentValue A pointer to some location holding the
N *                              expected current value of the data being set atomically.
N *                              The computed 'desiredValue' should be a function of this current value.
N *                              @Note: This is an in-out parameter. In the
N *                              failure case of atomic_cas (where the
N *                              destination isn't set), the pointee of expectedCurrentValue is
N *                              updated with the current value.
N * @param[in] desiredValue      The new value computed based on '*expectedCurrentValue'.
N *
N * @return                      true if the memory location was atomically
N *                              updated with the desired value (after verifying
N *                              that it contained the expectedCurrentValue),
N *                              false otherwise. In the failure case,
N *                              exepctedCurrentValue is updated with the new
N *                              value of the target memory location.
N *
N * pseudocode:
N * function cas(p : pointer to int, old : pointer to int, new : int) returns bool {
N *     if *p != *old {
N *         *old = *p
N *         return false
N *     }
N *     *p = new
N *     return true
N * }
N *
N * @Note: In the failure case (where the destination isn't set), the value
N * pointed to by expectedCurrentValue is still updated with the current value.
N * This property helps writing concise code for the following incr:
N *
N * function incr(p : pointer to int, a : int) returns int {
N *     done = false
N *     value = *p // This fetch operation need not be atomic.
N *     while not done {
N *         done = atomic_cas(p, &value, value + a) // *value gets updated automatically until success
N *     }
N *     return value + a
N * }
N */
Nbool core_util_atomic_cas_u8(uint8_t *ptr, uint8_t *expectedCurrentValue, uint8_t desiredValue);
N
N/**
N * Atomic compare and set. It compares the contents of a memory location to a
N * given value and, only if they are the same, modifies the contents of that
N * memory location to a given new value. This is done as a single atomic
N * operation. The atomicity guarantees that the new value is calculated based on
N * up-to-date information; if the value had been updated by another thread in
N * the meantime, the write would fail due to a mismatched expectedCurrentValue.
N *
N * Refer to https://en.wikipedia.org/wiki/Compare-and-set [which may redirect
N * you to the article on compare-and swap].
N *
N * @param  ptr                  The target memory location.
N * @param[in,out] expectedCurrentValue A pointer to some location holding the
N *                              expected current value of the data being set atomically.
N *                              The computed 'desiredValue' should be a function of this current value.
N *                              @Note: This is an in-out parameter. In the
N *                              failure case of atomic_cas (where the
N *                              destination isn't set), the pointee of expectedCurrentValue is
N *                              updated with the current value.
N * @param[in] desiredValue      The new value computed based on '*expectedCurrentValue'.
N *
N * @return                      true if the memory location was atomically
N *                              updated with the desired value (after verifying
N *                              that it contained the expectedCurrentValue),
N *                              false otherwise. In the failure case,
N *                              exepctedCurrentValue is updated with the new
N *                              value of the target memory location.
N *
N * pseudocode:
N * function cas(p : pointer to int, old : pointer to int, new : int) returns bool {
N *     if *p != *old {
N *         *old = *p
N *         return false
N *     }
N *     *p = new
N *     return true
N * }
N *
N * @Note: In the failure case (where the destination isn't set), the value
N * pointed to by expectedCurrentValue is still updated with the current value.
N * This property helps writing concise code for the following incr:
N *
N * function incr(p : pointer to int, a : int) returns int {
N *     done = false
N *     value = *p // This fetch operation need not be atomic.
N *     while not done {
N *         done = atomic_cas(p, &value, value + a) // *value gets updated automatically until success
N *     }
N *     return value + a
N * }
N */
Nbool core_util_atomic_cas_u16(uint16_t *ptr, uint16_t *expectedCurrentValue, uint16_t desiredValue);
N
N/**
N * Atomic compare and set. It compares the contents of a memory location to a
N * given value and, only if they are the same, modifies the contents of that
N * memory location to a given new value. This is done as a single atomic
N * operation. The atomicity guarantees that the new value is calculated based on
N * up-to-date information; if the value had been updated by another thread in
N * the meantime, the write would fail due to a mismatched expectedCurrentValue.
N *
N * Refer to https://en.wikipedia.org/wiki/Compare-and-set [which may redirect
N * you to the article on compare-and swap].
N *
N * @param  ptr                  The target memory location.
N * @param[in,out] expectedCurrentValue A pointer to some location holding the
N *                              expected current value of the data being set atomically.
N *                              The computed 'desiredValue' should be a function of this current value.
N *                              @Note: This is an in-out parameter. In the
N *                              failure case of atomic_cas (where the
N *                              destination isn't set), the pointee of expectedCurrentValue is
N *                              updated with the current value.
N * @param[in] desiredValue      The new value computed based on '*expectedCurrentValue'.
N *
N * @return                      true if the memory location was atomically
N *                              updated with the desired value (after verifying
N *                              that it contained the expectedCurrentValue),
N *                              false otherwise. In the failure case,
N *                              exepctedCurrentValue is updated with the new
N *                              value of the target memory location.
N *
N * pseudocode:
N * function cas(p : pointer to int, old : pointer to int, new : int) returns bool {
N *     if *p != *old {
N *         *old = *p
N *         return false
N *     }
N *     *p = new
N *     return true
N * }
N *
N * @Note: In the failure case (where the destination isn't set), the value
N * pointed to by expectedCurrentValue is still updated with the current value.
N * This property helps writing concise code for the following incr:
N *
N * function incr(p : pointer to int, a : int) returns int {
N *     done = false
N *     value = *p // This fetch operation need not be atomic.
N *     while not done {
N *         done = atomic_cas(p, &value, value + a) // *value gets updated automatically until success
N *     }
N *     return value + a
N * }
N */
Nbool core_util_atomic_cas_u32(uint32_t *ptr, uint32_t *expectedCurrentValue, uint32_t desiredValue);
N
N/**
N * Atomic compare and set. It compares the contents of a memory location to a
N * given value and, only if they are the same, modifies the contents of that
N * memory location to a given new value. This is done as a single atomic
N * operation. The atomicity guarantees that the new value is calculated based on
N * up-to-date information; if the value had been updated by another thread in
N * the meantime, the write would fail due to a mismatched expectedCurrentValue.
N *
N * Refer to https://en.wikipedia.org/wiki/Compare-and-set [which may redirect
N * you to the article on compare-and swap].
N *
N * @param  ptr                  The target memory location.
N * @param[in,out] expectedCurrentValue A pointer to some location holding the
N *                              expected current value of the data being set atomically.
N *                              The computed 'desiredValue' should be a function of this current value.
N *                              @Note: This is an in-out parameter. In the
N *                              failure case of atomic_cas (where the
N *                              destination isn't set), the pointee of expectedCurrentValue is
N *                              updated with the current value.
N * @param[in] desiredValue      The new value computed based on '*expectedCurrentValue'.
N *
N * @return                      true if the memory location was atomically
N *                              updated with the desired value (after verifying
N *                              that it contained the expectedCurrentValue),
N *                              false otherwise. In the failure case,
N *                              exepctedCurrentValue is updated with the new
N *                              value of the target memory location.
N *
N * pseudocode:
N * function cas(p : pointer to int, old : pointer to int, new : int) returns bool {
N *     if *p != *old {
N *         *old = *p
N *         return false
N *     }
N *     *p = new
N *     return true
N * }
N *
N * @Note: In the failure case (where the destination isn't set), the value
N * pointed to by expectedCurrentValue is still updated with the current value.
N * This property helps writing concise code for the following incr:
N *
N * function incr(p : pointer to int, a : int) returns int {
N *     done = false
N *     value = *p // This fetch operation need not be atomic.
N *     while not done {
N *         done = atomic_cas(p, &value, value + a) // *value gets updated automatically until success
N *     }
N *     return value + a
N * }
N */
Nbool core_util_atomic_cas_ptr(void **ptr, void **expectedCurrentValue, void *desiredValue);
N
N/**
N * Atomic increment.
N * @param  valuePtr Target memory location being incremented.
N * @param  delta    The amount being incremented.
N * @return          The new incremented value.
N */
Nuint8_t core_util_atomic_incr_u8(uint8_t *valuePtr, uint8_t delta);
N
N/**
N * Atomic increment.
N * @param  valuePtr Target memory location being incremented.
N * @param  delta    The amount being incremented.
N * @return          The new incremented value.
N */
Nuint16_t core_util_atomic_incr_u16(uint16_t *valuePtr, uint16_t delta);
N
N/**
N * Atomic increment.
N * @param  valuePtr Target memory location being incremented.
N * @param  delta    The amount being incremented.
N * @return          The new incremented value.
N */
Nuint32_t core_util_atomic_incr_u32(uint32_t *valuePtr, uint32_t delta);
N
N/**
N * Atomic increment.
N * @param  valuePtr Target memory location being incremented.
N * @param  delta    The amount being incremented in bytes.
N * @return          The new incremented value.
N *
N * @note The type of the pointer argument is not taken into account
N *       and the pointer is incremented by bytes.
N */
Nvoid *core_util_atomic_incr_ptr(void **valuePtr, ptrdiff_t delta);
N
N/**
N * Atomic decrement.
N * @param  valuePtr Target memory location being decremented.
N * @param  delta    The amount being decremented.
N * @return          The new decremented value.
N */
Nuint8_t core_util_atomic_decr_u8(uint8_t *valuePtr, uint8_t delta);
N
N/**
N * Atomic decrement.
N * @param  valuePtr Target memory location being decremented.
N * @param  delta    The amount being decremented.
N * @return          The new decremented value.
N */
Nuint16_t core_util_atomic_decr_u16(uint16_t *valuePtr, uint16_t delta);
N
N/**
N * Atomic decrement.
N * @param  valuePtr Target memory location being decremented.
N * @param  delta    The amount being decremented.
N * @return          The new decremented value.
N */
Nuint32_t core_util_atomic_decr_u32(uint32_t *valuePtr, uint32_t delta);
N
N/**
N * Atomic decrement.
N * @param  valuePtr Target memory location being decremented.
N * @param  delta    The amount being decremented in bytes.
N * @return          The new decremented value.
N *
N * @note The type of the pointer argument is not taken into account
N *       and the pointer is decremented by bytes
N */
Nvoid *core_util_atomic_decr_ptr(void **valuePtr, ptrdiff_t delta);
N
N#ifdef __cplusplus
N} // extern "C"
N#endif
N
N
N#endif // __MBED_UTIL_CRITICAL_H__
N
N/** @}*/
L 23 "mbed/./drivers/DigitalIn.h" 2
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A digital input, used for reading the state of a pin
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example:
N * @code
N * // Flash an LED while a DigitalIn is true
N *
N * #include "mbed.h"
N *
N * DigitalIn enable(p5);
N * DigitalOut led(LED1);
N *
N * int main() {
N *     while(1) {
N *         if(enable) {
N *             led = !led;
N *         }
N *         wait(0.25);
N *     }
N * }
N * @endcode
N */
Nclass DigitalIn {
N
Npublic:
N    /** Create a DigitalIn connected to the specified pin
N     *
N     *  @param pin DigitalIn pin to connect to
N     */
N    DigitalIn(PinName pin) : gpio() {
N        // No lock needed in the constructor
N        gpio_init_in(&gpio, pin);
N    }
N
N    /** Create a DigitalIn connected to the specified pin
N     *
N     *  @param pin DigitalIn pin to connect to
N     *  @param mode the initial mode of the pin
N     */
N    DigitalIn(PinName pin, PinMode mode) : gpio() {
N        // No lock needed in the constructor
N        gpio_init_in_ex(&gpio, pin, mode);
N    }
N    /** Read the input, represented as 0 or 1 (int)
N     *
N     *  @returns
N     *    An integer representing the state of the input pin,
N     *    0 for logical 0, 1 for logical 1
N     */
N    int read() {
N        // Thread safe / atomic HAL call
N        return gpio_read(&gpio);
N    }
N
N    /** Set the input pin mode
N     *
N     *  @param mode PullUp, PullDown, PullNone, OpenDrain
N     */
N    void mode(PinMode pull) {
N        core_util_critical_section_enter();
N        gpio_mode(&gpio, pull);
N        core_util_critical_section_exit();
N    }
N
N    /** Return the output setting, represented as 0 or 1 (int)
N     *
N     *  @returns
N     *    Non zero value if pin is connected to uc GPIO
N     *    0 if gpio object was initialized with NC
N     */
N    int is_connected() {
N        // Thread safe / atomic HAL call
N        return gpio_is_connected(&gpio);
N    }
N
N    /** An operator shorthand for read()
N     */
N    operator int() {
N        // Underlying read is thread safe
N        return read();
N    }
N
Nprotected:
N    gpio_t gpio;
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 69 "mbed/./mbed.h" 2
N#include "drivers/DigitalOut.h"
L 1 "mbed/./drivers/DigitalOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_DIGITALOUT_H
N#define MBED_DIGITALOUT_H
N
N#include "platform/platform.h"
N#include "hal/gpio_api.h"
N#include "platform/mbed_critical.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A digital output, used for setting the state of a pin
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example:
N * @code
N * // Toggle a LED
N * #include "mbed.h"
N *
N * DigitalOut led(LED1);
N *
N * int main() {
N *     while(1) {
N *         led = !led;
N *         wait(0.2);
N *     }
N * }
N * @endcode
N */
Nclass DigitalOut {
N
Npublic:
N    /** Create a DigitalOut connected to the specified pin
N     *
N     *  @param pin DigitalOut pin to connect to
N     */
N    DigitalOut(PinName pin) : gpio() {
N        // No lock needed in the constructor
N        gpio_init_out(&gpio, pin);
N    }
N
N    /** Create a DigitalOut connected to the specified pin
N     *
N     *  @param pin DigitalOut pin to connect to
N     *  @param value the initial pin value
N     */
N    DigitalOut(PinName pin, int value) : gpio() {
N        // No lock needed in the constructor
N        gpio_init_out_ex(&gpio, pin, value);
N    }
N
N    /** Set the output, specified as 0 or 1 (int)
N     *
N     *  @param value An integer specifying the pin output value,
N     *      0 for logical 0, 1 (or any other non-zero value) for logical 1
N     */
N    void write(int value) {
N        // Thread safe / atomic HAL call
N        gpio_write(&gpio, value);
N    }
N
N    /** Return the output setting, represented as 0 or 1 (int)
N     *
N     *  @returns
N     *    an integer representing the output setting of the pin,
N     *    0 for logical 0, 1 for logical 1
N     */
N    int read() {
N        // Thread safe / atomic HAL call
N        return gpio_read(&gpio);
N    }
N
N    /** Return the output setting, represented as 0 or 1 (int)
N     *
N     *  @returns
N     *    Non zero value if pin is connected to uc GPIO
N     *    0 if gpio object was initialized with NC
N     */
N    int is_connected() {
N        // Thread safe / atomic HAL call
N        return gpio_is_connected(&gpio);
N    }
N
N    /** A shorthand for write()
N     */
N    DigitalOut& operator= (int value) {
N        // Underlying write is thread safe
N        write(value);
N        return *this;
N    }
N
N    DigitalOut& operator= (DigitalOut& rhs) {
N        core_util_critical_section_enter();
N        write(rhs.read());
N        core_util_critical_section_exit();
N        return *this;
N    }
N
N    /** A shorthand for read()
N     */
N    operator int() {
N        // Underlying call is thread safe
N        return read();
N    }
N
Nprotected:
N    gpio_t gpio;
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 70 "mbed/./mbed.h" 2
N#include "drivers/DigitalInOut.h"
L 1 "mbed/./drivers/DigitalInOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_DIGITALINOUT_H
N#define MBED_DIGITALINOUT_H
N
N#include "platform/platform.h"
N
N#include "hal/gpio_api.h"
N#include "platform/mbed_critical.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A digital input/output, used for setting or reading a bi-directional pin
N *
N * @Note Synchronization level: Interrupt safe
N */
Nclass DigitalInOut {
N
Npublic:
N    /** Create a DigitalInOut connected to the specified pin
N     *
N     *  @param pin DigitalInOut pin to connect to
N     */
N    DigitalInOut(PinName pin) : gpio() {
N        // No lock needed in the constructor
N        gpio_init_in(&gpio, pin);
N    }
N
N    /** Create a DigitalInOut connected to the specified pin
N     *
N     *  @param pin DigitalInOut pin to connect to
N     *  @param direction the initial direction of the pin
N     *  @param mode the initial mode of the pin
N     *  @param value the initial value of the pin if is an output
N     */
N    DigitalInOut(PinName pin, PinDirection direction, PinMode mode, int value) : gpio() {
N        // No lock needed in the constructor
N        gpio_init_inout(&gpio, pin, direction, mode, value);
N    }
N
N    /** Set the output, specified as 0 or 1 (int)
N     *
N     *  @param value An integer specifying the pin output value,
N     *      0 for logical 0, 1 (or any other non-zero value) for logical 1
N     */
N    void write(int value) {
N        // Thread safe / atomic HAL call
N        gpio_write(&gpio, value);
N    }
N
N    /** Return the output setting, represented as 0 or 1 (int)
N     *
N     *  @returns
N     *    an integer representing the output setting of the pin if it is an output,
N     *    or read the input if set as an input
N     */
N    int read() {
N        // Thread safe / atomic HAL call
N        return gpio_read(&gpio);
N    }
N
N    /** Set as an output
N     */
N    void output() {
N        core_util_critical_section_enter();
N        gpio_dir(&gpio, PIN_OUTPUT);
N        core_util_critical_section_exit();
N    }
N
N    /** Set as an input
N     */
N    void input() {
N        core_util_critical_section_enter();
N        gpio_dir(&gpio, PIN_INPUT);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the input pin mode
N     *
N     *  @param mode PullUp, PullDown, PullNone, OpenDrain
N     */
N    void mode(PinMode pull) {
N        core_util_critical_section_enter();
N        gpio_mode(&gpio, pull);
N        core_util_critical_section_exit();
N    }
N
N    /** Return the output setting, represented as 0 or 1 (int)
N     *
N     *  @returns
N     *    Non zero value if pin is connected to uc GPIO
N     *    0 if gpio object was initialized with NC
N     */
N    int is_connected() {
N        // Thread safe / atomic HAL call
N        return gpio_is_connected(&gpio);
N    }
N
N    /** A shorthand for write()
N     */
N    DigitalInOut& operator= (int value) {
N        // Underlying write is thread safe
N        write(value);
N        return *this;
N    }
N
N    DigitalInOut& operator= (DigitalInOut& rhs) {
N        core_util_critical_section_enter();
N        write(rhs.read());
N        core_util_critical_section_exit();
N        return *this;
N    }
N
N    /** A shorthand for read()
N     */
N    operator int() {
N        // Underlying call is thread safe
N        return read();
N    }
N
Nprotected:
N    gpio_t gpio;
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 71 "mbed/./mbed.h" 2
N#include "drivers/BusIn.h"
L 1 "mbed/./drivers/BusIn.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_BUSIN_H
N#define MBED_BUSIN_H
N
N#include "platform/platform.h"
N#include "drivers/DigitalIn.h"
N#include "platform/PlatformMutex.h"
L 1 "mbed/./platform/PlatformMutex.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef PLATFORM_MUTEX_H
N#define PLATFORM_MUTEX_H
N
N#ifdef MBED_CONF_RTOS_PRESENT
S#include "rtos/Mutex.h"
Stypedef rtos::Mutex PlatformMutex;
N#else
N/** A stub mutex for when an RTOS is not present
N*/
Nclass PlatformMutex {
Npublic:
N    PlatformMutex() {
N        // Stub
N
N    }
N    ~PlatformMutex() {
N        // Stub
N    }
N
N    void lock() {
N        // Do nothing
N    }
N
N    void unlock() {
N        // Do nothing
N    }
N};
N
N#endif
N
N#endif
N
N/** @}*/
L 22 "mbed/./drivers/BusIn.h" 2
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A digital input bus, used for reading the state of a collection of pins
N *
N * @Note Synchronization level: Thread safe
N */
Nclass BusIn {
N
Npublic:
N    /* Group: Configuration Methods */
N
N    /** Create an BusIn, connected to the specified pins
N     *
N     * @param <n> DigitalIn pin to connect to bus bit <n> (p5-p30, NC)
N     *
N     * @note
N     *  It is only required to specify as many pin variables as is required
N     *  for the bus; the rest will default to NC (not connected)
N     */
N    BusIn(PinName p0, PinName p1 = NC, PinName p2 = NC, PinName p3 = NC,
N          PinName p4 = NC, PinName p5 = NC, PinName p6 = NC, PinName p7 = NC,
N          PinName p8 = NC, PinName p9 = NC, PinName p10 = NC, PinName p11 = NC,
N          PinName p12 = NC, PinName p13 = NC, PinName p14 = NC, PinName p15 = NC);
N
N    BusIn(PinName pins[16]);
N
N    virtual ~BusIn();
N
N    /** Read the value of the input bus
N     *
N     *  @returns
N     *   An integer with each bit corresponding to the value read from the associated DigitalIn pin
N     */
N    int read();
N
N    /** Set the input pin mode
N     *
N     *  @param mode PullUp, PullDown, PullNone
N     */
N    void mode(PinMode pull);
N
N    /** Binary mask of bus pins connected to actual pins (not NC pins)
N     *  If bus pin is in NC state make corresponding bit will be cleared (set to 0), else bit will be set to 1
N     *
N     *  @returns
N     *    Binary mask of connected pins
N     */
N    int mask() {
N        // No lock needed since _nc_mask is not modified outside the constructor
N        return _nc_mask;
N    }
N
N    /** A shorthand for read()
N     */
N    operator int();
N
N    /** Access to particular bit in random-iterator fashion
N     */
N    DigitalIn & operator[] (int index);
N
Nprotected:
N    DigitalIn* _pin[16];
N
N    /** Mask of bus's NC pins
N     * If bit[n] is set to 1 - pin is connected
N     * if bit[n] is cleared - pin is not connected (NC)
N     */
N    int _nc_mask;
N
N    PlatformMutex _mutex;
N
N    /* disallow copy constructor and assignment operators */
Nprivate:
N    virtual void lock();
N    virtual void unlock();
N    BusIn(const BusIn&);
N    BusIn & operator = (const BusIn&);
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 72 "mbed/./mbed.h" 2
N#include "drivers/BusOut.h"
L 1 "mbed/./drivers/BusOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_BUSOUT_H
N#define MBED_BUSOUT_H
N
N#include "drivers/DigitalOut.h"
N#include "platform/PlatformMutex.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A digital output bus, used for setting the state of a collection of pins
N */
Nclass BusOut {
N
Npublic:
N
N    /** Create an BusOut, connected to the specified pins
N     *
N     *  @param p<n> DigitalOut pin to connect to bus bit <n> (p5-p30, NC)
N     *
N     *  @Note Synchronization level: Thread safe
N     *
N     *  @note
N     *  It is only required to specify as many pin variables as is required
N     *  for the bus; the rest will default to NC (not connected)
N     */
N    BusOut(PinName p0, PinName p1 = NC, PinName p2 = NC, PinName p3 = NC,
N           PinName p4 = NC, PinName p5 = NC, PinName p6 = NC, PinName p7 = NC,
N           PinName p8 = NC, PinName p9 = NC, PinName p10 = NC, PinName p11 = NC,
N           PinName p12 = NC, PinName p13 = NC, PinName p14 = NC, PinName p15 = NC);
N
N    BusOut(PinName pins[16]);
N
N    virtual ~BusOut();
N
N    /** Write the value to the output bus
N     *
N     *  @param value An integer specifying a bit to write for every corresponding DigitalOut pin
N     */
N    void write(int value);
N
N    /** Read the value currently output on the bus
N     *
N     *  @returns
N     *    An integer with each bit corresponding to associated DigitalOut pin setting
N     */
N    int read();
N
N    /** Binary mask of bus pins connected to actual pins (not NC pins)
N     *  If bus pin is in NC state make corresponding bit will be cleared (set to 0), else bit will be set to 1
N     *
N     *  @returns
N     *    Binary mask of connected pins
N     */
N    int mask() {
N        // No lock needed since _nc_mask is not modified outside the constructor
N        return _nc_mask;
N    }
N
N    /** A shorthand for write()
N     */
N    BusOut& operator= (int v);
N    BusOut& operator= (BusOut& rhs);
N
N    /** Access to particular bit in random-iterator fashion
N     */
N    DigitalOut& operator[] (int index);
N
N    /** A shorthand for read()
N     */
N    operator int();
N
Nprotected:
N    virtual void lock();
N    virtual void unlock();
N    DigitalOut* _pin[16];
N
N    /** Mask of bus's NC pins
N     * If bit[n] is set to 1 - pin is connected
N     * if bit[n] is cleared - pin is not connected (NC)
N     */
N    int _nc_mask;
N
N    PlatformMutex _mutex;
N
N   /* disallow copy constructor and assignment operators */
Nprivate:
N    BusOut(const BusOut&);
N    BusOut & operator = (const BusOut&);
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 73 "mbed/./mbed.h" 2
N#include "drivers/BusInOut.h"
L 1 "mbed/./drivers/BusInOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_BUSINOUT_H
N#define MBED_BUSINOUT_H
N
N#include "drivers/DigitalInOut.h"
N#include "platform/PlatformMutex.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A digital input output bus, used for setting the state of a collection of pins
N *
N * @Note Synchronization level: Thread safe
N */
Nclass BusInOut {
N
Npublic:
N
N    /** Create an BusInOut, connected to the specified pins
N     *
N     *  @param p<n> DigitalInOut pin to connect to bus bit p<n> (p5-p30, NC)
N     *
N     *  @note
N     *  It is only required to specify as many pin variables as is required
N     *  for the bus; the rest will default to NC (not connected)
N     */
N    BusInOut(PinName p0, PinName p1 = NC, PinName p2 = NC, PinName p3 = NC,
N             PinName p4 = NC, PinName p5 = NC, PinName p6 = NC, PinName p7 = NC,
N             PinName p8 = NC, PinName p9 = NC, PinName p10 = NC, PinName p11 = NC,
N             PinName p12 = NC, PinName p13 = NC, PinName p14 = NC, PinName p15 = NC);
N
N    BusInOut(PinName pins[16]);
N
N    virtual ~BusInOut();
N
N    /* Group: Access Methods */
N
N    /** Write the value to the output bus
N     *
N     *  @param value An integer specifying a bit to write for every corresponding DigitalInOut pin
N     */
N    void write(int value);
N
N    /** Read the value currently output on the bus
N     *
N     *  @returns
N     *    An integer with each bit corresponding to associated DigitalInOut pin setting
N     */
N    int read();
N
N    /** Set as an output
N     */
N    void output();
N
N    /** Set as an input
N     */
N    void input();
N
N    /** Set the input pin mode
N     *
N     *  @param mode PullUp, PullDown, PullNone
N     */
N    void mode(PinMode pull);
N
N    /** Binary mask of bus pins connected to actual pins (not NC pins)
N     *  If bus pin is in NC state make corresponding bit will be cleared (set to 0), else bit will be set to 1
N     *
N     *  @returns
N     *    Binary mask of connected pins
N     */
N    int mask() {
N        // No lock needed since _nc_mask is not modified outside the constructor
N        return _nc_mask;
N    }
N
N     /** A shorthand for write()
N     */
N    BusInOut& operator= (int v);
N    BusInOut& operator= (BusInOut& rhs);
N
N    /** Access to particular bit in random-iterator fashion
N    */
N    DigitalInOut& operator[] (int index);
N
N    /** A shorthand for read()
N     */
N    operator int();
N
Nprotected:
N    virtual void lock();
N    virtual void unlock();
N    DigitalInOut* _pin[16];
N
N    /** Mask of bus's NC pins
N     * If bit[n] is set to 1 - pin is connected
N     * if bit[n] is cleared - pin is not connected (NC)
N     */
N    int _nc_mask;
N
N    PlatformMutex _mutex;
N
N    /* disallow copy constructor and assignment operators */
Nprivate:
N    BusInOut(const BusInOut&);
N    BusInOut & operator = (const BusInOut&);
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 74 "mbed/./mbed.h" 2
N#include "drivers/PortIn.h"
L 1 "mbed/./drivers/PortIn.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PORTIN_H
N#define MBED_PORTIN_H
N
N#include "platform/platform.h"
N
N#if DEVICE_PORTIN
X#if 1
N
N#include "hal/port_api.h"
L 1 "mbed/./hal/port_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PORTMAP_H
N#define MBED_PORTMAP_H
N
N#include "device.h"
N
N#if DEVICE_PORTIN || DEVICE_PORTOUT
X#if 1 || 1
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Port HAL structure. port_s is declared in the target's HAL
N */
Ntypedef struct port_s port_t;
N
N/**
N * \defgroup hal_port Port HAL functions
N * @{
N */
N
N/** Get the pin name from the port's pin number
N *
N * @param port  The port name
N * @param pin_n The pin number within the specified port
N * @return The pin name for the port's pin number
N */
NPinName port_pin(PortName port, int pin_n);
N
N/** Initilize the port
N *
N * @param obj  The port object to initialize
N * @param port The port name
N * @param mask The bitmask to identify which bits in the port should be included (0 - ignore)
N * @param dir  The port direction
N */
Nvoid port_init(port_t *obj, PortName port, int mask, PinDirection dir);
N
N/** Set the input port mode
N *
N * @param obj  The port object
N * @param mode THe port mode to be set
N */
Nvoid port_mode(port_t *obj, PinMode mode);
N
N/** Set port direction (in/out)
N *
N * @param obj The port object
N * @param dir The port direction to be set
N */
Nvoid port_dir(port_t *obj, PinDirection dir);
N
N/** Write value to the port
N *
N * @param obj   The port object
N * @param value The value to be set
N */
Nvoid port_write(port_t *obj, int value);
N
N/** Read the current value on the port
N *
N * @param obj The port object
N * @return An integer with each bit corresponding to an associated port pin setting
N */
Nint port_read(port_t *obj);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N#endif
N
N#endif
N
N/** @}*/
L 24 "mbed/./drivers/PortIn.h" 2
N#include "platform/mbed_critical.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A multiple pin digital input
N *
N * @Note Synchronization level: Interrupt safe
N *
N *  Example:
N * @code
N * // Switch on an LED if any of mbed pins 21-26 is high
N *
N * #include "mbed.h"
N *
N * PortIn     p(Port2, 0x0000003F);   // p21-p26
N * DigitalOut ind(LED4);
N *
N * int main() {
N *     while(1) {
N *         int pins = p.read();
N *         if(pins) {
N *             ind = 1;
N *         } else {
N *             ind = 0;
N *         }
N *     }
N * }
N * @endcode
N */
Nclass PortIn {
Npublic:
N
N    /** Create an PortIn, connected to the specified port
N     *
N     *  @param port Port to connect to (Port0-Port5)
N     *  @param mask A bitmask to identify which bits in the port should be included (0 - ignore)
N        */
N    PortIn(PortName port, int mask = 0xFFFFFFFF) {
N        core_util_critical_section_enter();
N        port_init(&_port, port, mask, PIN_INPUT);
N        core_util_critical_section_exit();
N    }
N
N    /** Read the value currently output on the port
N     *
N     *  @returns
N     *    An integer with each bit corresponding to associated port pin setting
N     */
N    int read() {
N        return port_read(&_port);
N    }
N
N    /** Set the input pin mode
N     *
N     *  @param mode PullUp, PullDown, PullNone, OpenDrain
N     */
N    void mode(PinMode mode) {
N        core_util_critical_section_enter();
N        port_mode(&_port, mode);
N        core_util_critical_section_exit();
N    }
N
N    /** A shorthand for read()
N     */
N    operator int() {
N        return read();
N    }
N
Nprivate:
N    port_t _port;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 75 "mbed/./mbed.h" 2
N#include "drivers/PortInOut.h"
L 1 "mbed/./drivers/PortInOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PORTINOUT_H
N#define MBED_PORTINOUT_H
N
N#include "platform/platform.h"
N
N#if DEVICE_PORTINOUT
X#if 1
N
N#include "hal/port_api.h"
N#include "platform/mbed_critical.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A multiple pin digital in/out used to set/read multiple bi-directional pins
N *
N * @Note Synchronization level: Interrupt safe
N */
Nclass PortInOut {
Npublic:
N
N    /** Create an PortInOut, connected to the specified port
N     *
N     *  @param port Port to connect to (Port0-Port5)
N     *  @param mask A bitmask to identify which bits in the port should be included (0 - ignore)
N     */
N    PortInOut(PortName port, int mask = 0xFFFFFFFF) {
N        core_util_critical_section_enter();
N        port_init(&_port, port, mask, PIN_INPUT);
N        core_util_critical_section_exit();
N    }
N
N    /** Write the value to the output port
N     *
N     *  @param value An integer specifying a bit to write for every corresponding port pin
N     */
N    void write(int value) {
N        port_write(&_port, value);
N    }
N
N    /** Read the value currently output on the port
N     *
N     *  @returns
N     *    An integer with each bit corresponding to associated port pin setting
N     */
N    int read() {
N        return port_read(&_port);
N    }
N
N    /** Set as an output
N     */
N    void output() {
N        core_util_critical_section_enter();
N        port_dir(&_port, PIN_OUTPUT);
N        core_util_critical_section_exit();
N    }
N
N    /** Set as an input
N     */
N    void input() {
N        core_util_critical_section_enter();
N        port_dir(&_port, PIN_INPUT);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the input pin mode
N     *
N     *  @param mode PullUp, PullDown, PullNone, OpenDrain
N     */
N    void mode(PinMode mode) {
N        core_util_critical_section_enter();
N        port_mode(&_port, mode);
N        core_util_critical_section_exit();
N    }
N
N    /** A shorthand for write()
N     */
N    PortInOut& operator= (int value) {
N        write(value);
N        return *this;
N    }
N
N    PortInOut& operator= (PortInOut& rhs) {
N        write(rhs.read());
N        return *this;
N    }
N
N    /** A shorthand for read()
N     */
N    operator int() {
N        return read();
N    }
N
Nprivate:
N    port_t _port;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 76 "mbed/./mbed.h" 2
N#include "drivers/PortOut.h"
L 1 "mbed/./drivers/PortOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PORTOUT_H
N#define MBED_PORTOUT_H
N
N#include "platform/platform.h"
N
N#if DEVICE_PORTOUT
X#if 1
N
N#include "hal/port_api.h"
N#include "platform/mbed_critical.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N/** A multiple pin digital out
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example:
N * @code
N * // Toggle all four LEDs
N *
N * #include "mbed.h"
N *
N * // LED1 = P1.18  LED2 = P1.20  LED3 = P1.21  LED4 = P1.23
N * #define LED_MASK 0x00B40000
N *
N * PortOut ledport(Port1, LED_MASK);
N *
N * int main() {
N *     while(1) {
N *         ledport = LED_MASK;
N *         wait(1);
N *         ledport = 0;
N *         wait(1);
N *     }
N * }
N * @endcode
N */
Nclass PortOut {
Npublic:
N
N    /** Create an PortOut, connected to the specified port
N     *
N     *  @param port Port to connect to (Port0-Port5)
N     *  @param mask A bitmask to identify which bits in the port should be included (0 - ignore)
N     */
N    PortOut(PortName port, int mask = 0xFFFFFFFF) {
N        core_util_critical_section_enter();
N        port_init(&_port, port, mask, PIN_OUTPUT);
N        core_util_critical_section_exit();
N    }
N
N    /** Write the value to the output port
N     *
N     *  @param value An integer specifying a bit to write for every corresponding PortOut pin
N     */
N    void write(int value) {
N        port_write(&_port, value);
N    }
N
N    /** Read the value currently output on the port
N     *
N     *  @returns
N     *    An integer with each bit corresponding to associated PortOut pin setting
N     */
N    int read() {
N        return port_read(&_port);
N    }
N
N    /** A shorthand for write()
N     */
N    PortOut& operator= (int value) {
N        write(value);
N        return *this;
N    }
N
N    PortOut& operator= (PortOut& rhs) {
N        write(rhs.read());
N        return *this;
N    }
N
N    /** A shorthand for read()
N     */
N    operator int() {
N        return read();
N    }
N
Nprivate:
N    port_t _port;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 77 "mbed/./mbed.h" 2
N#include "drivers/AnalogIn.h"
L 1 "mbed/./drivers/AnalogIn.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_ANALOGIN_H
N#define MBED_ANALOGIN_H
N
N#include "platform/platform.h"
N
N#if DEVICE_ANALOGIN
X#if 1
N
N#include "hal/analogin_api.h"
L 1 "mbed/./hal/analogin_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_ANALOGIN_API_H
N#define MBED_ANALOGIN_API_H
N
N#include "device.h"
N
N#if DEVICE_ANALOGIN
X#if 1
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Analogin hal structure. analogin_s is declared in the target's hal
N */
Ntypedef struct analogin_s analogin_t;
N
N/**
N * \defgroup hal_analogin Analogin hal functions
N * @{
N */
N
N/** Initialize the analogin peripheral
N *
N * Configures the pin used by analogin.
N * @param obj The analogin object to initialize
N * @param pin The analogin pin name
N */
Nvoid analogin_init(analogin_t *obj, PinName pin);
N
N/** Read the input voltage, represented as a float in the range [0.0, 1.0]
N *
N * @param obj The analogin object
N * @return A floating value representing the current input voltage
N */
Nfloat analogin_read(analogin_t *obj);
N
N/** Read the value from analogin pin, represented as an unsigned 16bit value
N *
N * @param obj The analogin object
N * @return An unsigned 16bit value representing the current input voltage
N */
Nuint16_t analogin_read_u16(analogin_t *obj);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N#endif
N
N/** @}*/
L 24 "mbed/./drivers/AnalogIn.h" 2
N#include "platform/SingletonPtr.h"
L 1 "mbed/./platform/SingletonPtr.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef SINGLETONPTR_H
N#define SINGLETONPTR_H
N
N#include <stdint.h>
N#include <new>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 1
N/*
N * C++ Library file new
N * Copyright 1993-2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N/* Edison Design Group, 1992-2013. */
N/*
Nnew -- Include file for C++ default operator new (see ARM 12.5).
N*/
N
N#ifndef __NEW_STDH
N#define __NEW_STDH
N#ifndef __STDDEF_H
N#include <stddef.h>
N#endif  /* ifndef __STDDEF_H */
N#ifndef __NEW
N#define __NEW
N#define __ARMCLIB_VERSION 5060037
N
N#ifndef __EXCEPTION_INCLUDED
N#include <exception>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\exception" 1
N/*
N * C++ Library file exception
N * Copyright 2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __EXCEPTION_INCLUDED
N#define __EXCEPTION_INCLUDED
N#define __ARMCLIB_VERSION 5060037
N
N/* Edison Design Group, 1995-2005. */
N/*
Nexception -- Include file for exception handling (see 18.6)
N*/
N
Nnamespace std {
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class exception {
N  public:
N    exception() throw();
N    exception(const exception&) throw();
N    exception& operator=(const exception&) throw();
N    virtual ~exception() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_exception : public exception {
N  public:
N    bad_exception() throw();
N    bad_exception(const bad_exception&) throw();
N    bad_exception& operator=(const bad_exception&) throw();
N    virtual ~bad_exception() throw();
N    virtual const char* what() const throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*terminate_handler)();
N  extern terminate_handler set_terminate(terminate_handler) throw();
N
N  typedef void (*unexpected_handler)();
N  extern unexpected_handler set_unexpected(unexpected_handler) throw();
N
N  void terminate();
N  void unexpected();
N
N  extern bool uncaught_exception() throw();
N
N}  /* namespace std */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __EXCEPTION_INCLUDED */
N
L 28 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 2
N#endif /* __EXCEPTION_INCLUDED */
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
Nnamespace std {
N#endif /* if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__ */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef unsigned long size_t;   /* see <stddef.h> */
N#else
N  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class bad_alloc : public exception {
N  public:
N    bad_alloc() throw();
N    bad_alloc(const bad_alloc&) throw();
N    bad_alloc& operator=(const bad_alloc&) throw();
N    virtual ~bad_alloc() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_array_new_length : public bad_alloc {
N  public:
N    bad_array_new_length() throw();
N    virtual ~bad_array_new_length() throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*new_handler)();
N  new_handler set_new_handler(new_handler) throw();
N  struct nothrow_t { };
N  // Declaration of object nothrow to permit the use of the placement new
N  // syntax: new (nothrow) T;
N  extern const nothrow_t nothrow;
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
N}  /* namespace std */
N#endif /* __EDG_RUNTIME_USES_NAMESPACES || __clang__ */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N/* Normal operator new. */
Nvoid *operator new(std::size_t) throw(std::bad_alloc);
N
N/* Normal operator delete. */
Nvoid operator delete(void*) throw ();
N
N/* Nothrow version of operator new. */
Nvoid *operator new(std::size_t, const std::nothrow_t&) throw();
N
N/* Nothrow version of operator delete. */
Nvoid operator delete(void*, const std::nothrow_t&) throw();
N
N/* Placement new. */
Ninline void *operator new(std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement delete. */
Ninline void operator delete(void*, void*) throw() { /* nothing */ }
N
N
N/* Array new. */
Nvoid *operator new[](std::size_t) throw(std::bad_alloc);
N
N/* Array delete. */
Nvoid operator delete[](void*) throw ();
N
N/* Placement array new. */
Ninline void *operator new[](std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement array delete. */
Ninline void operator delete[](void*, void*) throw() { /* nothing */ }
N
N/* Nothrow version of array new. */
Nvoid *operator new[](std::size_t,
N                     const std::nothrow_t&) throw();
N
N/* Nothrow version of array delete. */
Nvoid operator delete[](void*,
N                       const std::nothrow_t&) throw();
N
N#endif /*__NEW */
N/* End of new */
N
N#endif /*__NEW_STDH */
L 24 "mbed/./platform/SingletonPtr.h" 2
N#include "platform/mbed_assert.h"
N#ifdef MBED_CONF_RTOS_PRESENT
S#include "cmsis_os.h"
N#endif
N
N#ifdef MBED_CONF_RTOS_PRESENT
Sextern osMutexId singleton_mutex_id;
N#endif
N
N/** Lock the singleton mutex
N *
N * This function is typically used to provide
N * exclusive access when initializing a
N * global object.
N */
Ninline static void singleton_lock(void)
N{
N#ifdef MBED_CONF_RTOS_PRESENT
S    osMutexWait(singleton_mutex_id, osWaitForever);
N#endif
N}
N
N/** Unlock the singleton mutex
N *
N * This function is typically used to provide
N * exclusive access when initializing a
N * global object.
N */
Ninline static void singleton_unlock(void)
N{
N#ifdef MBED_CONF_RTOS_PRESENT
S    osMutexRelease (singleton_mutex_id);
N#endif
N}
N
N/** Utility class for creating an using a singleton
N *
N * @Note Synchronization level: Thread safe
N *
N * @Note: This class must only be used in a static context -
N * this class must never be allocated or created on the
N * stack.
N *
N * @Note: This class is lazily initialized on first use.
N * This class is a POD type so if it is not used it will
N * be garbage collected.
N */
Ntemplate <class T>
Nstruct SingletonPtr {
N
N    /** Get a pointer to the underlying singleton
N     *
N     * @returns
N     *   A pointer to the singleton
N     */
N    T* get() {
N        if (NULL == _ptr) {
X        if (0 == _ptr) {
N            singleton_lock();
N            if (NULL == _ptr) {
X            if (0 == _ptr) {
N                _ptr = new (_data) T();
N            }
N            singleton_unlock();
N        }
N        // _ptr was not zero initialized or was
N        // corrupted if this assert is hit
N        MBED_ASSERT(_ptr == (T *)&_data);
X        do { if (!(_ptr == (T *)&_data)) { mbed_assert_internal("_ptr == (T *)&_data", "mbed/./platform/SingletonPtr.h", 89); } } while (0);
N        return _ptr;
N    }
N
N    /** Get a pointer to the underlying singleton
N     *
N     * @returns
N     *   A pointer to the singleton
N     */
N    T* operator->() {
N        return get();
N    }
N
N    // This is zero initialized when in global scope
N    T *_ptr;
N    // Force data to be 4 byte aligned
N    uint32_t _data[(sizeof(T) + sizeof(uint32_t) - 1) / sizeof(uint32_t)];
N};
N
N#endif
N
N/** @}*/
L 25 "mbed/./drivers/AnalogIn.h" 2
N#include "platform/PlatformMutex.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** An analog input, used for reading the voltage on a pin
N *
N * @Note Synchronization level: Thread safe
N *
N * Example:
N * @code
N * // Print messages when the AnalogIn is greater than 50%
N *
N * #include "mbed.h"
N *
N * AnalogIn temperature(p20);
N *
N * int main() {
N *     while(1) {
N *         if(temperature > 0.5) {
N *             printf("Too hot! (%f)", temperature.read());
N *         }
N *     }
N * }
N * @endcode
N */
Nclass AnalogIn {
N
Npublic:
N
N    /** Create an AnalogIn, connected to the specified pin
N     *
N     * @param pin AnalogIn pin to connect to
N     * @param name (optional) A string to identify the object
N     */
N    AnalogIn(PinName pin) {
N        lock();
N        analogin_init(&_adc, pin);
N        unlock();
N    }
N
N    /** Read the input voltage, represented as a float in the range [0.0, 1.0]
N     *
N     * @returns A floating-point value representing the current input voltage, measured as a percentage
N     */
N    float read() {
N        lock();
N        float ret = analogin_read(&_adc);
N        unlock();
N        return ret;
N    }
N
N    /** Read the input voltage, represented as an unsigned short in the range [0x0, 0xFFFF]
N     *
N     * @returns
N     *   16-bit unsigned short representing the current input voltage, normalised to a 16-bit value
N     */
N    unsigned short read_u16() {
N        lock();
N        unsigned short ret = analogin_read_u16(&_adc);
N        unlock();
N        return ret;
N    }
N
N    /** An operator shorthand for read()
N     *
N     * The float() operator can be used as a shorthand for read() to simplify common code sequences
N     *
N     * Example:
N     * @code
N     * float x = volume.read();
N     * float x = volume;
N     *
N     * if(volume.read() > 0.25) { ... }
N     * if(volume > 0.25) { ... }
N     * @endcode
N     */
N    operator float() {
N        // Underlying call is thread safe
N        return read();
N    }
N
N    virtual ~AnalogIn() {
N        // Do nothing
N    }
N
Nprotected:
N
N    virtual void lock() {
N        _mutex->lock();
N    }
N
N    virtual void unlock() {
N        _mutex->unlock();
N    }
N
N    analogin_t _adc;
N    static SingletonPtr<PlatformMutex> _mutex;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 78 "mbed/./mbed.h" 2
N#include "drivers/AnalogOut.h"
L 1 "mbed/./drivers/AnalogOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_ANALOGOUT_H
N#define MBED_ANALOGOUT_H
N
N#include "platform/platform.h"
N
N#if DEVICE_ANALOGOUT
X#if 1
N
N#include "hal/analogout_api.h"
L 1 "mbed/./hal/analogout_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_ANALOGOUT_API_H
N#define MBED_ANALOGOUT_API_H
N
N#include "device.h"
N
N#if DEVICE_ANALOGOUT
X#if 1
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Analogout hal structure. dac_s is declared in the target's hal
N */
Ntypedef struct dac_s dac_t;
N
N/**
N * \defgroup hal_analogout Analogout hal functions
N * @{
N */
N
N/** Initialize the analogout peripheral
N *
N * Configures the pin used by analogout.
N * @param obj The analogout object to initialize
N * @param pin The analogout pin name
N */
Nvoid analogout_init(dac_t *obj, PinName pin);
N
N/** Release the analogout object
N *
N * Note: This is not currently used in the mbed-drivers
N * @param obj The analogout object
N */
Nvoid analogout_free(dac_t *obj);
N
N/** Set the output voltage, specified as a percentage (float)
N *
N * @param obj The analogin object
N * @param value The floating-point output voltage to be set
N */
Nvoid analogout_write(dac_t *obj, float value);
N
N/** Set the output voltage, specified as unsigned 16-bit
N *
N * @param obj The analogin object
N * @param value The unsigned 16-bit output voltage to be set
N */
Nvoid analogout_write_u16(dac_t *obj, uint16_t value);
N
N/** Read the current voltage value on the pin
N *
N * @param obj The analogin object
N * @return A floating-point value representing the current voltage on the pin,
N *     measured as a percentage
N */
Nfloat analogout_read(dac_t *obj);
N
N/** Read the current voltage value on the pin, as a normalized unsigned 16bit value
N *
N * @param obj The analogin object
N * @return An unsigned 16-bit value representing the current voltage on the pin
N */
Nuint16_t analogout_read_u16(dac_t *obj);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N#endif
N
N/** @}*/
L 24 "mbed/./drivers/AnalogOut.h" 2
N#include "platform/PlatformMutex.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** An analog output, used for setting the voltage on a pin
N *
N * @Note Synchronization level: Thread safe
N *
N * Example:
N * @code
N * // Make a sawtooth output
N *
N * #include "mbed.h"
N *
N * AnalogOut tri(p18);
N * int main() {
N *     while(1) {
N *         tri = tri + 0.01;
N *         wait_us(1);
N *         if(tri == 1) {
N *             tri = 0;
N *         }
N *     }
N * }
N * @endcode
N */
Nclass AnalogOut {
N
Npublic:
N
N    /** Create an AnalogOut connected to the specified pin
N     *
N     *  @param AnalogOut pin to connect to (18)
N     */
N    AnalogOut(PinName pin) {
N        analogout_init(&_dac, pin);
N    }
N
N    /** Set the output voltage, specified as a percentage (float)
N     *
N     *  @param value A floating-point value representing the output voltage,
N     *    specified as a percentage. The value should lie between
N     *    0.0f (representing 0v / 0%) and 1.0f (representing 3.3v / 100%).
N     *    Values outside this range will be saturated to 0.0f or 1.0f.
N     */
N    void write(float value) {
N        lock();
N        analogout_write(&_dac, value);
N        unlock();
N    }
N
N    /** Set the output voltage, represented as an unsigned short in the range [0x0, 0xFFFF]
N     *
N     *  @param value 16-bit unsigned short representing the output voltage,
N     *            normalised to a 16-bit value (0x0000 = 0v, 0xFFFF = 3.3v)
N     */
N    void write_u16(unsigned short value) {
N        lock();
N        analogout_write_u16(&_dac, value);
N        unlock();
N    }
N
N    /** Return the current output voltage setting, measured as a percentage (float)
N     *
N     *  @returns
N     *    A floating-point value representing the current voltage being output on the pin,
N     *    measured as a percentage. The returned value will lie between
N     *    0.0f (representing 0v / 0%) and 1.0f (representing 3.3v / 100%).
N     *
N     *  @note
N     *    This value may not match exactly the value set by a previous write().
N     */
N    float read() {
N        lock();
N        float ret = analogout_read(&_dac);
N        unlock();
N        return ret;
N    }
N
N    /** An operator shorthand for write()
N     */
N    AnalogOut& operator= (float percent) {
N        // Underlying write call is thread safe
N        write(percent);
N        return *this;
N    }
N
N    AnalogOut& operator= (AnalogOut& rhs) {
N        // Underlying write call is thread safe
N        write(rhs.read());
N        return *this;
N    }
N
N    /** An operator shorthand for read()
N     */
N    operator float() {
N        // Underlying read call is thread safe
N        return read();
N    }
N
N    virtual ~AnalogOut() {
N        // Do nothing
N    }
N
Nprotected:
N
N    virtual void lock() {
N        _mutex.lock();
N    }
N
N    virtual void unlock() {
N        _mutex.unlock();
N    }
N
N    dac_t _dac;
N    PlatformMutex _mutex;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 79 "mbed/./mbed.h" 2
N#include "drivers/PwmOut.h"
L 1 "mbed/./drivers/PwmOut.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PWMOUT_H
N#define MBED_PWMOUT_H
N
N#include "platform/platform.h"
N
N#if DEVICE_PWMOUT
X#if 1
N#include "hal/pwmout_api.h"
L 1 "mbed/./hal/pwmout_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_PWMOUT_API_H
N#define MBED_PWMOUT_API_H
N
N#include "device.h"
N
N#if DEVICE_PWMOUT
X#if 1
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Pwmout hal structure. pwmout_s is declared in the target's hal
N */
Ntypedef struct pwmout_s pwmout_t;
N
N/**
N * \defgroup hal_pwmout Pwmout hal functions
N * @{
N */
N
N/** Initialize the pwm out peripheral and configure the pin
N *
N * @param obj The pwmout object to initialize
N * @param pin The pwmout pin to initialize
N */
Nvoid pwmout_init(pwmout_t *obj, PinName pin);
N
N/** Deinitialize the pwmout object
N *
N * @param obj The pwmout object
N */
Nvoid pwmout_free(pwmout_t *obj);
N
N/** Set the output duty-cycle in range <0.0f, 1.0f>
N *
N * Value 0.0f represents 0 percentage, 1.0f represents 100 percent.
N * @param obj     The pwmout object
N * @param percent The floating-point percentage number
N */
Nvoid pwmout_write(pwmout_t *obj, float percent);
N
N/** Read the current float-point output duty-cycle
N *
N * @param obj The pwmout object
N * @return A floating-point output duty-cycle
N */
Nfloat pwmout_read(pwmout_t *obj);
N
N/** Set the PWM period specified in seconds, keeping the duty cycle the same
N *
N * Periods smaller than microseconds (the lowest resolution) are set to zero.
N * @param obj     The pwmout object
N * @param seconds The floating-point seconds period
N */
Nvoid pwmout_period(pwmout_t *obj, float seconds);
N
N/** Set the PWM period specified in miliseconds, keeping the duty cycle the same
N *
N * @param obj The pwmout object
N * @param ms  The milisecond period
N */
Nvoid pwmout_period_ms(pwmout_t *obj, int ms);
N
N/** Set the PWM period specified in microseconds, keeping the duty cycle the same
N *
N * @param obj The pwmout object
N * @param us  The microsecond period
N */
Nvoid pwmout_period_us(pwmout_t *obj, int us);
N
N/** Set the PWM pulsewidth specified in seconds, keeping the period the same.
N *
N * @param obj     The pwmout object
N * @param seconds The floating-point pulsewidth in seconds
N */
Nvoid pwmout_pulsewidth(pwmout_t *obj, float seconds);
N
N/** Set the PWM pulsewidth specified in miliseconds, keeping the period the same.
N *
N * @param obj The pwmout object
N * @param ms  The floating-point pulsewidth in miliseconds
N */
Nvoid pwmout_pulsewidth_ms(pwmout_t *obj, int ms);
N
N/** Set the PWM pulsewidth specified in microseconds, keeping the period the same.
N *
N * @param obj The pwmout object
N * @param us  The floating-point pulsewidth in microseconds
N */
Nvoid pwmout_pulsewidth_us(pwmout_t *obj, int us);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N#endif
N
N/** @}*/
L 23 "mbed/./drivers/PwmOut.h" 2
N#include "platform/mbed_critical.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A pulse-width modulation digital output
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example
N * @code
N * // Fade a led on.
N * #include "mbed.h"
N *
N * PwmOut led(LED1);
N *
N * int main() {
N *     while(1) {
N *         led = led + 0.01;
N *         wait(0.2);
N *         if(led == 1.0) {
N *             led = 0;
N *         }
N *     }
N * }
N * @endcode
N *
N * @note
N *  On the LPC1768 and LPC2368, the PWMs all share the same
N *  period - if you change the period for one, you change it for all.
N *  Although routines that change the period maintain the duty cycle
N *  for its PWM, all other PWMs will require their duty cycle to be
N *  refreshed.
N */
Nclass PwmOut {
N
Npublic:
N
N    /** Create a PwmOut connected to the specified pin
N     *
N     *  @param pin PwmOut pin to connect to
N     */
N    PwmOut(PinName pin) {
N        core_util_critical_section_enter();
N        pwmout_init(&_pwm, pin);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the ouput duty-cycle, specified as a percentage (float)
N     *
N     *  @param value A floating-point value representing the output duty-cycle,
N     *    specified as a percentage. The value should lie between
N     *    0.0f (representing on 0%) and 1.0f (representing on 100%).
N     *    Values outside this range will be saturated to 0.0f or 1.0f.
N     */
N    void write(float value) {
N        core_util_critical_section_enter();
N        pwmout_write(&_pwm, value);
N        core_util_critical_section_exit();
N    }
N
N    /** Return the current output duty-cycle setting, measured as a percentage (float)
N     *
N     *  @returns
N     *    A floating-point value representing the current duty-cycle being output on the pin,
N     *    measured as a percentage. The returned value will lie between
N     *    0.0f (representing on 0%) and 1.0f (representing on 100%).
N     *
N     *  @note
N     *  This value may not match exactly the value set by a previous <write>.
N     */
N    float read() {
N        core_util_critical_section_enter();
N        float val = pwmout_read(&_pwm);
N        core_util_critical_section_exit();
N        return val;
N    }
N
N    /** Set the PWM period, specified in seconds (float), keeping the duty cycle the same.
N     *
N     *  @note
N     *   The resolution is currently in microseconds; periods smaller than this
N     *   will be set to zero.
N     */
N    void period(float seconds) {
N        core_util_critical_section_enter();
N        pwmout_period(&_pwm, seconds);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the PWM period, specified in milli-seconds (int), keeping the duty cycle the same.
N     */
N    void period_ms(int ms) {
N        core_util_critical_section_enter();
N        pwmout_period_ms(&_pwm, ms);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the PWM period, specified in micro-seconds (int), keeping the duty cycle the same.
N     */
N    void period_us(int us) {
N        core_util_critical_section_enter();
N        pwmout_period_us(&_pwm, us);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the PWM pulsewidth, specified in seconds (float), keeping the period the same.
N     */
N    void pulsewidth(float seconds) {
N        core_util_critical_section_enter();
N        pwmout_pulsewidth(&_pwm, seconds);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the PWM pulsewidth, specified in milli-seconds (int), keeping the period the same.
N     */
N    void pulsewidth_ms(int ms) {
N        core_util_critical_section_enter();
N        pwmout_pulsewidth_ms(&_pwm, ms);
N        core_util_critical_section_exit();
N    }
N
N    /** Set the PWM pulsewidth, specified in micro-seconds (int), keeping the period the same.
N     */
N    void pulsewidth_us(int us) {
N        core_util_critical_section_enter();
N        pwmout_pulsewidth_us(&_pwm, us);
N        core_util_critical_section_exit();
N    }
N
N    /** A operator shorthand for write()
N     */
N    PwmOut& operator= (float value) {
N        // Underlying call is thread safe
N        write(value);
N        return *this;
N    }
N
N    PwmOut& operator= (PwmOut& rhs) {
N        // Underlying call is thread safe
N        write(rhs.read());
N        return *this;
N    }
N
N    /** An operator shorthand for read()
N     */
N    operator float() {
N        // Underlying call is thread safe
N        return read();
N    }
N
Nprotected:
N    pwmout_t _pwm;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 80 "mbed/./mbed.h" 2
N#include "drivers/Serial.h"
L 1 "mbed/./drivers/Serial.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SERIAL_H
N#define MBED_SERIAL_H
N
N#include "platform/platform.h"
N
N#if DEVICE_SERIAL
X#if 1
N
N#include "Stream.h"
L 1 "mbed/./drivers/Stream.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_STREAM_H
N#define MBED_STREAM_H
N
N#include "platform/platform.h"
N#include "drivers/FileLike.h"
L 1 "mbed/./drivers/FileLike.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_FILELIKE_H
N#define MBED_FILELIKE_H
N
N#include "platform/mbed_toolchain.h"
N#include "drivers/FileBase.h"
L 1 "mbed/./drivers/FileBase.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_FILEBASE_H
N#define MBED_FILEBASE_H
N
Ntypedef int FILEHANDLE;
N
N#include <cstdio>
N#include <cstring>
N
N#include "platform/platform.h"
N#include "platform/SingletonPtr.h"
N#include "platform/PlatformMutex.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
Ntypedef enum {
N    FilePathType,
N    FileSystemPathType
N} PathType;
N
Nclass FileBase {
Npublic:
N    FileBase(const char *name, PathType t);
N    virtual ~FileBase();
N
N    const char* getName(void);
N    PathType    getPathType(void);
N
N    static FileBase *lookup(const char *name, unsigned int len);
N
N    static FileBase *get(int n);
N
N    /* disallow copy constructor and assignment operators */
Nprivate:
N    static FileBase *_head;
N    static SingletonPtr<PlatformMutex> _mutex;
N
N    FileBase   *_next;
N    const char * const _name;
N    const PathType _path_type;
N    FileBase(const FileBase&);
N    FileBase & operator = (const FileBase&);
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 21 "mbed/./drivers/FileLike.h" 2
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N
N/* Class FileLike
N *  A file-like object is one that can be opened with fopen by
N *  fopen("/name", mode).
N *
N *  @Note Synchronization level: Set by subclass
N */
Nclass FileLike : public FileBase {
Npublic:
N    /** Constructor FileLike
N     *
N     *  @param name     The name to use to open the file.
N     */
N    FileLike(const char *name = NULL) : FileBase(name, FilePathType) {}
X    FileLike(const char *name = 0) : FileBase(name, FilePathType) {}
N    virtual ~FileLike() {}
N
N    /** Read the contents of a file into a buffer
N     *
N     *  @param buffer   The buffer to read in to
N     *  @param size     The number of bytes to read
N     *  @return         The number of bytes read, 0 at end of file, negative error on failure
N     */
N    virtual ssize_t read(void *buffer, size_t len) = 0;
N
N    /** Write the contents of a buffer to a file
N     *
N     *  @param buffer   The buffer to write from
N     *  @param size     The number of bytes to write 
N     *  @return         The number of bytes written, negative error on failure
N     */
N    virtual ssize_t write(const void *buffer, size_t len) = 0;
N
N    /** Close a file
N     *
N     *  @return         0 on success, negative error code on failure
N     */
N    virtual int close() = 0;
N
N    /** Flush any buffers associated with the file
N     *
N     *  @return         0 on success, negative error code on failure
N     */
N    virtual int sync() = 0;
N
N    /** Check if the file in an interactive terminal device
N     *
N     *  @return         True if the file is a terminal
N     */
N    virtual int isatty() = 0;
N
N    /** Move the file position to a given offset from from a given location
N     *
N     *  @param offset   The offset from whence to move to
N     *  @param whence   The start of where to seek
N     *      SEEK_SET to start from beginning of file,
N     *      SEEK_CUR to start from current position in file,
N     *      SEEK_END to start from end of file
N     *  @return         The new offset of the file
N     */
N    virtual off_t seek(off_t offset, int whence = SEEK_SET) = 0;
X    virtual off_t seek(off_t offset, int whence = 0) = 0;
N
N    /** Get the file position of the file
N     *
N     *  @return         The current offset in the file
N     */
N    virtual off_t tell() = 0;
N
N    /** Rewind the file position to the beginning of the file
N     *
N     *  @note This is equivalent to file_seek(file, 0, FS_SEEK_SET)
N     */
N    virtual void rewind() = 0;
N
N    /** Get the size of the file
N     *
N     *  @return         Size of the file in bytes
N     */
N    virtual size_t size() = 0;
N
N    /** Move the file position to a given offset from a given location.
N     *
N     *  @param offset The offset from whence to move to
N     *  @param whence SEEK_SET for the start of the file, SEEK_CUR for the
N     *   current file position, or SEEK_END for the end of the file.
N     *
N     *  @returns
N     *    new file position on success,
N     *    -1 on failure or unsupported
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileLike::seek")
X    __attribute__((deprecated))
N    virtual off_t lseek(off_t offset, int whence) { return seek(offset, whence); }
N
N    /** Flush any buffers associated with the FileHandle, ensuring it
N     *  is up to date on disk
N     *
N     *  @returns
N     *    0 on success or un-needed,
N     *   -1 on error
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileLike::sync")
X    __attribute__((deprecated))
N    virtual int fsync() { return sync(); }
N
N    /** Find the length of the file
N     *
N     *  @returns
N     *   Length of the file
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4", "Replaced by FileLike::size")
X    __attribute__((deprecated))
N    virtual off_t flen() { return size(); }
N
Nprotected:
N    /** Acquire exclusive access to this object.
N     */
N    virtual void lock() {
N        // Stub
N    }
N
N    /** Release exclusive access to this object.
N     */
N    virtual void unlock() {
N        // Stub
N    }
N};
N
N
N/** @}*/
N} // namespace mbed
N
N#endif
L 21 "mbed/./drivers/Stream.h" 2
N#include "drivers/FileHandle.h"
L 1 "mbed/./drivers/FileHandle.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_FILEHANDLE_H
N#define MBED_FILEHANDLE_H
N
Ntypedef int FILEHANDLE;
N
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
S  #define __STDIO_DECLS
S
S    #undef __CLIBNS
S    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
S    #else /* ndef __cplusplus */
S      #define __CLIBNS
S    #endif /* ndef __cplusplus */
S
S#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
S /* always defined in C++ and non-strict C for consistency of debug info */
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
S    #define __size_t 1
S  #endif
S#endif
S
S#undef NULL
S#define NULL 0                   /* see <stddef.h> */
S
S/* ANSI forbids va_list to be defined here */
S/* keep in step with <stdarg.h> and <wchar.h> */
S#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
S/* always defined in C++ and non-strict C for consistency of debug info */
S  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
S  #else
S    typedef struct __va_list __va_list;
S  #endif
S  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
S    #define __va_list_defined 1
S  #endif
S#endif
S
S   /*
S    * If the compiler supports signalling nans as per N965 then it
S    * will define __SUPPORT_SNAN__, in which case a user may define
S    * _WANT_SNAN in order to obtain compliant versions of the printf
S    * and scanf families of functions
S    */
S#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
S#pragma import(__use_snan)
S#endif
S
Stypedef struct __fpos_t_struct {
S    unsigned __int64 __pos;
S    /*
S     * this structure is equivalent to an mbstate_t, but we're not
S     * allowed to actually define the type name `mbstate_t' within
S     * stdio.h
S     */
S    struct {
S        unsigned int __state1, __state2;
S    } __mbstate;
S} fpos_t;
S   /*
S    * fpos_t is an object capable of recording all information needed to
S    * specify uniquely every position within a file.
S    */
S
S#define _SYS_OPEN 16
S   /* _SYS_OPEN defines a limit on the number of open files that is imposed
S    * by this C library
S    */
S
Stypedef struct __FILE FILE;
S   /*
S    * FILE is an object capable of recording all information needed to control
S    * a stream, such as its file position indicator, a pointer to its
S    * associated buffer, an error indicator that records whether a read/write
S    * error has occurred and an end-of-file indicator that records whether the
S    * end-of-file has been reached.
S    * Its structure is not made known to library clients.
S    */
S
S#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
S#endif
S
S
Sextern FILE __stdin, __stdout, __stderr;
Sextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
S
S#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
S#else
S#define stdin  (&__CLIBNS __stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (&__CLIBNS __stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (&__CLIBNS __stderr)
S   /* pointer to a FILE object associated with standard error stream */
S
S#define _IOFBF           0x100 /* fully buffered IO */
S#define _IOLBF           0x200 /* line buffered IO */
S#define _IONBF           0x400 /* unbuffered IO */
S
S    /* Various default file IO buffer sizes */
S#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
S
S#define FOPEN_MAX _SYS_OPEN
S   /*
S    * an integral constant expression that is the minimum number of files that
S    * this implementation guarantees can be open simultaneously.
S    */
S
S#define FILENAME_MAX 256
S   /*
S    * an integral constant expression that is the size of an array of char
S    * large enough to hold the longest filename string
S    */
S#define L_tmpnam FILENAME_MAX
S   /*
S    * an integral constant expression that is the size of an array of char
S    * large enough to hold a temporary file name string generated by the
S    * tmpnam function.
S    */
S#define TMP_MAX 256
S   /*
S    * an integral constant expression that is the minimum number of unique
S    * file names that shall be generated by the tmpnam function.
S    */
S
S#endif
S
S#define EOF      (-1)
S   /*
S    * negative integral constant, indicates end-of-file, that is, no more input
S    * from a stream.
S    */
S
S#define SEEK_SET 0 /* start of stream (see fseek) */
S#define SEEK_CUR 1 /* current position in stream (see fseek) */
S#define SEEK_END 2 /* end of stream (see fseek) */
S
S    /*
S     * _IOBIN is the flag passed to _sys_write to denote a binary
S     * file.
S     */
S#define _IOBIN            0x04     /* binary stream */
S
S#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
S#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
S#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
S
Sextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
S   /*
S    * causes the file whose name is the string pointed to by filename to be
S    * removed. Subsequent attempts to open the file will fail, unless it is
S    * created anew. If the file is open, the behaviour of the remove function
S    * is implementation-defined.
S    * Returns: zero if the operation succeeds, nonzero if it fails.
S    */
Sextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * causes the file whose name is the string pointed to by old to be
S    * henceforth known by the name given by the string pointed to by new. The
S    * file named old is effectively removed. If a file named by the string
S    * pointed to by new exists prior to the call of the rename function, the
S    * behaviour is implementation-defined.
S    * Returns: zero if the operation succeeds, nonzero if it fails, in which
S    *          case if the file existed previously it is still known by its
S    *          original name.
S    */
Sextern _ARMABI FILE *tmpfile(void);
S   /*
S    * creates a temporary binary file that will be automatically removed when
S    * it is closed or at program termination. The file is opened for update.
S    * Returns: a pointer to the stream of the file that it created. If the file
S    *          cannot be created, a null pointer is returned.
S    */
Sextern _ARMABI char *tmpnam(char * /*s*/);
S   /*
S    * generates a string that is not the same as the name of an existing file.
S    * The tmpnam function generates a different string each time it is called,
S    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
S    * behaviour is implementation-defined.
S    * Returns: If the argument is a null pointer, the tmpnam function leaves
S    *          its result in an internal static object and returns a pointer to
S    *          that object. Subsequent calls to the tmpnam function may modify
S    *          the same object. if the argument is not a null pointer, it is
S    *          assumed to point to an array of at least L_tmpnam characters;
S    *          the tmpnam function writes its result in that array and returns
S    *          the argument as its value.
S    */
S
Sextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * causes the stream pointed to by stream to be flushed and the associated
S    * file to be closed. Any unwritten buffered data for the stream are
S    * delivered to the host environment to be written to the file; any unread
S    * buffered data are discarded. The stream is disassociated from the file.
S    * If the associated buffer was automatically allocated, it is deallocated.
S    * Returns: zero if the stream was succesfully closed, or nonzero if any
S    *          errors were detected or if the stream was already closed.
S    */
Sextern _ARMABI int fflush(FILE * /*stream*/);
S   /*
S    * If the stream points to an output or update stream in which the most
S    * recent operation was output, the fflush function causes any unwritten
S    * data for that stream to be delivered to the host environment to be
S    * written to the file. If the stream points to an input or update stream,
S    * the fflush function undoes the effect of any preceding ungetc operation
S    * on the stream.
S    * Returns: nonzero if a write error occurs.
S    */
Sextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
S                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * opens the file whose name is the string pointed to by filename, and
S    * associates a stream with it.
S    * The argument mode points to a string beginning with one of the following
S    * sequences:
S    * "r"         open text file for reading
S    * "w"         create text file for writing, or truncate to zero length
S    * "a"         append; open text file or create for writing at eof
S    * "rb"        open binary file for reading
S    * "wb"        create binary file for writing, or truncate to zero length
S    * "ab"        append; open binary file or create for writing at eof
S    * "r+"        open text file for update (reading and writing)
S    * "w+"        create text file for update, or truncate to zero length
S    * "a+"        append; open text file or create for update, writing at eof
S    * "r+b"/"rb+" open binary file for update (reading and writing)
S    * "w+b"/"wb+" create binary file for update, or truncate to zero length
S    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
S    *
S    * Opening a file with read mode ('r' as the first character in the mode
S    * argument) fails if the file does not exist or cannot be read.
S    * Opening a file with append mode ('a' as the first character in the mode
S    * argument) causes all subsequent writes to be forced to the current end of
S    * file, regardless of intervening calls to the fseek function. In some
S    * implementations, opening a binary file with append mode ('b' as the
S    * second or third character in the mode argument) may initially position
S    * the file position indicator beyond the last data written, because of the
S    * NUL padding.
S    * When a file is opened with update mode ('+' as the second or third
S    * character in the mode argument), both input and output may be performed
S    * on the associated stream. However, output may not be directly followed
S    * by input without an intervening call to the fflush fuction or to a file
S    * positioning function (fseek, fsetpos, or rewind), and input be not be
S    * directly followed by output without an intervening call to the fflush
S    * fuction or to a file positioning function, unless the input operation
S    * encounters end-of-file. Opening a file with update mode may open or
S    * create a binary stream in some implementations. When opened, a stream
S    * is fully buffered if and only if it does not refer to an interactive
S    * device. The error and end-of-file indicators for the stream are
S    * cleared.
S    * Returns: a pointer to the object controlling the stream. If the open
S    *          operation fails, fopen returns a null pointer.
S    */
Sextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
S                    const char * __restrict /*mode*/,
S                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
S   /*
S    * opens the file whose name is the string pointed to by filename and
S    * associates the stream pointed to by stream with it. The mode argument is
S    * used just as in the fopen function.
S    * The freopen function first attempts to close any file that is associated
S    * with the specified stream. Failure to close the file successfully is
S    * ignored. The error and end-of-file indicators for the stream are cleared.
S    * Returns: a null pointer if the operation fails. Otherwise, freopen
S    *          returns the value of the stream.
S    */
Sextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
S                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
S   /*
S    * Except that it returns no value, the setbuf function is equivalent to the
S    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
S    * size, or (if buf is a null pointer), with the value _IONBF for mode.
S    * Returns: no value.
S    */
Sextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
S                   char * __restrict /*buf*/,
S                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
S   /*
S    * may be used after the stream pointed to by stream has been associated
S    * with an open file but before it is read or written. The argument mode
S    * determines how stream will be buffered, as follows: _IOFBF causes
S    * input/output to be fully buffered; _IOLBF causes output to be line
S    * buffered (the buffer will be flushed when a new-line character is
S    * written, when the buffer is full, or when input is requested); _IONBF
S    * causes input/output to be completely unbuffered. If buf is not the null
S    * pointer, the array it points to may be used instead of an automatically
S    * allocated buffer (the buffer must have a lifetime at least as great as
S    * the open stream, so the stream should be closed before a buffer that has
S    * automatic storage duration is deallocated upon block exit). The argument
S    * size specifies the size of the array. The contents of the array at any
S    * time are indeterminate.
S    * Returns: zero on success, or nonzero if an invalid value is given for
S    *          mode or size, or if the request cannot be honoured.
S    */
S#pragma __printf_args
Sextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
S                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * writes output to the stream pointed to by stream, under control of the
S    * string pointed to by format that specifies how subsequent arguments are
S    * converted for output. If there are insufficient arguments for the format,
S    * the behaviour is undefined. If the format is exhausted while arguments
S    * remain, the excess arguments are evaluated but otherwise ignored. The
S    * fprintf function returns when the end of the format string is reached.
S    * The format shall be a multibyte character sequence, beginning and ending
S    * in its initial shift state. The format is composed of zero or more
S    * directives: ordinary multibyte characters (not %), which are copied
S    * unchanged to the output stream; and conversion specifiers, each of which
S    * results in fetching zero or more subsequent arguments. Each conversion
S    * specification is introduced by the character %. For a description of the
S    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
S    * draft mentioned at the start of this file or to any modern textbook on C.
S    * The minimum value for the maximum number of characters producable by any
S    * single conversion is at least 509.
S    * Returns: the number of characters transmitted, or a negative value if an
S    *          output error occurred.
S    */
S#pragma __printf_args
Sextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
S                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to fprintf, but does not support floating-point formats.
S    * You can use instead of fprintf to improve code size.
S    * Returns: as fprintf.
S    */
S#pragma __printf_args
Sextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
S   /*
S    * is equivalent to fprintf with the argument stdout interposed before the
S    * arguments to printf.
S    * Returns: the number of characters transmitted, or a negative value if an
S    *          output error occurred.
S    */
S#pragma __printf_args
Sextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
S   /*
S    * is equivalent to printf, but does not support floating-point formats.
S    * You can use instead of printf to improve code size.
S    * Returns: as printf.
S    */
S#pragma __printf_args
Sextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to fprintf, except that the argument s specifies an array
S    * into which the generated output is to be written, rather than to a
S    * stream. A null character is written at the end of the characters written;
S    * it is not counted as part of the returned sum.
S    * Returns: the number of characters written to the array, not counting the
S    *          terminating null character.
S    */
S#pragma __printf_args
Sextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to sprintf, but does not support floating-point formats.
S    * You can use instead of sprintf to improve code size.
S    * Returns: as sprintf.
S    */
S
S#pragma __printf_args
Sextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
S                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
S
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S#pragma __printf_args
Sextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
S                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
S   /*
S    * is equivalent to fprintf, except that the argument s specifies an array
S    * into which the generated output is to be written, rather than to a
S    * stream. The argument n specifies the size of the output array, so as to
S    * avoid overflowing the buffer.
S    * A null character is written at the end of the characters written, even
S    * if the formatting was not completed; it is not counted as part of the
S    * returned sum. At most n characters of the output buffer are used,
S    * _including_ the null character.
S    * Returns: the number of characters that would have been written to the
S    *          array, not counting the terminating null character, if the
S    *          array had been big enough. So if the return is >=0 and <n, then
S    *          the entire string was successfully formatted; if the return is
S    *          >=n, the string was truncated (but there is still a null char
S    *          at the end of what was written); if the return is <0, there was
S    *          an error.
S    */
S#endif
S#pragma __printf_args
Sextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
S                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
S   /*
S    * is equivalent to snprintf, but does not support floating-point formats.
S    * You can use instead of snprintf to improve code size.
S    * Returns: as snprintf.
S    */
S#pragma __scanf_args
Sextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
S                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * reads input from the stream pointed to by stream, under control of the
S    * string pointed to by format that specifies the admissible input sequences
S    * and how thay are to be converted for assignment, using subsequent
S    * arguments as pointers to the objects to receive the converted input. If
S    * there are insufficient arguments for the format, the behaviour is
S    * undefined. If the format is exhausted while arguments remain, the excess
S    * arguments are evaluated but otherwise ignored.
S    * The format is composed of zero or more directives: one or more
S    * white-space characters; an ordinary character (not %); or a conversion
S    * specification. Each conversion specification is introduced by the
S    * character %. For a description of the available conversion specifiers
S    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
S    * file, or to any modern textbook on C.
S    * If end-of-file is encountered during input, conversion is terminated. If
S    * end-of-file occurs before any characters matching the current directive
S    * have been read (other than leading white space, where permitted),
S    * execution of the current directive terminates with an input failure;
S    * otherwise, unless execution of the current directive is terminated with a
S    * matching failure, execution of the following directive (if any) is
S    * terminated with an input failure.
S    * If conversions terminates on a conflicting input character, the offending
S    * input character is left unread in the input strem. Trailing white space
S    * (including new-line characters) is left unread unless matched by a
S    * directive. The success of literal matches and suppressed asignments is
S    * not directly determinable other than via the %n directive.
S    * Returns: the value of the macro EOF if an input failure occurs before any
S    *          conversion. Otherwise, the fscanf function returns the number of
S    *          input items assigned, which can be fewer than provided for, or
S    *          even zero, in the event of an early conflict between an input
S    *          character and the format.
S    */
S#pragma __scanf_args
Sextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
S                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to fscanf, but does not support floating-point formats.
S    * You can use instead of fscanf to improve code size.
S    * Returns: as fscanf.
S    */
S#pragma __scanf_args
Sextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
S   /*
S    * is equivalent to fscanf with the argument stdin interposed before the
S    * arguments to scanf.
S    * Returns: the value of the macro EOF if an input failure occurs before any
S    *          conversion. Otherwise, the scanf function returns the number of
S    *          input items assigned, which can be fewer than provided for, or
S    *          even zero, in the event of an early matching failure.
S    */
S#pragma __scanf_args
Sextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
S   /*
S    * is equivalent to scanf, but does not support floating-point formats.
S    * You can use instead of scanf to improve code size.
S    * Returns: as scanf.
S    */
S#pragma __scanf_args
Sextern _ARMABI int sscanf(const char * __restrict /*s*/,
S                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to fscanf except that the argument s specifies a string
S    * from which the input is to be obtained, rather than from a stream.
S    * Reaching the end of the string is equivalent to encountering end-of-file
S    * for the fscanf function.
S    * Returns: the value of the macro EOF if an input failure occurs before any
S    *          conversion. Otherwise, the scanf function returns the number of
S    *          input items assigned, which can be fewer than provided for, or
S    *          even zero, in the event of an early matching failure.
S    */
S#pragma __scanf_args
Sextern _ARMABI int _sscanf(const char * __restrict /*s*/,
S                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to sscanf, but does not support floating-point formats.
S    * You can use instead of sscanf to improve code size.
S    * Returns: as sscanf.
S    */
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S/* C99 additions */
Sextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Sextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
S#endif
Sextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Sextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
S
Sextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
S   /*
S    * is equivalent to printf, with the variable argument list replaced by arg,
S    * which has been initialised by the va_start macro (and possibly subsequent
S    * va_arg calls). The vprintf function does not invoke the va_end function.
S    * Returns: the number of characters transmitted, or a negative value if an
S    *          output error occurred.
S    */
Sextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
S   /*
S    * is equivalent to vprintf, but does not support floating-point formats.
S    * You can use instead of vprintf to improve code size.
S    * Returns: as vprintf.
S    */
Sextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
S                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to fprintf, with the variable argument list replaced by
S    * arg, which has been initialised by the va_start macro (and possibly
S    * subsequent va_arg calls). The vfprintf function does not invoke the
S    * va_end function.
S    * Returns: the number of characters transmitted, or a negative value if an
S    *          output error occurred.
S    */
Sextern _ARMABI int vsprintf(char * __restrict /*s*/,
S                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to sprintf, with the variable argument list replaced by
S    * arg, which has been initialised by the va_start macro (and possibly
S    * subsequent va_arg calls). The vsprintf function does not invoke the
S    * va_end function.
S    * Returns: the number of characters written in the array, not counting the
S    *          terminating null character.
S    */
Sextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
S                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
Sextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
S                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
S   /*
S    * is equivalent to snprintf, with the variable argument list replaced by
S    * arg, which has been initialised by the va_start macro (and possibly
S    * subsequent va_arg calls). The vsprintf function does not invoke the
S    * va_end function.
S    * Returns: the number of characters that would have been written in the
S    *          array, not counting the terminating null character. As
S    *          snprintf.
S    */
S#endif
Sextern _ARMABI int _vsprintf(char * __restrict /*s*/,
S                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to vsprintf, but does not support floating-point formats.
S    * You can use instead of vsprintf to improve code size.
S    * Returns: as vsprintf.
S    */
Sextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
S                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * is equivalent to vfprintf, but does not support floating-point formats.
S    * You can use instead of vfprintf to improve code size.
S    * Returns: as vfprintf.
S    */
Sextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
S                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
S   /*
S    * is equivalent to vsnprintf, but does not support floating-point formats.
S    * You can use instead of vsnprintf to improve code size.
S    * Returns: as vsnprintf.
S    */
S#if !defined(__STRICT_ANSI__)
S#pragma __printf_args
Sextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Sextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
S#endif
S#pragma __printf_args
Sextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Sextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
S   /*
S    * dynamically allocates a buffer of the right size for the
S    * formatted string, and returns it in (*strp). Formal return value
S    * is the same as any other printf variant, except that it returns
S    * -1 if the buffer could not be allocated.
S    *
S    * (The functions with __ARM_ prefixed names are identical to the
S    * ones without, but are available in all compilation modes without
S    * violating user namespace.)
S    */
S
Sextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * obtains the next character (if present) as an unsigned char converted to
S    * an int, from the input stream pointed to by stream, and advances the
S    * associated file position indicator (if defined).
S    * Returns: the next character from the input stream pointed to by stream.
S    *          If the stream is at end-of-file, the end-of-file indicator is
S    *          set and fgetc returns EOF. If a read error occurs, the error
S    *          indicator is set and fgetc returns EOF.
S    */
Sextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
S                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
S   /*
S    * reads at most one less than the number of characters specified by n from
S    * the stream pointed to by stream into the array pointed to by s. No
S    * additional characters are read after a new-line character (which is
S    * retained) or after end-of-file. A null character is written immediately
S    * after the last character read into the array.
S    * Returns: s if successful. If end-of-file is encountered and no characters
S    *          have been read into the array, the contents of the array remain
S    *          unchanged and a null pointer is returned. If a read error occurs
S    *          during the operation, the array contents are indeterminate and a
S    *          null pointer is returned.
S    */
Sextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
S   /*
S    * writes the character specified by c (converted to an unsigned char) to
S    * the output stream pointed to by stream, at the position indicated by the
S    * asociated file position indicator (if defined), and advances the
S    * indicator appropriately. If the file position indicator is not defined,
S    * the character is appended to the output stream.
S    * Returns: the character written. If a write error occurs, the error
S    *          indicator is set and fputc returns EOF.
S    */
Sextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * writes the string pointed to by s to the stream pointed to by stream.
S    * The terminating null character is not written.
S    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
S    *          value.
S    */
Sextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * is equivalent to fgetc except that it may be implemented as an unsafe
S    * macro (stream may be evaluated more than once, so the argument should
S    * never be an expression with side-effects).
S    * Returns: the next character from the input stream pointed to by stream.
S    *          If the stream is at end-of-file, the end-of-file indicator is
S    *          set and getc returns EOF. If a read error occurs, the error
S    *          indicator is set and getc returns EOF.
S    */
S#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
S#else
S    #define getchar() getc(stdin)
S    extern _ARMABI int (getchar)(void);
S#endif
S   /*
S    * is equivalent to getc with the argument stdin.
S    * Returns: the next character from the input stream pointed to by stdin.
S    *          If the stream is at end-of-file, the end-of-file indicator is
S    *          set and getchar returns EOF. If a read error occurs, the error
S    *          indicator is set and getchar returns EOF.
S    */
Sextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
S   /*
S    * reads characters from the input stream pointed to by stdin into the array
S    * pointed to by s, until end-of-file is encountered or a new-line character
S    * is read. Any new-line character is discarded, and a null character is
S    * written immediately after the last character read into the array.
S    * Returns: s if successful. If end-of-file is encountered and no characters
S    *          have been read into the array, the contents of the array remain
S    *          unchanged and a null pointer is returned. If a read error occurs
S    *          during the operation, the array contents are indeterminate and a
S    *          null pointer is returned.
S    */
Sextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
S   /*
S    * is equivalent to fputc except that it may be implemented as aan unsafe
S    * macro (stream may be evaluated more than once, so the argument should
S    * never be an expression with side-effects).
S    * Returns: the character written. If a write error occurs, the error
S    *          indicator is set and putc returns EOF.
S    */
S#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
S#else
S    #define putchar(c) putc(c, stdout)
S    extern _ARMABI int (putchar)(int /*c*/);
S#endif
S   /*
S    * is equivalent to putc with the second argument stdout.
S    * Returns: the character written. If a write error occurs, the error
S    *          indicator is set and putc returns EOF.
S    */
Sextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
S   /*
S    * writes the string pointed to by s to the stream pointed to by stdout, and
S    * appends a new-line character to the output. The terminating null
S    * character is not written.
S    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
S    *          value.
S    */
Sextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
S   /*
S    * pushes the character specified by c (converted to an unsigned char) back
S    * onto the input stream pointed to by stream. The character will be
S    * returned by the next read on that stream. An intervening call to the
S    * fflush function or to a file positioning function (fseek, fsetpos,
S    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
S    * corresponding to the stream is unchanged.
S    * One character pushback is guaranteed. If the unget function is called too
S    * many times on the same stream without an intervening read or file
S    * positioning operation on that stream, the operation may fail.
S    * If the value of c equals that of the macro EOF, the operation fails and
S    * the input stream is unchanged.
S    * A successful call to the ungetc function clears the end-of-file
S    * indicator. The value of the file position indicator after reading or
S    * discarding all pushed-back characters shall be the same as it was before
S    * the characters were pushed back. For a text stream, the value of the file
S    * position indicator after a successful call to the ungetc function is
S    * unspecified until all pushed-back characters are read or discarded. For a
S    * binary stream, the file position indicator is decremented by each
S    * successful call to the ungetc function; if its value was zero before a
S    * call, it is indeterminate after the call.
S    * Returns: the character pushed back after conversion, or EOF if the
S    *          operation fails.
S    */
S
Sextern _ARMABI size_t fread(void * __restrict /*ptr*/,
S                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
S   /*
S    * reads into the array pointed to by ptr, up to nmemb members whose size is
S    * specified by size, from the stream pointed to by stream. The file
S    * position indicator (if defined) is advanced by the number of characters
S    * successfully read. If an error occurs, the resulting value of the file
S    * position indicator is indeterminate. If a partial member is read, its
S    * value is indeterminate. The ferror or feof function shall be used to
S    * distinguish between a read error and end-of-file.
S    * Returns: the number of members successfully read, which may be less than
S    *          nmemb if a read error or end-of-file is encountered. If size or
S    *          nmemb is zero, fread returns zero and the contents of the array
S    *          and the state of the stream remain unchanged.
S    */
S
Sextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
S                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
S   /*
S    * reads into the array pointed to by ptr, up to count characters from the
S    * stream pointed to by stream. The file position indicator (if defined)
S    * is advanced by the number of characters successfully read. If an error
S    * occurs, the resulting value of the file position indicator is
S    * indeterminate. The ferror or feof function shall be used to
S    * distinguish between a read error and end-of-file.  The call will block
S    * only if no characters are available.
S    * Returns: the number of characters successfully read, which may be less than
S    *          count. If count is zero, __fread_bytes_avail returns zero and
S    *          the contents of the array and the state of the stream remain
S    *          unchanged.
S    */
S
Sextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
S                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
S   /*
S    * writes, from the array pointed to by ptr up to nmemb members whose size
S    * is specified by size, to the stream pointed to by stream. The file
S    * position indicator (if defined) is advanced by the number of characters
S    * successfully written. If an error occurs, the resulting value of the file
S    * position indicator is indeterminate.
S    * Returns: the number of members successfully written, which will be less
S    *          than nmemb only if a write error is encountered.
S    */
S
Sextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * stores the current value of the file position indicator for the stream
S    * pointed to by stream in the object pointed to by pos. The value stored
S    * contains unspecified information usable by the fsetpos function for
S    * repositioning the stream to its position at the time  of the call to the
S    * fgetpos function.
S    * Returns: zero, if successful. Otherwise nonzero is returned and the
S    *          integer expression errno is set to an implementation-defined
S    *          nonzero value.
S    */
Sextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
S   /*
S    * sets the file position indicator for the stream pointed to by stream.
S    * For a binary stream, the new position is at the signed number of
S    * characters specified by offset away from the point specified by whence.
S    * The specified point is the beginning of the file for SEEK_SET, the
S    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
S    * A binary stream need not meaningfully support fseek calls with a whence
S    * value of SEEK_END.
S    * For a text stream, either offset shall be zero, or offset shall be a
S    * value returned by an earlier call to the ftell function on the same
S    * stream and whence shall be SEEK_SET.
S    * The fseek function clears the end-of-file indicator and undoes any
S    * effects of the ungetc function on the same stream. After an fseek call,
S    * the next operation on an update stream may be either input or output.
S    * Returns: nonzero only for a request that cannot be satisfied.
S    */
Sextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * sets  the file position indicator for the stream pointed to by stream
S    * according to the value of the object pointed to by pos, which shall be a
S    * value returned by an earlier call to the fgetpos function on the same
S    * stream.
S    * The fsetpos function clears the end-of-file indicator and undoes any
S    * effects of the ungetc function on the same stream. After an fsetpos call,
S    * the next operation on an update stream may be either input or output.
S    * Returns: zero, if successful. Otherwise nonzero is returned and the
S    *          integer expression errno is set to an implementation-defined
S    *          nonzero value.
S    */
Sextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * obtains the current value of the file position indicator for the stream
S    * pointed to by stream. For a binary stream, the value is the number of
S    * characters from the beginning of the file. For a text stream, the file
S    * position indicator contains unspecified information, usable by the fseek
S    * function for returning the file position indicator to its position at the
S    * time of the ftell call; the difference between two such return values is
S    * not necessarily a meaningful measure of the number of characters written
S    * or read.
S    * Returns: if successful, the current value of the file position indicator.
S    *          On failure, the ftell function returns -1L and sets the integer
S    *          expression errno to an implementation-defined nonzero value.
S    */
Sextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * sets the file position indicator for the stream pointed to by stream to
S    * the beginning of the file. It is equivalent to
S    *          (void)fseek(stream, 0L, SEEK_SET)
S    * except that the error indicator for the stream is also cleared.
S    * Returns: no value.
S    */
S
Sextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * clears the end-of-file and error indicators for the stream pointed to by
S    * stream. These indicators are cleared only when the file is opened or by
S    * an explicit call to the clearerr function or to the rewind function.
S    * Returns: no value.
S    */
S
Sextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * tests the end-of-file indicator for the stream pointed to by stream.
S    * Returns: nonzero iff the end-of-file indicator is set for stream.
S    */
Sextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
S   /*
S    * tests the error indicator for the stream pointed to by stream.
S    * Returns: nonzero iff the error indicator is set for stream.
S    */
Sextern _ARMABI void perror(const char * /*s*/);
S   /*
S    * maps the error number  in the integer expression errno to an error
S    * message. It writes a sequence of characters to the standard error stream
S    * thus: first (if s is not a null pointer and the character pointed to by
S    * s is not the null character), the string pointed to by s followed by a
S    * colon and a space; then an appropriate error message string followed by
S    * a new-line character. The contents of the error message strings are the
S    * same as those returned by the strerror function with argument errno,
S    * which are implementation-defined.
S    * Returns: no value.
S    */
S
Sextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
S    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
S     */
S
Sextern _ARMABI void __use_no_semihosting_swi(void);
Sextern _ARMABI void __use_no_semihosting(void);
S    /*
S     * Referencing either of these symbols will cause a link-time
S     * error if any library functions that use semihosting SWI
S     * calls are also present in the link, i.e. you define it if
S     * you want to make sure you haven't accidentally used any such
S     * SWIs.
S     */
S
S    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
S    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 1L && !0L
N    using ::std::size_t;
N    using ::std::fpos_t;
N    using ::std::FILE;
N    using ::std::remove;
N    using ::std::rename;
N    using ::std::tmpfile;
N    using ::std::tmpnam;
N    using ::std::fclose;
N    using ::std::fflush;
N    using ::std::fopen;
N    using ::std::freopen;
N    using ::std::setbuf;
N    using ::std::setvbuf;
N    using ::std::fprintf;
N    using ::std::_fprintf;
N    using ::std::printf;
N    using ::std::_printf;
N    using ::std::sprintf;
N    using ::std::_sprintf;
N    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N      using ::std::snprintf;
N      using ::std::vsnprintf;
N      using ::std::vfscanf;
N      using ::std::vscanf;
N      using ::std::vsscanf;
N    #endif
N    using ::std::_snprintf;
N    using ::std::_vsnprintf;
N#if !defined(__STRICT_ANSI__)
X#if !0L
N    using ::std::asprintf;
N    using ::std::vasprintf;
N#endif
N    using ::std::__ARM_asprintf;
N    using ::std::__ARM_vasprintf;
N    using ::std::__ARM_vsnprintf;
N    using ::std::__ARM_snprintf;
N    using ::std::__ARM_vsscanf;
N    using ::std::fscanf;
N    using ::std::_fscanf;
N    using ::std::scanf;
N    using ::std::_scanf;
N    using ::std::sscanf;
N    using ::std::_sscanf;
N    using ::std::_vfscanf;
N    using ::std::_vscanf;
N    using ::std::_vsscanf;
N    using ::std::vprintf;
N    using ::std::_vprintf;
N    using ::std::vfprintf;
N    using ::std::_vfprintf;
N    using ::std::vsprintf;
N    using ::std::_vsprintf;
N    using ::std::fgetc;
N    using ::std::fgets;
N    using ::std::fputc;
N    using ::std::fputs;
N    using ::std::getc;
N    using ::std::getchar;
N    using ::std::gets;
N    using ::std::putc;
N    using ::std::putchar;
N    using ::std::puts;
N    using ::std::ungetc;
N    using ::std::fread;
N    using ::std::__fread_bytes_avail;
N    using ::std::fwrite;
N    using ::std::fgetpos;
N    using ::std::fseek;
N    using ::std::fsetpos;
N    using ::std::ftell;
N    using ::std::rewind;
N    using ::std::clearerr;
N    using ::std::feof;
N    using ::std::ferror;
N    using ::std::perror;
N    using ::std::_fisatty;
N    using ::std::__use_no_semihosting_swi;
N    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 22 "mbed/./drivers/FileHandle.h" 2
N#include "platform/platform.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** An OO equivalent of the internal FILEHANDLE variable
N *  and associated _sys_* functions.
N *
N * FileHandle is an abstract class, needing at least sys_write and
N *  sys_read to be implmented for a simple interactive device.
N *
N * No one ever directly tals to/instanciates a FileHandle - it gets
N *  created by FileSystem, and wrapped up by stdio.
N *
N * @Note Synchronization level: Set by subclass
N */
Nclass FileHandle {
N
Npublic:
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "The mbed 2 filesystem classes have been superseeded by the FileSystem api, "
N        "Replaced by File")
X    __attribute__((deprecated))
N    FileHandle() {}
N
N    /** Write the contents of a buffer to the file
N     *
N     *  @param buffer the buffer to write from
N     *  @param length the number of characters to write
N     *
N     *  @returns
N     *  The number of characters written (possibly 0) on success, -1 on error.
N     */
N    virtual ssize_t write(const void* buffer, size_t length) = 0;
N
N    /** Close the file
N     *
N     *  @returns
N     *  Zero on success, -1 on error.
N     */
N    virtual int close() = 0;
N
N    /** Function read
N     *  Reads the contents of the file into a buffer
N     *
N     *  @param buffer the buffer to read in to
N     *  @param length the number of characters to read
N     *
N     *  @returns
N     *  The number of characters read (zero at end of file) on success, -1 on error.
N     */
N    virtual ssize_t read(void* buffer, size_t length) = 0;
N
N    /** Check if the handle is for a interactive terminal device.
N     * If so, line buffered behaviour is used by default
N     *
N     *  @returns
N     *    1 if it is a terminal,
N     *    0 otherwise
N     */
N    virtual int isatty() = 0;
N
N    /** Move the file position to a given offset from a given location.
N     *
N     *  @param offset The offset from whence to move to
N     *  @param whence SEEK_SET for the start of the file, SEEK_CUR for the
N     *   current file position, or SEEK_END for the end of the file.
N     *
N     *  @returns
N     *    new file position on success,
N     *    -1 on failure or unsupported
N     */
N    virtual off_t lseek(off_t offset, int whence) = 0;
N
N    /** Flush any buffers associated with the FileHandle, ensuring it
N     *  is up to date on disk
N     *
N     *  @returns
N     *    0 on success or un-needed,
N     *   -1 on error
N     */
N    virtual int fsync() = 0;
N
N    virtual off_t flen() {
N        lock();
N        /* remember our current position */
N        off_t pos = lseek(0, SEEK_CUR);
X        off_t pos = lseek(0, 1);
N        if(pos == -1) {
N            unlock();
N            return -1;
N        }
N        /* seek to the end to get the file length */
N        off_t res = lseek(0, SEEK_END);
X        off_t res = lseek(0, 2);
N        /* return to our old position */
N        lseek(pos, SEEK_SET);
X        lseek(pos, 0);
N        unlock();
N        return res;
N    }
N
N    virtual ~FileHandle() {};
N
Nprotected:
N
N    /** Acquire exclusive access to this object.
N     */
N    virtual void lock() {
N        // Stub
N    }
N
N    /** Release exclusive access to this object.
N     */
N    virtual void unlock() {
N        // Stub
N    }
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 22 "mbed/./drivers/Stream.h" 2
N#include <cstdarg>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdarg" 1
N/*
N * C++ header for C header stdarg.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstdarg
N#define __cstdarg
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STDARG_NO_EXPORTS 1
N  #include <stdarg.h>
N  #undef __STDARG_NO_EXPORTS
N
N  #undef __stdarg_h  // later inclusion of stdarg.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstdarg */
N
L 23 "mbed/./drivers/Stream.h" 2
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
Nextern void mbed_set_unbuffered_stream(FILE *_file);
Nextern int mbed_getc(FILE *_file);
Nextern char* mbed_gets(char *s, int size, FILE *_file);
N
N/** File stream
N *
N * @Note Synchronization level: Set by subclass
N */
Nclass Stream : public FileLike {
N
Npublic:
N    Stream(const char *name=NULL);
X    Stream(const char *name=0);
N    virtual ~Stream();
N
N    int putc(int c);
N    int puts(const char *s);
N    int getc();
N    char *gets(char *s, int size);
N    int printf(const char* format, ...);
N    int scanf(const char* format, ...);
N    int vprintf(const char* format, std::va_list args);
N    int vscanf(const char* format, std::va_list args);
N
N    operator std::FILE*() {return _file;}
N
Nprotected:
N    virtual int close();
N    virtual ssize_t write(const void* buffer, size_t length);
N    virtual ssize_t read(void* buffer, size_t length);
N    virtual off_t seek(off_t offset, int whence);
N    virtual off_t tell();
N    virtual void rewind();
N    virtual int isatty();
N    virtual int sync();
N    virtual size_t size();
N
N    virtual int _putc(int c) = 0;
N    virtual int _getc() = 0;
N
N    std::FILE *_file;
N
N    /* disallow copy constructor and assignment operators */
Nprivate:
N    Stream(const Stream&);
N    Stream & operator = (const Stream&);
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 24 "mbed/./drivers/Serial.h" 2
N#include "SerialBase.h"
L 1 "mbed/./drivers/SerialBase.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SERIALBASE_H
N#define MBED_SERIALBASE_H
N
N#include "platform/platform.h"
N
N#if DEVICE_SERIAL
X#if 1
N
N#include "Stream.h"
N#include "Callback.h"
L 1 "mbed/platform/Callback.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_CALLBACK_H
N#define MBED_CALLBACK_H
N
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
S  #define __STRING_DECLS
S
S    #undef __CLIBNS
S
S    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
S    #else
S      #define __CLIBNS
S    #endif  /* __cplusplus */
S
S#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
S /* unconditional in C++ and non-strict C for consistency of debug info */
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S#endif
S
S#undef NULL
S#define NULL 0                   /* see <stddef.h> */
S
Sextern _ARMABI void *memcpy(void * __restrict /*s1*/,
S                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies n characters from the object pointed to by s2 into the object
S    * pointed to by s1. If copying takes place between objects that overlap,
S    * the behaviour is undefined.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI void *memmove(void * /*s1*/,
S                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies n characters from the object pointed to by s2 into the object
S    * pointed to by s1. Copying takes place as if the n characters from the
S    * object pointed to by s2 are first copied into a temporary array of n
S    * characters that does not overlap the objects pointed to by s1 and s2,
S    * and then the n characters from the temporary array are copied into the
S    * object pointed to by s1.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies the string pointed to by s2 (including the terminating nul
S    * character) into the array pointed to by s1. If copying takes place
S    * between objects that overlap, the behaviour is undefined.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies not more than n characters (characters that follow a null
S    * character are not copied) from the array pointed to by s2 into the array
S    * pointed to by s1. If copying takes place between objects that overlap,
S    * the behaviour is undefined.
S    * Returns: the value of s1.
S    */
S
Sextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * appends a copy of the string pointed to by s2 (including the terminating
S    * null character) to the end of the string pointed to by s1. The initial
S    * character of s2 overwrites the null character at the end of s1.
S    * Returns: the value of s1.
S    */
Sextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * appends not more than n characters (a null character and characters that
S    * follow it are not appended) from the array pointed to by s2 to the end of
S    * the string pointed to by s1. The initial character of s2 overwrites the
S    * null character at the end of s1. A terminating null character is always
S    * appended to the result.
S    * Returns: the value of s1.
S    */
S
S/*
S * The sign of a nonzero value returned by the comparison functions is
S * determined by the sign of the difference between the values of the first
S * pair of characters (both interpreted as unsigned char) that differ in the
S * objects being compared.
S */
S
Sextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the first n characters of the object pointed to by s1 to the
S    * first n characters of the object pointed to by s2.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the object pointed to by s1 is greater than, equal to, or
S    *          less than the object pointed to by s2.
S    */
Sextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the string pointed to by s1 to the string pointed to by s2.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares not more than n characters (characters that follow a null
S    * character are not compared) from the array pointed to by s1 to the array
S    * pointed to by s2.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the string pointed to by s1 to the string pointed to by s2,
S    * case-insensitively as defined by the current locale.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares not more than n characters (characters that follow a null
S    * character are not compared) from the array pointed to by s1 to the array
S    * pointed to by s2, case-insensitively as defined by the current locale.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2.
S    */
Sextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * compares the string pointed to by s1 to the string pointed to by s2, both
S    * interpreted as appropriate to the LC_COLLATE category of the current
S    * locale.
S    * Returns: an integer greater than, equal to, or less than zero, according
S    *          as the string pointed to by s1 is greater than, equal to, or
S    *          less than the string pointed to by s2 when both are interpreted
S    *          as appropriate to the current locale.
S    */
S
Sextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
S   /*
S    * transforms the string pointed to by s2 and places the resulting string
S    * into the array pointed to by s1. The transformation function is such that
S    * if the strcmp function is applied to two transformed strings, it returns
S    * a value greater than, equal to or less than zero, corresponding to the
S    * result of the strcoll function applied to the same two original strings.
S    * No more than n characters are placed into the resulting array pointed to
S    * by s1, including the terminating null character. If n is zero, s1 is
S    * permitted to be a null pointer. If copying takes place between objects
S    * that overlap, the behaviour is undefined.
S    * Returns: The length of the transformed string is returned (not including
S    *          the terminating null character). If the value returned is n or
S    *          more, the contents of the array pointed to by s1 are
S    *          indeterminate.
S    */
S
S
S#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
S#else
Sextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
S#endif
S   /*
S    * locates the first occurence of c (converted to an unsigned char) in the
S    * initial n characters (each interpreted as unsigned char) of the object
S    * pointed to by s.
S    * Returns: a pointer to the located character, or a null pointer if the
S    *          character does not occur in the object.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
S#else
Sextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
S#endif
S   /*
S    * locates the first occurence of c (converted to an char) in the string
S    * pointed to by s (including the terminating null character).
S    * Returns: a pointer to the located character, or a null pointer if the
S    *          character does not occur in the string.
S    */
S
Sextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * computes the length of the initial segment of the string pointed to by s1
S    * which consists entirely of characters not from the string pointed to by
S    * s2. The terminating null character is not considered part of s2.
S    * Returns: the length of the segment.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
S#else
Sextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S#endif
S   /*
S    * locates the first occurence in the string pointed to by s1 of any
S    * character from the string pointed to by s2.
S    * Returns: returns a pointer to the character, or a null pointer if no
S    *          character form s2 occurs in s1.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
S#else
Sextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
S#endif
S   /*
S    * locates the last occurence of c (converted to a char) in the string
S    * pointed to by s. The terminating null character is considered part of
S    * the string.
S    * Returns: returns a pointer to the character, or a null pointer if c does
S    *          not occur in the string.
S    */
S
Sextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * computes the length of the initial segment of the string pointed to by s1
S    * which consists entirely of characters from the string pointed to by S2
S    * Returns: the length of the segment.
S    */
S
S#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
S#else
Sextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
S#endif
S   /*
S    * locates the first occurence in the string pointed to by s1 of the
S    * sequence of characters (excluding the terminating null character) in the
S    * string pointed to by s2.
S    * Returns: a pointer to the located string, or a null pointer if the string
S    *          is not found.
S    */
S
Sextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Sextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
S#ifndef __STRICT_ANSI__
Sextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
S#endif
S   /*
S    * A sequence of calls to the strtok function breaks the string pointed to
S    * by s1 into a sequence of tokens, each of which is delimited by a
S    * character from the string pointed to by s2. The first call in the
S    * sequence has s1 as its first argument, and is followed by calls with a
S    * null pointer as their first argument. The separator string pointed to by
S    * s2 may be different from call to call.
S    * The first call in the sequence searches for the first character that is
S    * not contained in the current separator string s2. If no such character
S    * is found, then there are no tokens in s1 and the strtok function returns
S    * a null pointer. If such a character is found, it is the start of the
S    * first token.
S    * The strtok function then searches from there for a character that is
S    * contained in the current separator string. If no such character is found,
S    * the current token extends to the end of the string pointed to by s1, and
S    * subsequent searches for a token will fail. If such a character is found,
S    * it is overwritten by a null character, which terminates the current
S    * token. The strtok function saves a pointer to the following character,
S    * from which the next search for a token will start.
S    * Each subsequent call, with a null pointer as the value for the first
S    * argument, starts searching from the saved pointer and behaves as
S    * described above.
S    * Returns: pointer to the first character of a token, or a null pointer if
S    *          there is no token.
S    *
S    * strtok_r() is a common extension which works exactly like
S    * strtok(), but instead of storing its state in a hidden
S    * library variable, requires the user to pass in a pointer to a
S    * char * variable which will be used instead. Any sequence of
S    * calls to strtok_r() passing the same char ** pointer should
S    * behave exactly like the corresponding sequence of calls to
S    * strtok(). This means that strtok_r() can safely be used in
S    * multi-threaded programs, and also that you can tokenise two
S    * strings in parallel.
S    */
S
Sextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
S   /*
S    * copies the value of c (converted to an unsigned char) into each of the
S    * first n charactes of the object pointed to by s.
S    * Returns: the value of s.
S    */
Sextern _ARMABI char *strerror(int /*errnum*/);
S   /*
S    * maps the error number in errnum to an error message string.
S    * Returns: a pointer to the string, the contents of which are
S    *          implementation-defined. The array pointed to shall not be
S    *          modified by the program, but may be overwritten by a
S    *          subsequent call to the strerror function.
S    */
Sextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
S   /*
S    * computes the length of the string pointed to by s.
S    * Returns: the number of characters that precede the terminating null
S    *          character.
S    */
S
Sextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * copies the string src into the string dst, using no more than
S    * len bytes of dst. Always null-terminates dst _within the
S    * length len (i.e. will copy at most len-1 bytes of string plus
S    * a NUL), unless len is actually zero.
S    * 
S    * Return value is the length of the string that _would_ have
S    * been written, i.e. the length of src. Thus, the operation
S    * succeeded without truncation if and only if ret < len;
S    * otherwise, the value in ret tells you how big to make dst if
S    * you decide to reallocate it. (That value does _not_ include
S    * the NUL.)
S    * 
S    * This is a BSD-derived library extension, which we are
S    * permitted to declare in a standard header because ISO defines
S    * function names beginning with 'str' as reserved for future
S    * expansion of <string.h>.
S    */
S
Sextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
S   /*
S    * concatenates the string src to the string dst, using no more
S    * than len bytes of dst. Always null-terminates dst _within the
S    * length len (i.e. will copy at most len-1 bytes of string plus
S    * a NUL), unless len is actually zero.
S    * 
S    * Return value is the length of the string that _would_ have
S    * been written, i.e. the length of src plus the original length
S    * of dst. Thus, the operation succeeded without truncation if
S    * and only if ret < len; otherwise, the value in ret tells you
S    * how big to make dst if you decide to reallocate it. (That
S    * value does _not_ include the NUL.)
S    * 
S    * If no NUL is encountered within the first len bytes of dst,
S    * then the length of dst is considered to have been equal to
S    * len for the purposes of the return value (as if there were a
S    * NUL at dst[len]). Thus, the return value in this case is len
S    * + strlen(src).
S    * 
S    * This is a BSD-derived library extension, which we are
S    * permitted to declare in a standard header because ISO defines
S    * function names beginning with 'str' as reserved for future
S    * expansion of <string.h>.
S    */
S
Sextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Sextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
S    /*
S     * Copies or moves a piece of memory from one place to another,
S     * with one-bit granularity. So you can start or finish a copy
S     * part way through a byte, and you can copy between regions
S     * with different alignment within a byte.
S     * 
S     * All these functions have the same prototype: two void *
S     * pointers for destination and source, then two integers
S     * giving the bit offset from those pointers, and finally the
S     * number of bits to copy.
S     * 
S     * Just like memcpy and memmove, the "cpy" functions copy as
S     * fast as they can in the assumption that the memory regions
S     * do not overlap, while the "move" functions cope correctly
S     * with overlap.
S     *
S     * Treating memory as a stream of individual bits requires
S     * defining a convention about what order those bits are
S     * considered to be arranged in. The above functions support
S     * multiple conventions:
S     * 
S     *  - the "bl" functions consider the unit of memory to be the
S     *    byte, and consider the bits within each byte to be
S     *    arranged in little-endian fashion, so that the LSB comes
S     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
S     *    the MSB of the byte at b to the LSB of the byte at a.)
S     * 
S     *  - the "bb" functions consider the unit of memory to be the
S     *    byte, and consider the bits within each byte to be
S     *    arranged in big-endian fashion, so that the MSB comes
S     *    first.
S     * 
S     *  - the "hl" functions consider the unit of memory to be the
S     *    16-bit halfword, and consider the bits within each word
S     *    to be arranged in little-endian fashion.
S     * 
S     *  - the "hb" functions consider the unit of memory to be the
S     *    16-bit halfword, and consider the bits within each word
S     *    to be arranged in big-endian fashion.
S     * 
S     *  - the "wl" functions consider the unit of memory to be the
S     *    32-bit word, and consider the bits within each word to be
S     *    arranged in little-endian fashion.
S     * 
S     *  - the "wb" functions consider the unit of memory to be the
S     *    32-bit word, and consider the bits within each word to be
S     *    arranged in big-endian fashion.
S     */
S
S    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
S    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STRING_NO_EXPORTS
N      using ::std::size_t;
N      using ::std::memcpy;
N      using ::std::memmove;
N      using ::std::strcpy;
N      using ::std::strncpy;
N      using ::std::strcat;
N      using ::std::strncat;
N      using ::std::memcmp;
N      using ::std::strcmp;
N      using ::std::strncmp;
N      using ::std::strcasecmp;
N      using ::std::strncasecmp;
N      using ::std::strcoll;
N      using ::std::strxfrm;
N      using ::std::memchr;
N      using ::std::strchr;
N      using ::std::strcspn;
N      using ::std::strpbrk;
N      using ::std::strrchr;
N      using ::std::strspn;
N      using ::std::strstr;
N      using ::std::strtok;
N#ifndef __STRICT_ANSI__
N      using ::std::strtok_r;
N#endif
N      using ::std::_strtok_r;
N      using ::std::memset;
N      using ::std::strerror;
N      using ::std::strlen;
N      using ::std::strlcpy;
N      using ::std::strlcat;
N      using ::std::_membitcpybl;
N      using ::std::_membitcpybb;
N      using ::std::_membitcpyhl;
N      using ::std::_membitcpyhb;
N      using ::std::_membitcpywl;
N      using ::std::_membitcpywb;
N      using ::std::_membitmovebl;
N      using ::std::_membitmovebb;
N      using ::std::_membitmovehl;
N      using ::std::_membitmovehb;
N      using ::std::_membitmovewl;
N      using ::std::_membitmovewb;
N    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 20 "mbed/platform/Callback.h" 2
N#include <stdint.h>
N#include <new>
N#include "platform/mbed_assert.h"
N#include "platform/mbed_toolchain.h"
N
Nnamespace mbed {
N/** \addtogroup platform */
N/** @{*/
N
N
N/** Callback class based on template specialization
N *
N * @Note Synchronization level: Not protected
N */
Ntemplate <typename F>
Nclass Callback;
N
N// Internal sfinae declarations
N//
N// These are used to eliminate overloads based on type attributes
N// 1. Does a function object have a call operator
N// 2. Does a function object fit in the available storage
N//
N// These eliminations are handled cleanly by the compiler and avoid
N// massive and misleading error messages when confronted with an
N// invalid type (or worse, runtime failures)
Nnamespace detail {
N    struct nil {};
N
N    template <bool B, typename R = nil>
N    struct enable_if { typedef R type; };
N
N    template <typename R>
N    struct enable_if<false, R> {};
N
N    template <typename M, M>
N    struct is_type {
N        static const bool value = true;
N    };
N}
N
N/** Callback class based on template specialization
N *
N * @Note Synchronization level: Not protected
N */
Ntemplate <typename R>
Nclass Callback<R()> {
Npublic:
N    /** Create a Callback with a static function
N     *  @param func     Static function to attach
N     */
N    Callback(R (*func)() = 0) {
N        if (!func) {
N            _ops = 0;
N        } else {
N            generate(func);
N        }
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     */
N    Callback(const Callback<R()> &func) {
N        if (func._ops) {
N            func._ops->move(this, &func);
N        }
N        _ops = func._ops;
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(U *obj, R (T::*method)()) {
N        generate(method_context<T, R (T::*)()>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const U *obj, R (T::*method)() const) {
N        generate(method_context<const T, R (T::*)() const>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(volatile U *obj, R (T::*method)() volatile) {
N        generate(method_context<volatile T, R (T::*)() volatile>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const volatile U *obj, R (T::*method)() const volatile) {
N        generate(method_context<const volatile T, R (T::*)() const volatile>(obj, method));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(T*), U *arg) {
N        generate(function_context<R (*)(T*), T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const T*), const U *arg) {
N        generate(function_context<R (*)(const T*), const T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(volatile T*), volatile U *arg) {
N        generate(function_context<R (*)(volatile T*), volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const volatile T*), const volatile U *arg) {
N        generate(function_context<R (*)(const volatile T*), const volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)() const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)() volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)() const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(U *obj, R (*func)(T*)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const U *obj, R (*func)(const T*)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(volatile U *obj, R (*func)(volatile T*)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const volatile U *obj, R (*func)(const volatile T*)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Destroy a callback
N     */
N    ~Callback() {
N        if (_ops) {
N            _ops->dtor(this);
N        }
N    }
N
N    /** Attach a static function
N     *  @param func     Static function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)()) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const Callback<R()> &func) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(U *obj, R (T::*method)()) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (T::*method)() const) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (T::*method)() volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (T::*method)() const volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(T*), U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const T*), const U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(volatile T*), volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const volatile T*), const volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)() const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)() volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)() const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(U *obj, R (*func)(T*)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (*func)(const T*)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (*func)(volatile T*)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (*func)(const volatile T*)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Assign a callback
N     */
N    Callback &operator=(const Callback &that) {
N        if (this != &that) {
N            this->~Callback();
N            new (this) Callback(that);
N        }
N
N        return *this;
N    }
N
N    /** Call the attached function
N     */
N    R call() const {
N        MBED_ASSERT(_ops);
X        do { if (!(_ops)) { mbed_assert_internal("_ops", "mbed/platform/Callback.h", 543); } } while (0);
N        return _ops->call(this);
N    }
N
N    /** Call the attached function
N     */
N    R operator()() const {
N        return call();
N    }
N
N    /** Test if function has been attached
N     */
N    operator bool() const {
N        return _ops;
N    }
N
N    /** Test for equality
N     */
N    friend bool operator==(const Callback &l, const Callback &r) {
N        return memcmp(&l, &r, sizeof(Callback)) == 0;
N    }
N
N    /** Test for inequality
N     */
N    friend bool operator!=(const Callback &l, const Callback &r) {
N        return !(l == r);
N    }
N
N    /** Static thunk for passing as C-style function
N     *  @param func Callback to call passed as void pointer
N     */
N    static R thunk(void *func) {
N        return static_cast<Callback*>(func)->call();
N    }
N
Nprivate:
N    // Stored as pointer to function and pointer to optional object
N    // Function pointer is stored as union of possible function types
N    // to garuntee proper size and alignment
N    struct _class;
N    union {
N        void (*_staticfunc)();
N        void (*_boundfunc)(_class*);
N        void (_class::*_methodfunc)();
N    } _func;
N    void *_obj;
N
N    // Dynamically dispatched operations
N    const struct ops {
N        R (*call)(const void*);
N        void (*move)(void*, const void*);
N        void (*dtor)(void*);
N    } *_ops;
N
N    // Generate operations for function object
N    template <typename F>
N    void generate(const F &f) {
N        static const ops ops = {
N            &Callback::function_call<F>,
N            &Callback::function_move<F>,
N            &Callback::function_dtor<F>,
N        };
N
N        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),
N                "Type F must not exceed the size of the Callback class");
X        enum {MBED_ASSERTION_AT_606 = sizeof(char[(sizeof(Callback) - sizeof(_ops) >= sizeof(F)) ? 1 : -1])};
N        new (this) F(f);
N        _ops = &ops;
N    }
N
N    // Function attributes
N    template <typename F>
N    static R function_call(const void *p) {
N        return (*(F*)p)();
N    }
N
N    template <typename F>
N    static void function_move(void *d, const void *p) {
N        new (d) F(*(F*)p);
N    }
N
N    template <typename F>
N    static void function_dtor(void *p) {
N        ((F*)p)->~F();
N    }
N
N    // Wrappers for functions with context
N    template <typename O, typename M>
N    struct method_context {
N        M method;
N        O *obj;
N
N        method_context(O *obj, M method)
N            : method(method), obj(obj) {}
N
N        R operator()() const {
N            return (obj->*method)();
N        }
N    };
N
N    template <typename F, typename A>
N    struct function_context {
N        F func;
N        A *arg;
N
N        function_context(F func, A *arg)
N            : func(func), arg(arg) {}
N
N        R operator()() const {
N            return func(arg);
N        }
N    };
N};
N
N/** Callback class based on template specialization
N *
N * @Note Synchronization level: Not protected
N */
Ntemplate <typename R, typename A0>
Nclass Callback<R(A0)> {
Npublic:
N    /** Create a Callback with a static function
N     *  @param func     Static function to attach
N     */
N    Callback(R (*func)(A0) = 0) {
N        if (!func) {
N            _ops = 0;
N        } else {
N            generate(func);
N        }
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     */
N    Callback(const Callback<R(A0)> &func) {
N        if (func._ops) {
N            func._ops->move(this, &func);
N        }
N        _ops = func._ops;
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(U *obj, R (T::*method)(A0)) {
N        generate(method_context<T, R (T::*)(A0)>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const U *obj, R (T::*method)(A0) const) {
N        generate(method_context<const T, R (T::*)(A0) const>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(volatile U *obj, R (T::*method)(A0) volatile) {
N        generate(method_context<volatile T, R (T::*)(A0) volatile>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const volatile U *obj, R (T::*method)(A0) const volatile) {
N        generate(method_context<const volatile T, R (T::*)(A0) const volatile>(obj, method));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(T*, A0), U *arg) {
N        generate(function_context<R (*)(T*, A0), T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const T*, A0), const U *arg) {
N        generate(function_context<R (*)(const T*, A0), const T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(volatile T*, A0), volatile U *arg) {
N        generate(function_context<R (*)(volatile T*, A0), volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const volatile T*, A0), const volatile U *arg) {
N        generate(function_context<R (*)(const volatile T*, A0), const volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(U *obj, R (*func)(T*, A0)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const U *obj, R (*func)(const T*, A0)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(volatile U *obj, R (*func)(volatile T*, A0)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Destroy a callback
N     */
N    ~Callback() {
N        if (_ops) {
N            _ops->dtor(this);
N        }
N    }
N
N    /** Attach a static function
N     *  @param func     Static function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(A0)) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const Callback<R(A0)> &func) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(U *obj, R (T::*method)(A0)) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (T::*method)(A0) const) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (T::*method)(A0) volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (T::*method)(A0) const volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(T*, A0), U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const T*, A0), const U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(volatile T*, A0), volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const volatile T*, A0), const volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(U *obj, R (*func)(T*, A0)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (*func)(const T*, A0)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (*func)(volatile T*, A0)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (*func)(const volatile T*, A0)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Assign a callback
N     */
N    Callback &operator=(const Callback &that) {
N        if (this != &that) {
N            this->~Callback();
N            new (this) Callback(that);
N        }
N
N        return *this;
N    }
N
N    /** Call the attached function
N     */
N    R call(A0 a0) const {
N        MBED_ASSERT(_ops);
X        do { if (!(_ops)) { mbed_assert_internal("_ops", "mbed/platform/Callback.h", 1138); } } while (0);
N        return _ops->call(this, a0);
N    }
N
N    /** Call the attached function
N     */
N    R operator()(A0 a0) const {
N        return call(a0);
N    }
N
N    /** Test if function has been attached
N     */
N    operator bool() const {
N        return _ops;
N    }
N
N    /** Test for equality
N     */
N    friend bool operator==(const Callback &l, const Callback &r) {
N        return memcmp(&l, &r, sizeof(Callback)) == 0;
N    }
N
N    /** Test for inequality
N     */
N    friend bool operator!=(const Callback &l, const Callback &r) {
N        return !(l == r);
N    }
N
N    /** Static thunk for passing as C-style function
N     *  @param func Callback to call passed as void pointer
N     */
N    static R thunk(void *func, A0 a0) {
N        return static_cast<Callback*>(func)->call(a0);
N    }
N
Nprivate:
N    // Stored as pointer to function and pointer to optional object
N    // Function pointer is stored as union of possible function types
N    // to garuntee proper size and alignment
N    struct _class;
N    union {
N        void (*_staticfunc)(A0);
N        void (*_boundfunc)(_class*, A0);
N        void (_class::*_methodfunc)(A0);
N    } _func;
N    void *_obj;
N
N    // Dynamically dispatched operations
N    const struct ops {
N        R (*call)(const void*, A0);
N        void (*move)(void*, const void*);
N        void (*dtor)(void*);
N    } *_ops;
N
N    // Generate operations for function object
N    template <typename F>
N    void generate(const F &f) {
N        static const ops ops = {
N            &Callback::function_call<F>,
N            &Callback::function_move<F>,
N            &Callback::function_dtor<F>,
N        };
N
N        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),
N                "Type F must not exceed the size of the Callback class");
X        enum {MBED_ASSERTION_AT_1201 = sizeof(char[(sizeof(Callback) - sizeof(_ops) >= sizeof(F)) ? 1 : -1])};
N        new (this) F(f);
N        _ops = &ops;
N    }
N
N    // Function attributes
N    template <typename F>
N    static R function_call(const void *p, A0 a0) {
N        return (*(F*)p)(a0);
N    }
N
N    template <typename F>
N    static void function_move(void *d, const void *p) {
N        new (d) F(*(F*)p);
N    }
N
N    template <typename F>
N    static void function_dtor(void *p) {
N        ((F*)p)->~F();
N    }
N
N    // Wrappers for functions with context
N    template <typename O, typename M>
N    struct method_context {
N        M method;
N        O *obj;
N
N        method_context(O *obj, M method)
N            : method(method), obj(obj) {}
N
N        R operator()(A0 a0) const {
N            return (obj->*method)(a0);
N        }
N    };
N
N    template <typename F, typename A>
N    struct function_context {
N        F func;
N        A *arg;
N
N        function_context(F func, A *arg)
N            : func(func), arg(arg) {}
N
N        R operator()(A0 a0) const {
N            return func(arg, a0);
N        }
N    };
N};
N
N/** Callback class based on template specialization
N *
N * @Note Synchronization level: Not protected
N */
Ntemplate <typename R, typename A0, typename A1>
Nclass Callback<R(A0, A1)> {
Npublic:
N    /** Create a Callback with a static function
N     *  @param func     Static function to attach
N     */
N    Callback(R (*func)(A0, A1) = 0) {
N        if (!func) {
N            _ops = 0;
N        } else {
N            generate(func);
N        }
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     */
N    Callback(const Callback<R(A0, A1)> &func) {
N        if (func._ops) {
N            func._ops->move(this, &func);
N        }
N        _ops = func._ops;
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(U *obj, R (T::*method)(A0, A1)) {
N        generate(method_context<T, R (T::*)(A0, A1)>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const U *obj, R (T::*method)(A0, A1) const) {
N        generate(method_context<const T, R (T::*)(A0, A1) const>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {
N        generate(method_context<volatile T, R (T::*)(A0, A1) volatile>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {
N        generate(method_context<const volatile T, R (T::*)(A0, A1) const volatile>(obj, method));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(T*, A0, A1), U *arg) {
N        generate(function_context<R (*)(T*, A0, A1), T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const T*, A0, A1), const U *arg) {
N        generate(function_context<R (*)(const T*, A0, A1), const T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {
N        generate(function_context<R (*)(volatile T*, A0, A1), volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {
N        generate(function_context<R (*)(const volatile T*, A0, A1), const volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(U *obj, R (*func)(T*, A0, A1)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const U *obj, R (*func)(const T*, A0, A1)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Destroy a callback
N     */
N    ~Callback() {
N        if (_ops) {
N            _ops->dtor(this);
N        }
N    }
N
N    /** Attach a static function
N     *  @param func     Static function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(A0, A1)) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const Callback<R(A0, A1)> &func) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(U *obj, R (T::*method)(A0, A1)) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (T::*method)(A0, A1) const) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (T::*method)(A0, A1) volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(T*, A0, A1), U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const T*, A0, A1), const U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(volatile T*, A0, A1), volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(U *obj, R (*func)(T*, A0, A1)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (*func)(const T*, A0, A1)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Assign a callback
N     */
N    Callback &operator=(const Callback &that) {
N        if (this != &that) {
N            this->~Callback();
N            new (this) Callback(that);
N        }
N
N        return *this;
N    }
N
N    /** Call the attached function
N     */
N    R call(A0 a0, A1 a1) const {
N        MBED_ASSERT(_ops);
X        do { if (!(_ops)) { mbed_assert_internal("_ops", "mbed/platform/Callback.h", 1733); } } while (0);
N        return _ops->call(this, a0, a1);
N    }
N
N    /** Call the attached function
N     */
N    R operator()(A0 a0, A1 a1) const {
N        return call(a0, a1);
N    }
N
N    /** Test if function has been attached
N     */
N    operator bool() const {
N        return _ops;
N    }
N
N    /** Test for equality
N     */
N    friend bool operator==(const Callback &l, const Callback &r) {
N        return memcmp(&l, &r, sizeof(Callback)) == 0;
N    }
N
N    /** Test for inequality
N     */
N    friend bool operator!=(const Callback &l, const Callback &r) {
N        return !(l == r);
N    }
N
N    /** Static thunk for passing as C-style function
N     *  @param func Callback to call passed as void pointer
N     */
N    static R thunk(void *func, A0 a0, A1 a1) {
N        return static_cast<Callback*>(func)->call(a0, a1);
N    }
N
Nprivate:
N    // Stored as pointer to function and pointer to optional object
N    // Function pointer is stored as union of possible function types
N    // to garuntee proper size and alignment
N    struct _class;
N    union {
N        void (*_staticfunc)(A0, A1);
N        void (*_boundfunc)(_class*, A0, A1);
N        void (_class::*_methodfunc)(A0, A1);
N    } _func;
N    void *_obj;
N
N    // Dynamically dispatched operations
N    const struct ops {
N        R (*call)(const void*, A0, A1);
N        void (*move)(void*, const void*);
N        void (*dtor)(void*);
N    } *_ops;
N
N    // Generate operations for function object
N    template <typename F>
N    void generate(const F &f) {
N        static const ops ops = {
N            &Callback::function_call<F>,
N            &Callback::function_move<F>,
N            &Callback::function_dtor<F>,
N        };
N
N        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),
N                "Type F must not exceed the size of the Callback class");
X        enum {MBED_ASSERTION_AT_1796 = sizeof(char[(sizeof(Callback) - sizeof(_ops) >= sizeof(F)) ? 1 : -1])};
N        new (this) F(f);
N        _ops = &ops;
N    }
N
N    // Function attributes
N    template <typename F>
N    static R function_call(const void *p, A0 a0, A1 a1) {
N        return (*(F*)p)(a0, a1);
N    }
N
N    template <typename F>
N    static void function_move(void *d, const void *p) {
N        new (d) F(*(F*)p);
N    }
N
N    template <typename F>
N    static void function_dtor(void *p) {
N        ((F*)p)->~F();
N    }
N
N    // Wrappers for functions with context
N    template <typename O, typename M>
N    struct method_context {
N        M method;
N        O *obj;
N
N        method_context(O *obj, M method)
N            : method(method), obj(obj) {}
N
N        R operator()(A0 a0, A1 a1) const {
N            return (obj->*method)(a0, a1);
N        }
N    };
N
N    template <typename F, typename A>
N    struct function_context {
N        F func;
N        A *arg;
N
N        function_context(F func, A *arg)
N            : func(func), arg(arg) {}
N
N        R operator()(A0 a0, A1 a1) const {
N            return func(arg, a0, a1);
N        }
N    };
N};
N
N/** Callback class based on template specialization
N *
N * @Note Synchronization level: Not protected
N */
Ntemplate <typename R, typename A0, typename A1, typename A2>
Nclass Callback<R(A0, A1, A2)> {
Npublic:
N    /** Create a Callback with a static function
N     *  @param func     Static function to attach
N     */
N    Callback(R (*func)(A0, A1, A2) = 0) {
N        if (!func) {
N            _ops = 0;
N        } else {
N            generate(func);
N        }
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     */
N    Callback(const Callback<R(A0, A1, A2)> &func) {
N        if (func._ops) {
N            func._ops->move(this, &func);
N        }
N        _ops = func._ops;
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(U *obj, R (T::*method)(A0, A1, A2)) {
N        generate(method_context<T, R (T::*)(A0, A1, A2)>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const U *obj, R (T::*method)(A0, A1, A2) const) {
N        generate(method_context<const T, R (T::*)(A0, A1, A2) const>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {
N        generate(method_context<volatile T, R (T::*)(A0, A1, A2) volatile>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {
N        generate(method_context<const volatile T, R (T::*)(A0, A1, A2) const volatile>(obj, method));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(T*, A0, A1, A2), U *arg) {
N        generate(function_context<R (*)(T*, A0, A1, A2), T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const T*, A0, A1, A2), const U *arg) {
N        generate(function_context<R (*)(const T*, A0, A1, A2), const T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {
N        generate(function_context<R (*)(volatile T*, A0, A1, A2), volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {
N        generate(function_context<R (*)(const volatile T*, A0, A1, A2), const volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(U *obj, R (*func)(T*, A0, A1, A2)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Destroy a callback
N     */
N    ~Callback() {
N        if (_ops) {
N            _ops->dtor(this);
N        }
N    }
N
N    /** Attach a static function
N     *  @param func     Static function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(A0, A1, A2)) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const Callback<R(A0, A1, A2)> &func) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(U *obj, R (T::*method)(A0, A1, A2)) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (T::*method)(A0, A1, A2) const) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(T*, A0, A1, A2), U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const T*, A0, A1, A2), const U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(U *obj, R (*func)(T*, A0, A1, A2)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (*func)(const T*, A0, A1, A2)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Assign a callback
N     */
N    Callback &operator=(const Callback &that) {
N        if (this != &that) {
N            this->~Callback();
N            new (this) Callback(that);
N        }
N
N        return *this;
N    }
N
N    /** Call the attached function
N     */
N    R call(A0 a0, A1 a1, A2 a2) const {
N        MBED_ASSERT(_ops);
X        do { if (!(_ops)) { mbed_assert_internal("_ops", "mbed/platform/Callback.h", 2328); } } while (0);
N        return _ops->call(this, a0, a1, a2);
N    }
N
N    /** Call the attached function
N     */
N    R operator()(A0 a0, A1 a1, A2 a2) const {
N        return call(a0, a1, a2);
N    }
N
N    /** Test if function has been attached
N     */
N    operator bool() const {
N        return _ops;
N    }
N
N    /** Test for equality
N     */
N    friend bool operator==(const Callback &l, const Callback &r) {
N        return memcmp(&l, &r, sizeof(Callback)) == 0;
N    }
N
N    /** Test for inequality
N     */
N    friend bool operator!=(const Callback &l, const Callback &r) {
N        return !(l == r);
N    }
N
N    /** Static thunk for passing as C-style function
N     *  @param func Callback to call passed as void pointer
N     */
N    static R thunk(void *func, A0 a0, A1 a1, A2 a2) {
N        return static_cast<Callback*>(func)->call(a0, a1, a2);
N    }
N
Nprivate:
N    // Stored as pointer to function and pointer to optional object
N    // Function pointer is stored as union of possible function types
N    // to garuntee proper size and alignment
N    struct _class;
N    union {
N        void (*_staticfunc)(A0, A1, A2);
N        void (*_boundfunc)(_class*, A0, A1, A2);
N        void (_class::*_methodfunc)(A0, A1, A2);
N    } _func;
N    void *_obj;
N
N    // Dynamically dispatched operations
N    const struct ops {
N        R (*call)(const void*, A0, A1, A2);
N        void (*move)(void*, const void*);
N        void (*dtor)(void*);
N    } *_ops;
N
N    // Generate operations for function object
N    template <typename F>
N    void generate(const F &f) {
N        static const ops ops = {
N            &Callback::function_call<F>,
N            &Callback::function_move<F>,
N            &Callback::function_dtor<F>,
N        };
N
N        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),
N                "Type F must not exceed the size of the Callback class");
X        enum {MBED_ASSERTION_AT_2391 = sizeof(char[(sizeof(Callback) - sizeof(_ops) >= sizeof(F)) ? 1 : -1])};
N        new (this) F(f);
N        _ops = &ops;
N    }
N
N    // Function attributes
N    template <typename F>
N    static R function_call(const void *p, A0 a0, A1 a1, A2 a2) {
N        return (*(F*)p)(a0, a1, a2);
N    }
N
N    template <typename F>
N    static void function_move(void *d, const void *p) {
N        new (d) F(*(F*)p);
N    }
N
N    template <typename F>
N    static void function_dtor(void *p) {
N        ((F*)p)->~F();
N    }
N
N    // Wrappers for functions with context
N    template <typename O, typename M>
N    struct method_context {
N        M method;
N        O *obj;
N
N        method_context(O *obj, M method)
N            : method(method), obj(obj) {}
N
N        R operator()(A0 a0, A1 a1, A2 a2) const {
N            return (obj->*method)(a0, a1, a2);
N        }
N    };
N
N    template <typename F, typename A>
N    struct function_context {
N        F func;
N        A *arg;
N
N        function_context(F func, A *arg)
N            : func(func), arg(arg) {}
N
N        R operator()(A0 a0, A1 a1, A2 a2) const {
N            return func(arg, a0, a1, a2);
N        }
N    };
N};
N
N/** Callback class based on template specialization
N *
N * @Note Synchronization level: Not protected
N */
Ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>
Nclass Callback<R(A0, A1, A2, A3)> {
Npublic:
N    /** Create a Callback with a static function
N     *  @param func     Static function to attach
N     */
N    Callback(R (*func)(A0, A1, A2, A3) = 0) {
N        if (!func) {
N            _ops = 0;
N        } else {
N            generate(func);
N        }
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     */
N    Callback(const Callback<R(A0, A1, A2, A3)> &func) {
N        if (func._ops) {
N            func._ops->move(this, &func);
N        }
N        _ops = func._ops;
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {
N        generate(method_context<T, R (T::*)(A0, A1, A2, A3)>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {
N        generate(method_context<const T, R (T::*)(A0, A1, A2, A3) const>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {
N        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3) volatile>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {
N        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3) const volatile>(obj, method));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {
N        generate(function_context<R (*)(T*, A0, A1, A2, A3), T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {
N        generate(function_context<R (*)(const T*, A0, A1, A2, A3), const T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {
N        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3), volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {
N        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3), const volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Destroy a callback
N     */
N    ~Callback() {
N        if (_ops) {
N            _ops->dtor(this);
N        }
N    }
N
N    /** Attach a static function
N     *  @param func     Static function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(A0, A1, A2, A3)) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const Callback<R(A0, A1, A2, A3)> &func) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(U *obj, R (T::*method)(A0, A1, A2, A3)) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(T*, A0, A1, A2, A3), U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Assign a callback
N     */
N    Callback &operator=(const Callback &that) {
N        if (this != &that) {
N            this->~Callback();
N            new (this) Callback(that);
N        }
N
N        return *this;
N    }
N
N    /** Call the attached function
N     */
N    R call(A0 a0, A1 a1, A2 a2, A3 a3) const {
N        MBED_ASSERT(_ops);
X        do { if (!(_ops)) { mbed_assert_internal("_ops", "mbed/platform/Callback.h", 2923); } } while (0);
N        return _ops->call(this, a0, a1, a2, a3);
N    }
N
N    /** Call the attached function
N     */
N    R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {
N        return call(a0, a1, a2, a3);
N    }
N
N    /** Test if function has been attached
N     */
N    operator bool() const {
N        return _ops;
N    }
N
N    /** Test for equality
N     */
N    friend bool operator==(const Callback &l, const Callback &r) {
N        return memcmp(&l, &r, sizeof(Callback)) == 0;
N    }
N
N    /** Test for inequality
N     */
N    friend bool operator!=(const Callback &l, const Callback &r) {
N        return !(l == r);
N    }
N
N    /** Static thunk for passing as C-style function
N     *  @param func Callback to call passed as void pointer
N     */
N    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3) {
N        return static_cast<Callback*>(func)->call(a0, a1, a2, a3);
N    }
N
Nprivate:
N    // Stored as pointer to function and pointer to optional object
N    // Function pointer is stored as union of possible function types
N    // to garuntee proper size and alignment
N    struct _class;
N    union {
N        void (*_staticfunc)(A0, A1, A2, A3);
N        void (*_boundfunc)(_class*, A0, A1, A2, A3);
N        void (_class::*_methodfunc)(A0, A1, A2, A3);
N    } _func;
N    void *_obj;
N
N    // Dynamically dispatched operations
N    const struct ops {
N        R (*call)(const void*, A0, A1, A2, A3);
N        void (*move)(void*, const void*);
N        void (*dtor)(void*);
N    } *_ops;
N
N    // Generate operations for function object
N    template <typename F>
N    void generate(const F &f) {
N        static const ops ops = {
N            &Callback::function_call<F>,
N            &Callback::function_move<F>,
N            &Callback::function_dtor<F>,
N        };
N
N        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),
N                "Type F must not exceed the size of the Callback class");
X        enum {MBED_ASSERTION_AT_2986 = sizeof(char[(sizeof(Callback) - sizeof(_ops) >= sizeof(F)) ? 1 : -1])};
N        new (this) F(f);
N        _ops = &ops;
N    }
N
N    // Function attributes
N    template <typename F>
N    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3) {
N        return (*(F*)p)(a0, a1, a2, a3);
N    }
N
N    template <typename F>
N    static void function_move(void *d, const void *p) {
N        new (d) F(*(F*)p);
N    }
N
N    template <typename F>
N    static void function_dtor(void *p) {
N        ((F*)p)->~F();
N    }
N
N    // Wrappers for functions with context
N    template <typename O, typename M>
N    struct method_context {
N        M method;
N        O *obj;
N
N        method_context(O *obj, M method)
N            : method(method), obj(obj) {}
N
N        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {
N            return (obj->*method)(a0, a1, a2, a3);
N        }
N    };
N
N    template <typename F, typename A>
N    struct function_context {
N        F func;
N        A *arg;
N
N        function_context(F func, A *arg)
N            : func(func), arg(arg) {}
N
N        R operator()(A0 a0, A1 a1, A2 a2, A3 a3) const {
N            return func(arg, a0, a1, a2, a3);
N        }
N    };
N};
N
N/** Callback class based on template specialization
N *
N * @Note Synchronization level: Not protected
N */
Ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
Nclass Callback<R(A0, A1, A2, A3, A4)> {
Npublic:
N    /** Create a Callback with a static function
N     *  @param func     Static function to attach
N     */
N    Callback(R (*func)(A0, A1, A2, A3, A4) = 0) {
N        if (!func) {
N            _ops = 0;
N        } else {
N            generate(func);
N        }
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     */
N    Callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {
N        if (func._ops) {
N            func._ops->move(this, &func);
N        }
N        _ops = func._ops;
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {
N        generate(method_context<T, R (T::*)(A0, A1, A2, A3, A4)>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {
N        generate(method_context<const T, R (T::*)(A0, A1, A2, A3, A4) const>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {
N        generate(method_context<volatile T, R (T::*)(A0, A1, A2, A3, A4) volatile>(obj, method));
N    }
N
N    /** Create a Callback with a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     */
N    template<typename T, typename U>
N    Callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {
N        generate(method_context<const volatile T, R (T::*)(A0, A1, A2, A3, A4) const volatile>(obj, method));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {
N        generate(function_context<R (*)(T*, A0, A1, A2, A3, A4), T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {
N        generate(function_context<R (*)(const T*, A0, A1, A2, A3, A4), const T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {
N        generate(function_context<R (*)(volatile T*, A0, A1, A2, A3, A4), volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function 
N     */
N    template<typename T, typename U>
N    Callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {
N        generate(function_context<R (*)(const volatile T*, A0, A1, A2, A3, A4), const volatile T>(func, arg));
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     */
N    template <typename F>
N    Callback(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        generate(f);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Create a Callback with a static function and bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to Callback(func, arg)
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to Callback(func, arg)")
X    __attribute__((deprecated))
N    Callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {
N        new (this) Callback(func, obj);
N    }
N
N    /** Destroy a callback
N     */
N    ~Callback() {
N        if (_ops) {
N            _ops->dtor(this);
N        }
N    }
N
N    /** Attach a static function
N     *  @param func     Static function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(A0, A1, A2, A3, A4)) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a Callback
N     *  @param func     The Callback to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const Callback<R(A0, A1, A2, A3, A4)> &func) {
N        this->~Callback();
N        new (this) Callback(func);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a member function
N     *  @param obj      Pointer to object to invoke member function on
N     *  @param method   Member function to attach
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template<typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {
N        this->~Callback();
N        new (this) Callback(obj, method);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param func     Static function to attach
N     *  @param arg      Pointer argument to function
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {
N        this->~Callback();
N        new (this) Callback(func, arg);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4), &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4) const, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4) volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a function object
N     *  @param func     Function object to attach
N     *  @note The function object is limited to a single word of storage
N     *  @deprecated
N     *      Replaced by simple assignment 'Callback cb = func'
N     */
N    template <typename F>
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "Replaced by simple assignment 'Callback cb = func")
X    __attribute__((deprecated))
N    void attach(const volatile F f, typename detail::enable_if<
N                detail::is_type<R (F::*)(A0, A1, A2, A3, A4) const volatile, &F::operator()>::value &&
N                sizeof(F) <= sizeof(uintptr_t)
N            >::type = detail::nil()) {
N        this->~Callback();
N        new (this) Callback(f);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Attach a static function with a bound pointer
N     *  @param obj  Pointer to object to bind to function
N     *  @param func Static function to attach
N     *  @deprecated
N     *      Arguments to callback have been reordered to attach(func, arg)
N     */
N    template <typename T, typename U>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "Arguments to callback have been reordered to attach(func, arg)")
X    __attribute__((deprecated))
N    void attach(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {
N        this->~Callback();
N        new (this) Callback(func, obj);
N    }
N
N    /** Assign a callback
N     */
N    Callback &operator=(const Callback &that) {
N        if (this != &that) {
N            this->~Callback();
N            new (this) Callback(that);
N        }
N
N        return *this;
N    }
N
N    /** Call the attached function
N     */
N    R call(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {
N        MBED_ASSERT(_ops);
X        do { if (!(_ops)) { mbed_assert_internal("_ops", "mbed/platform/Callback.h", 3518); } } while (0);
N        return _ops->call(this, a0, a1, a2, a3, a4);
N    }
N
N    /** Call the attached function
N     */
N    R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {
N        return call(a0, a1, a2, a3, a4);
N    }
N
N    /** Test if function has been attached
N     */
N    operator bool() const {
N        return _ops;
N    }
N
N    /** Test for equality
N     */
N    friend bool operator==(const Callback &l, const Callback &r) {
N        return memcmp(&l, &r, sizeof(Callback)) == 0;
N    }
N
N    /** Test for inequality
N     */
N    friend bool operator!=(const Callback &l, const Callback &r) {
N        return !(l == r);
N    }
N
N    /** Static thunk for passing as C-style function
N     *  @param func Callback to call passed as void pointer
N     */
N    static R thunk(void *func, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {
N        return static_cast<Callback*>(func)->call(a0, a1, a2, a3, a4);
N    }
N
Nprivate:
N    // Stored as pointer to function and pointer to optional object
N    // Function pointer is stored as union of possible function types
N    // to garuntee proper size and alignment
N    struct _class;
N    union {
N        void (*_staticfunc)(A0, A1, A2, A3, A4);
N        void (*_boundfunc)(_class*, A0, A1, A2, A3, A4);
N        void (_class::*_methodfunc)(A0, A1, A2, A3, A4);
N    } _func;
N    void *_obj;
N
N    // Dynamically dispatched operations
N    const struct ops {
N        R (*call)(const void*, A0, A1, A2, A3, A4);
N        void (*move)(void*, const void*);
N        void (*dtor)(void*);
N    } *_ops;
N
N    // Generate operations for function object
N    template <typename F>
N    void generate(const F &f) {
N        static const ops ops = {
N            &Callback::function_call<F>,
N            &Callback::function_move<F>,
N            &Callback::function_dtor<F>,
N        };
N
N        MBED_STATIC_ASSERT(sizeof(Callback) - sizeof(_ops) >= sizeof(F),
N                "Type F must not exceed the size of the Callback class");
X        enum {MBED_ASSERTION_AT_3581 = sizeof(char[(sizeof(Callback) - sizeof(_ops) >= sizeof(F)) ? 1 : -1])};
N        new (this) F(f);
N        _ops = &ops;
N    }
N
N    // Function attributes
N    template <typename F>
N    static R function_call(const void *p, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) {
N        return (*(F*)p)(a0, a1, a2, a3, a4);
N    }
N
N    template <typename F>
N    static void function_move(void *d, const void *p) {
N        new (d) F(*(F*)p);
N    }
N
N    template <typename F>
N    static void function_dtor(void *p) {
N        ((F*)p)->~F();
N    }
N
N    // Wrappers for functions with context
N    template <typename O, typename M>
N    struct method_context {
N        M method;
N        O *obj;
N
N        method_context(O *obj, M method)
N            : method(method), obj(obj) {}
N
N        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {
N            return (obj->*method)(a0, a1, a2, a3, a4);
N        }
N    };
N
N    template <typename F, typename A>
N    struct function_context {
N        F func;
N        A *arg;
N
N        function_context(F func, A *arg)
N            : func(func), arg(arg) {}
N
N        R operator()(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const {
N            return func(arg, a0, a1, a2, a3, a4);
N        }
N    };
N};
N
N// Internally used event type
Ntypedef Callback<void(int)> event_callback_t;
N
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R>
NCallback<R()> callback(R (*func)() = 0) {
N    return Callback<R()>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R>
NCallback<R()> callback(const Callback<R()> &func) {
N    return Callback<R()>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R>
NCallback<R()> callback(U *obj, R (T::*method)()) {
N    return Callback<R()>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R>
NCallback<R()> callback(const U *obj, R (T::*method)() const) {
N    return Callback<R()>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R>
NCallback<R()> callback(volatile U *obj, R (T::*method)() volatile) {
N    return Callback<R()>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R>
NCallback<R()> callback(const volatile U *obj, R (T::*method)() const volatile) {
N    return Callback<R()>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R>
NCallback<R()> callback(R (*func)(T*), U *arg) {
N    return Callback<R()>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R>
NCallback<R()> callback(R (*func)(const T*), const U *arg) {
N    return Callback<R()>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R>
NCallback<R()> callback(R (*func)(volatile T*), volatile U *arg) {
N    return Callback<R()>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R>
NCallback<R()> callback(R (*func)(const volatile T*), const volatile U *arg) {
N    return Callback<R()>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R()> callback(U *obj, R (*func)(T*)) {
N    return Callback<R()>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R()> callback(const U *obj, R (*func)(const T*)) {
N    return Callback<R()>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R()> callback(volatile U *obj, R (*func)(volatile T*)) {
N    return Callback<R()>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R()> callback(const volatile U *obj, R (*func)(const volatile T*)) {
N    return Callback<R()>(func, obj);
N}
N
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0>
NCallback<R(A0)> callback(R (*func)(A0) = 0) {
N    return Callback<R(A0)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0>
NCallback<R(A0)> callback(const Callback<R(A0)> &func) {
N    return Callback<R(A0)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(U *obj, R (T::*method)(A0)) {
N    return Callback<R(A0)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(const U *obj, R (T::*method)(A0) const) {
N    return Callback<R(A0)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(volatile U *obj, R (T::*method)(A0) volatile) {
N    return Callback<R(A0)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(const volatile U *obj, R (T::*method)(A0) const volatile) {
N    return Callback<R(A0)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(R (*func)(T*, A0), U *arg) {
N    return Callback<R(A0)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(R (*func)(const T*, A0), const U *arg) {
N    return Callback<R(A0)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(R (*func)(volatile T*, A0), volatile U *arg) {
N    return Callback<R(A0)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NCallback<R(A0)> callback(R (*func)(const volatile T*, A0), const volatile U *arg) {
N    return Callback<R(A0)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0)> callback(U *obj, R (*func)(T*, A0)) {
N    return Callback<R(A0)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0)> callback(const U *obj, R (*func)(const T*, A0)) {
N    return Callback<R(A0)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0)> callback(volatile U *obj, R (*func)(volatile T*, A0)) {
N    return Callback<R(A0)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0)> callback(const volatile U *obj, R (*func)(const volatile T*, A0)) {
N    return Callback<R(A0)>(func, obj);
N}
N
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(R (*func)(A0, A1) = 0) {
N    return Callback<R(A0, A1)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(const Callback<R(A0, A1)> &func) {
N    return Callback<R(A0, A1)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(U *obj, R (T::*method)(A0, A1)) {
N    return Callback<R(A0, A1)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(const U *obj, R (T::*method)(A0, A1) const) {
N    return Callback<R(A0, A1)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(volatile U *obj, R (T::*method)(A0, A1) volatile) {
N    return Callback<R(A0, A1)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(const volatile U *obj, R (T::*method)(A0, A1) const volatile) {
N    return Callback<R(A0, A1)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(R (*func)(T*, A0, A1), U *arg) {
N    return Callback<R(A0, A1)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(R (*func)(const T*, A0, A1), const U *arg) {
N    return Callback<R(A0, A1)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(R (*func)(volatile T*, A0, A1), volatile U *arg) {
N    return Callback<R(A0, A1)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NCallback<R(A0, A1)> callback(R (*func)(const volatile T*, A0, A1), const volatile U *arg) {
N    return Callback<R(A0, A1)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1)> callback(U *obj, R (*func)(T*, A0, A1)) {
N    return Callback<R(A0, A1)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1)> callback(const U *obj, R (*func)(const T*, A0, A1)) {
N    return Callback<R(A0, A1)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1)) {
N    return Callback<R(A0, A1)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1)) {
N    return Callback<R(A0, A1)>(func, obj);
N}
N
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(R (*func)(A0, A1, A2) = 0) {
N    return Callback<R(A0, A1, A2)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(const Callback<R(A0, A1, A2)> &func) {
N    return Callback<R(A0, A1, A2)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(U *obj, R (T::*method)(A0, A1, A2)) {
N    return Callback<R(A0, A1, A2)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(const U *obj, R (T::*method)(A0, A1, A2) const) {
N    return Callback<R(A0, A1, A2)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(volatile U *obj, R (T::*method)(A0, A1, A2) volatile) {
N    return Callback<R(A0, A1, A2)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2) const volatile) {
N    return Callback<R(A0, A1, A2)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(R (*func)(T*, A0, A1, A2), U *arg) {
N    return Callback<R(A0, A1, A2)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(R (*func)(const T*, A0, A1, A2), const U *arg) {
N    return Callback<R(A0, A1, A2)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(R (*func)(volatile T*, A0, A1, A2), volatile U *arg) {
N    return Callback<R(A0, A1, A2)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NCallback<R(A0, A1, A2)> callback(R (*func)(const volatile T*, A0, A1, A2), const volatile U *arg) {
N    return Callback<R(A0, A1, A2)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2)> callback(U *obj, R (*func)(T*, A0, A1, A2)) {
N    return Callback<R(A0, A1, A2)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2)> callback(const U *obj, R (*func)(const T*, A0, A1, A2)) {
N    return Callback<R(A0, A1, A2)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2)) {
N    return Callback<R(A0, A1, A2)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2)) {
N    return Callback<R(A0, A1, A2)>(func, obj);
N}
N
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(R (*func)(A0, A1, A2, A3) = 0) {
N    return Callback<R(A0, A1, A2, A3)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(const Callback<R(A0, A1, A2, A3)> &func) {
N    return Callback<R(A0, A1, A2, A3)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(U *obj, R (T::*method)(A0, A1, A2, A3)) {
N    return Callback<R(A0, A1, A2, A3)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3) const) {
N    return Callback<R(A0, A1, A2, A3)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3) volatile) {
N    return Callback<R(A0, A1, A2, A3)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3) const volatile) {
N    return Callback<R(A0, A1, A2, A3)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(R (*func)(T*, A0, A1, A2, A3), U *arg) {
N    return Callback<R(A0, A1, A2, A3)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(R (*func)(const T*, A0, A1, A2, A3), const U *arg) {
N    return Callback<R(A0, A1, A2, A3)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(R (*func)(volatile T*, A0, A1, A2, A3), volatile U *arg) {
N    return Callback<R(A0, A1, A2, A3)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NCallback<R(A0, A1, A2, A3)> callback(R (*func)(const volatile T*, A0, A1, A2, A3), const volatile U *arg) {
N    return Callback<R(A0, A1, A2, A3)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3)) {
N    return Callback<R(A0, A1, A2, A3)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3)) {
N    return Callback<R(A0, A1, A2, A3)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3)) {
N    return Callback<R(A0, A1, A2, A3)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3)) {
N    return Callback<R(A0, A1, A2, A3)>(func, obj);
N}
N
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(A0, A1, A2, A3, A4) = 0) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @return         Callback with infered type
N */
Ntemplate <typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(const Callback<R(A0, A1, A2, A3, A4)> &func) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (T::*method)(A0, A1, A2, A3, A4)) {
N    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (T::*method)(A0, A1, A2, A3, A4) const) {
N    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) volatile) {
N    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj      Optional pointer to object to bind to function
N *  @param method   Member function to attach
N *  @return         Callback with infered type
N */
Ntemplate<typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (T::*method)(A0, A1, A2, A3, A4) const volatile) {
N    return Callback<R(A0, A1, A2, A3, A4)>(obj, method);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(T*, A0, A1, A2, A3, A4), U *arg) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const T*, A0, A1, A2, A3, A4), const U *arg) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(volatile T*, A0, A1, A2, A3, A4), volatile U *arg) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param func     Static function to attach
N *  @param arg      Pointer argument to function
N *  @return         Callback with infered type
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NCallback<R(A0, A1, A2, A3, A4)> callback(R (*func)(const volatile T*, A0, A1, A2, A3, A4), const volatile U *arg) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, arg);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3, A4)> callback(U *obj, R (*func)(T*, A0, A1, A2, A3, A4)) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3, A4)> callback(const U *obj, R (*func)(const T*, A0, A1, A2, A3, A4)) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3, A4)> callback(volatile U *obj, R (*func)(volatile T*, A0, A1, A2, A3, A4)) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);
N}
N
N/** Create a callback class with type infered from the arguments
N *
N *  @param obj  Optional pointer to object to bind to function
N *  @param func Static function to attach
N *  @return     Callback with infered type
N *  @deprecated
N *      Arguments to callback have been reordered to callback(func, arg)
N */
Ntemplate <typename T, typename U, typename R, typename A0, typename A1, typename A2, typename A3, typename A4>
NMBED_DEPRECATED_SINCE("mbed-os-5.1",
N    "Arguments to callback have been reordered to callback(func, arg)")
X__attribute__((deprecated))
NCallback<R(A0, A1, A2, A3, A4)> callback(const volatile U *obj, R (*func)(const volatile T*, A0, A1, A2, A3, A4)) {
N    return Callback<R(A0, A1, A2, A3, A4)>(func, obj);
N}
N
N
N} // namespace mbed
N
N#endif
N
N
N/** @}*/
L 25 "mbed/./drivers/SerialBase.h" 2
N#include "serial_api.h"
L 1 "mbed/hal/serial_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SERIAL_API_H
N#define MBED_SERIAL_API_H
N
N#include "device.h"
N#include "hal/buffer.h"
L 1 "mbed/./hal/buffer.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2014-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_BUFFER_H
N#define MBED_BUFFER_H
N
N#include <stddef.h>
N
N/** Generic buffer structure
N */
Ntypedef struct buffer_s {
N    void    *buffer; /**< the pointer to a buffer */
N    size_t   length; /**< the buffer length */
N    size_t   pos;    /**< actual buffer position */
N    uint8_t  width;  /**< The buffer unit width (8, 16, 32, 64), used for proper *buffer casting */
N} buffer_t;
N
N#endif
N
N/** @}*/
L 24 "mbed/hal/serial_api.h" 2
N#include "hal/dma_api.h"
L 1 "mbed/./hal/dma_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2014-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_DMA_API_H
N#define MBED_DMA_API_H
N
N#include <stdint.h>
N
N#define DMA_ERROR_OUT_OF_CHANNELS (-1)
N
Ntypedef enum {
N    DMA_USAGE_NEVER,
N    DMA_USAGE_OPPORTUNISTIC,
N    DMA_USAGE_ALWAYS,
N    DMA_USAGE_TEMPORARY_ALLOCATED,
N    DMA_USAGE_ALLOCATED
N} DMAUsage;
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Nvoid dma_init(void);
N
Nint dma_channel_allocate(uint32_t capabilities);
N
Nint dma_channel_free(int channelid);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 25 "mbed/hal/serial_api.h" 2
N
N#if DEVICE_SERIAL
X#if 1
N
N#define SERIAL_EVENT_TX_SHIFT (2)
N#define SERIAL_EVENT_RX_SHIFT (8)
N
N#define SERIAL_EVENT_TX_MASK (0x00FC)
N#define SERIAL_EVENT_RX_MASK (0x3F00)
N
N#define SERIAL_EVENT_ERROR (1 << 1)
N
N/**
N * @defgroup SerialTXEvents Serial TX Events Macros
N *
N * @{
N */
N#define SERIAL_EVENT_TX_COMPLETE (1 << (SERIAL_EVENT_TX_SHIFT + 0))
N#define SERIAL_EVENT_TX_ALL      (SERIAL_EVENT_TX_COMPLETE)
N/**@}*/
N
N/**
N * @defgroup SerialRXEvents Serial RX Events Macros
N *
N * @{
N */
N#define SERIAL_EVENT_RX_COMPLETE        (1 << (SERIAL_EVENT_RX_SHIFT + 0))
N#define SERIAL_EVENT_RX_OVERRUN_ERROR   (1 << (SERIAL_EVENT_RX_SHIFT + 1))
N#define SERIAL_EVENT_RX_FRAMING_ERROR   (1 << (SERIAL_EVENT_RX_SHIFT + 2))
N#define SERIAL_EVENT_RX_PARITY_ERROR    (1 << (SERIAL_EVENT_RX_SHIFT + 3))
N#define SERIAL_EVENT_RX_OVERFLOW        (1 << (SERIAL_EVENT_RX_SHIFT + 4))
N#define SERIAL_EVENT_RX_CHARACTER_MATCH (1 << (SERIAL_EVENT_RX_SHIFT + 5))
N#define SERIAL_EVENT_RX_ALL             (SERIAL_EVENT_RX_OVERFLOW | SERIAL_EVENT_RX_PARITY_ERROR | \
N                                         SERIAL_EVENT_RX_FRAMING_ERROR | SERIAL_EVENT_RX_OVERRUN_ERROR | \
N                                         SERIAL_EVENT_RX_COMPLETE | SERIAL_EVENT_RX_CHARACTER_MATCH)
X#define SERIAL_EVENT_RX_ALL             (SERIAL_EVENT_RX_OVERFLOW | SERIAL_EVENT_RX_PARITY_ERROR |                                          SERIAL_EVENT_RX_FRAMING_ERROR | SERIAL_EVENT_RX_OVERRUN_ERROR |                                          SERIAL_EVENT_RX_COMPLETE | SERIAL_EVENT_RX_CHARACTER_MATCH)
N/**@}*/
N
N#define SERIAL_RESERVED_CHAR_MATCH (255)
N
Ntypedef enum {
N    ParityNone = 0,
N    ParityOdd = 1,
N    ParityEven = 2,
N    ParityForced1 = 3,
N    ParityForced0 = 4
N} SerialParity;
N
Ntypedef enum {
N    RxIrq,
N    TxIrq
N} SerialIrq;
N
Ntypedef enum {
N    FlowControlNone,
N    FlowControlRTS,
N    FlowControlCTS,
N    FlowControlRTSCTS
N} FlowControl;
N
Ntypedef void (*uart_irq_handler)(uint32_t id, SerialIrq event);
N
N#if DEVICE_SERIAL_ASYNCH
S/** Asynch serial HAL structure
S */
Stypedef struct {
S    struct serial_s serial;  /**< Target specific serial structure */
S    struct buffer_s tx_buff; /**< TX buffer */
S    struct buffer_s rx_buff; /**< RX buffer */
S    uint8_t char_match;      /**< Character to be matched */
S    uint8_t char_found;      /**< State of the matched character */
S} serial_t;
S
N#else
N/** Non-asynch serial HAL structure
N */
Ntypedef struct serial_s serial_t;
N
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/**
N * \defgroup hal_GeneralSerial Serial Configuration Functions
N * @{
N */
N
N/** Initialize the serial peripheral. It sets the default parameters for serial
N *  peripheral, and configures its specifieds pins.
N *
N * @param obj The serial object
N * @param tx  The TX pin name
N * @param rx  The RX pin name
N */
Nvoid serial_init(serial_t *obj, PinName tx, PinName rx);
N
N/** Release the serial peripheral, not currently invoked. It requires further
N *  resource management.
N *
N * @param obj The serial object
N */
Nvoid serial_free(serial_t *obj);
N
N/** Configure the baud rate
N *
N * @param obj      The serial object
N * @param baudrate The baud rate to be configured
N */
Nvoid serial_baud(serial_t *obj, int baudrate);
N
N/** Configure the format. Set the number of bits, parity and the number of stop bits
N *
N * @param obj       The serial object
N * @param data_bits The number of data bits
N * @param parity    The parity
N * @param stop_bits The number of stop bits
N */
Nvoid serial_format(serial_t *obj, int data_bits, SerialParity parity, int stop_bits);
N
N/** The serial interrupt handler registration
N *
N * @param obj     The serial object
N * @param handler The interrupt handler which will be invoked when the interrupt fires
N * @param id      The SerialBase object
N */
Nvoid serial_irq_handler(serial_t *obj, uart_irq_handler handler, uint32_t id);
N
N/** Configure serial interrupt. This function is used for word-approach
N *
N * @param obj    The serial object
N * @param irq    The serial IRQ type (RX or TX)
N * @param enable Set to non-zero to enable events, or zero to disable them
N */
Nvoid serial_irq_set(serial_t *obj, SerialIrq irq, uint32_t enable);
N
N/** Get character. This is a blocking call, waiting for a character
N *
N * @param obj The serial object
N */
Nint  serial_getc(serial_t *obj);
N
N/** Send a character. This is a blocking call, waiting for a peripheral to be available
N *  for writing
N *
N * @param obj The serial object
N * @param c   The character to be sent
N */
Nvoid serial_putc(serial_t *obj, int c);
N
N/** Check if the serial peripheral is readable
N *
N * @param obj The serial object
N * @return Non-zero value if a character can be read, 0 if nothing to read
N */
Nint  serial_readable(serial_t *obj);
N
N/** Check if the serial peripheral is writable
N *
N * @param obj The serial object
N * @return Non-zero value if a character can be written, 0 otherwise.
N */
Nint  serial_writable(serial_t *obj);
N
N/** Clear the serial peripheral
N *
N * @param obj The serial object
N */
Nvoid serial_clear(serial_t *obj);
N
N/** Set the break
N *
N * @param obj The serial object
N */
Nvoid serial_break_set(serial_t *obj);
N
N/** Clear the break
N *
N * @param obj The serial object
N */
Nvoid serial_break_clear(serial_t *obj);
N
N/** Configure the TX pin for UART function.
N *
N * @param tx The pin name used for TX
N */
Nvoid serial_pinout_tx(PinName tx);
N
N/** Configure the serial for the flow control. It sets flow control in the hardware
N *  if a serial peripheral supports it, otherwise software emulation is used.
N *
N * @param obj    The serial object
N * @param type   The type of the flow control. Look at the available FlowControl types.
N * @param rxflow The TX pin name
N * @param txflow The RX pin name
N */
Nvoid serial_set_flow_control(serial_t *obj, FlowControl type, PinName rxflow, PinName txflow);
N
N#if DEVICE_SERIAL_ASYNCH
S
S/**@}*/
S
S/**
S * \defgroup hal_AsynchSerial Asynchronous Serial Hardware Abstraction Layer
S * @{
S */
S
S/** Begin asynchronous TX transfer. The used buffer is specified in the serial object,
S *  tx_buff
S *
S * @param obj       The serial object
S * @param tx        The transmit buffer
S * @param tx_length The number of bytes to transmit
S * @param tx_width  Deprecated argument
S * @param handler   The serial handler
S * @param event     The logical OR of events to be registered
S * @param hint      A suggestion for how to use DMA with this transfer
S * @return Returns number of data transfered, otherwise returns 0
S */
Sint serial_tx_asynch(serial_t *obj, const void *tx, size_t tx_length, uint8_t tx_width, uint32_t handler, uint32_t event, DMAUsage hint);
S
S/** Begin asynchronous RX transfer (enable interrupt for data collecting)
S *  The used buffer is specified in the serial object - rx_buff
S *
S * @param obj        The serial object
S * @param rx         The receive buffer
S * @param rx_length  The number of bytes to receive
S * @param rx_width   Deprecated argument
S * @param handler    The serial handler
S * @param event      The logical OR of events to be registered
S * @param handler    The serial handler
S * @param char_match A character in range 0-254 to be matched
S * @param hint       A suggestion for how to use DMA with this transfer
S */
Svoid serial_rx_asynch(serial_t *obj, void *rx, size_t rx_length, uint8_t rx_width, uint32_t handler, uint32_t event, uint8_t char_match, DMAUsage hint);
S
S/** Attempts to determine if the serial peripheral is already in use for TX
S *
S * @param obj The serial object
S * @return Non-zero if the RX transaction is ongoing, 0 otherwise
S */
Suint8_t serial_tx_active(serial_t *obj);
S
S/** Attempts to determine if the serial peripheral is already in use for RX
S *
S * @param obj The serial object
S * @return Non-zero if the RX transaction is ongoing, 0 otherwise
S */
Suint8_t serial_rx_active(serial_t *obj);
S
S/** The asynchronous TX and RX handler.
S *
S * @param obj The serial object
S * @return Returns event flags if an RX transfer termination condition was met; otherwise returns 0
S */
Sint serial_irq_handler_asynch(serial_t *obj);
S
S/** Abort the ongoing TX transaction. It disables the enabled interupt for TX and
S *  flushes the TX hardware buffer if TX FIFO is used
S *
S * @param obj The serial object
S */
Svoid serial_tx_abort_asynch(serial_t *obj);
S
S/** Abort the ongoing RX transaction. It disables the enabled interrupt for RX and
S *  flushes the RX hardware buffer if RX FIFO is used
S *
S * @param obj The serial object
S */
Svoid serial_rx_abort_asynch(serial_t *obj);
S
S/**@}*/
S
N#endif
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N#endif
N
N/** @}*/
L 26 "mbed/./drivers/SerialBase.h" 2
N#include "mbed_toolchain.h"
N
N#if DEVICE_SERIAL_ASYNCH
S#include "CThunk.h"
S#include "dma_api.h"
N#endif
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A base class for serial port implementations
N * Can't be instantiated directly (use Serial or RawSerial)
N *
N * @Note Synchronization level: Set by subclass
N */
Nclass SerialBase {
N
Npublic:
N    /** Set the baud rate of the serial port
N     *
N     *  @param baudrate The baudrate of the serial port (default = 9600).
N     */
N    void baud(int baudrate);
N
N    enum Parity {
N        None = 0,
N        Odd,
N        Even,
N        Forced1,
N        Forced0
N    };
N
N    enum IrqType {
N        RxIrq = 0,
N        TxIrq,
N
N        IrqCnt
N    };
N
N    enum Flow {
N        Disabled = 0,
N        RTS,
N        CTS,
N        RTSCTS
N    };
N
N    /** Set the transmission format used by the serial port
N     *
N     *  @param bits The number of bits in a word (5-8; default = 8)
N     *  @param parity The parity used (SerialBase::None, SerialBase::Odd, SerialBase::Even, SerialBase::Forced1, SerialBase::Forced0; default = SerialBase::None)
N     *  @param stop The number of stop bits (1 or 2; default = 1)
N     */
N    void format(int bits=8, Parity parity=SerialBase::None, int stop_bits=1);
N
N    /** Determine if there is a character available to read
N     *
N     *  @returns
N     *    1 if there is a character available to read,
N     *    0 otherwise
N     */
N    int readable();
N
N    /** Determine if there is space available to write a character
N     *
N     *  @returns
N     *    1 if there is space to write a character,
N     *    0 otherwise
N     */
N    int writeable();
N
N    /** Attach a function to call whenever a serial interrupt is generated
N     *
N     *  @param func A pointer to a void function, or 0 to set as none
N     *  @param type Which serial interrupt to attach the member function to (Seriall::RxIrq for receive, TxIrq for transmit buffer empty)
N     */
N    void attach(Callback<void()> func, IrqType type=RxIrq);
N
N    /** Attach a member function to call whenever a serial interrupt is generated
N     *
N     *  @param obj pointer to the object to call the member function on
N     *  @param method pointer to the member function to be called
N     *  @param type Which serial interrupt to attach the member function to (Seriall::RxIrq for receive, TxIrq for transmit buffer empty)
N     *  @deprecated
N     *      The attach function does not support cv-qualifiers. Replaced by
N     *      attach(callback(obj, method), type).
N     */
N    template<typename T>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "The attach function does not support cv-qualifiers. Replaced by "
N        "attach(callback(obj, method), type).")
X    __attribute__((deprecated))
N    void attach(T *obj, void (T::*method)(), IrqType type=RxIrq) {
N        attach(callback(obj, method), type);
N    }
N
N    /** Attach a member function to call whenever a serial interrupt is generated
N     *
N     *  @param obj pointer to the object to call the member function on
N     *  @param method pointer to the member function to be called
N     *  @param type Which serial interrupt to attach the member function to (Seriall::RxIrq for receive, TxIrq for transmit buffer empty)
N     *  @deprecated
N     *      The attach function does not support cv-qualifiers. Replaced by
N     *      attach(callback(obj, method), type).
N     */
N    template<typename T>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "The attach function does not support cv-qualifiers. Replaced by "
N        "attach(callback(obj, method), type).")
X    __attribute__((deprecated))
N    void attach(T *obj, void (*method)(T*), IrqType type=RxIrq) {
N        attach(callback(obj, method), type);
N    }
N
N    /** Generate a break condition on the serial line
N     */
N    void send_break();
N
Nprotected:
N
N    /** Acquire exclusive access to this serial port
N     */
N    virtual void lock(void);
N
N    /** Release exclusive access to this serial port
N     */
N    virtual void unlock(void);
N
Npublic:
N
N#if DEVICE_SERIAL_FC
X#if 1
N    /** Set the flow control type on the serial port
N     *
N     *  @param type the flow control type (Disabled, RTS, CTS, RTSCTS)
N     *  @param flow1 the first flow control pin (RTS for RTS or RTSCTS, CTS for CTS)
N     *  @param flow2 the second flow control pin (CTS for RTSCTS)
N     */
N    void set_flow_control(Flow type, PinName flow1=NC, PinName flow2=NC);
N#endif
N
N    static void _irq_handler(uint32_t id, SerialIrq irq_type);
N
N#if DEVICE_SERIAL_ASYNCH
S
S    /** Begin asynchronous write using 8bit buffer. The completition invokes registered TX event callback
S     *
S     *  @param buffer   The buffer where received data will be stored
S     *  @param length   The buffer length in bytes
S     *  @param callback The event callback function
S     *  @param event    The logical OR of TX events
S     */
S    int write(const uint8_t *buffer, int length, const event_callback_t& callback, int event = SERIAL_EVENT_TX_COMPLETE);
S
S    /** Begin asynchronous write using 16bit buffer. The completition invokes registered TX event callback
S     *
S     *  @param buffer   The buffer where received data will be stored
S     *  @param length   The buffer length in bytes
S     *  @param callback The event callback function
S     *  @param event    The logical OR of TX events
S     */
S    int write(const uint16_t *buffer, int length, const event_callback_t& callback, int event = SERIAL_EVENT_TX_COMPLETE);
S
S    /** Abort the on-going write transfer
S     */
S    void abort_write();
S
S    /** Begin asynchronous reading using 8bit buffer. The completition invokes registred RX event callback.
S     *
S     *  @param buffer     The buffer where received data will be stored
S     *  @param length     The buffer length in bytes
S     *  @param callback   The event callback function
S     *  @param event      The logical OR of RX events
S     *  @param char_match The matching character
S     */
S    int read(uint8_t *buffer, int length, const event_callback_t& callback, int event = SERIAL_EVENT_RX_COMPLETE, unsigned char char_match = SERIAL_RESERVED_CHAR_MATCH);
S
S    /** Begin asynchronous reading using 16bit buffer. The completition invokes registred RX event callback.
S     *
S     *  @param buffer     The buffer where received data will be stored
S     *  @param length     The buffer length in bytes
S     *  @param callback   The event callback function
S     *  @param event      The logical OR of RX events
S     *  @param char_match The matching character
S     */
S    int read(uint16_t *buffer, int length, const event_callback_t& callback, int event = SERIAL_EVENT_RX_COMPLETE, unsigned char char_match = SERIAL_RESERVED_CHAR_MATCH);
S
S    /** Abort the on-going read transfer
S     */
S    void abort_read();
S
S    /** Configure DMA usage suggestion for non-blocking TX transfers
S     *
S     *  @param usage The usage DMA hint for peripheral
S     *  @return Zero if the usage was set, -1 if a transaction is on-going
S     */
S    int set_dma_usage_tx(DMAUsage usage);
S
S    /** Configure DMA usage suggestion for non-blocking RX transfers
S     *
S     *  @param usage The usage DMA hint for peripheral
S     *  @return Zero if the usage was set, -1 if a transaction is on-going
S     */
S    int set_dma_usage_rx(DMAUsage usage);
S
Sprotected:
S    void start_read(void *buffer, int buffer_size, char buffer_width, const event_callback_t& callback, int event, unsigned char char_match);
S    void start_write(const void *buffer, int buffer_size, char buffer_width, const event_callback_t& callback, int event);
S    void interrupt_handler_asynch(void);
N#endif
N
Nprotected:
N    SerialBase(PinName tx, PinName rx, int baud);
N    virtual ~SerialBase() {
N    }
N
N    int _base_getc();
N    int _base_putc(int c);
N
N#if DEVICE_SERIAL_ASYNCH
S    CThunk<SerialBase> _thunk_irq;
S    event_callback_t _tx_callback;
S    event_callback_t _rx_callback;
S    DMAUsage _tx_usage;
S    DMAUsage _rx_usage;
N#endif
N
N    serial_t         _serial;
N    Callback<void()> _irq[IrqCnt];
N    int              _baud;
N
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 25 "mbed/./drivers/Serial.h" 2
N#include "PlatformMutex.h"
N#include "serial_api.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A serial port (UART) for communication with other serial devices
N *
N * Can be used for Full Duplex communication, or Simplex by specifying
N * one pin as NC (Not Connected)
N *
N * @Note Synchronization level: Thread safe
N *
N * Example:
N * @code
N * // Print "Hello World" to the PC
N *
N * #include "mbed.h"
N *
N * Serial pc(USBTX, USBRX);
N *
N * int main() {
N *     pc.printf("Hello World\n");
N * }
N * @endcode
N */
Nclass Serial : public SerialBase, public Stream {
N
Npublic:
N#if DEVICE_SERIAL_ASYNCH
S    using SerialBase::read;
S    using SerialBase::write;
N#endif
N
N    /** Create a Serial port, connected to the specified transmit and receive pins
N     *
N     *  @param tx Transmit pin
N     *  @param rx Receive pin
N     *  @param name The name of the stream associated with this serial port (optional)
N     *  @param baud The baud rate of the serial port (optional, defaults to MBED_CONF_PLATFORM_DEFAULT_SERIAL_BAUD_RATE)
N     *
N     *  @note
N     *    Either tx or rx may be specified as NC if unused
N     */
N    Serial(PinName tx, PinName rx, const char *name=NULL, int baud = MBED_CONF_PLATFORM_DEFAULT_SERIAL_BAUD_RATE);
X    Serial(PinName tx, PinName rx, const char *name=0, int baud = 9600);
N
N
N    /** Create a Serial port, connected to the specified transmit and receive pins, with the specified baud
N     *
N     *  @param tx Transmit pin
N     *  @param rx Receive pin
N     *  @param baud The baud rate of the serial port
N     *
N     *  @note
N     *    Either tx or rx may be specified as NC if unused
N     */
N    Serial(PinName tx, PinName rx, int baud);
N
Nprotected:
N    virtual int _getc();
N    virtual int _putc(int c);
N    virtual void lock();
N    virtual void unlock();
N
N    PlatformMutex _mutex;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 81 "mbed/./mbed.h" 2
N#include "drivers/SPI.h"
L 1 "mbed/./drivers/SPI.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SPI_H
N#define MBED_SPI_H
N
N#include "platform/platform.h"
N
N#if DEVICE_SPI
X#if 1
N
N#include "platform/PlatformMutex.h"
N#include "hal/spi_api.h"
L 1 "mbed/./hal/spi_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SPI_API_H
N#define MBED_SPI_API_H
N
N#include "device.h"
N#include "hal/dma_api.h"
N#include "hal/buffer.h"
N
N#if DEVICE_SPI
X#if 1
N
N#define SPI_EVENT_ERROR       (1 << 1)
N#define SPI_EVENT_COMPLETE    (1 << 2)
N#define SPI_EVENT_RX_OVERFLOW (1 << 3)
N#define SPI_EVENT_ALL         (SPI_EVENT_ERROR | SPI_EVENT_COMPLETE | SPI_EVENT_RX_OVERFLOW)
N
N#define SPI_EVENT_INTERNAL_TRANSFER_COMPLETE (1 << 30) // Internal flag to report that an event occurred
N
N#define SPI_FILL_WORD         (0xFFFF)
N
N#if DEVICE_SPI_ASYNCH
S/** Asynch SPI HAL structure
S */
Stypedef struct {
S    struct spi_s spi;        /**< Target specific SPI structure */
S    struct buffer_s tx_buff; /**< Tx buffer */
S    struct buffer_s rx_buff; /**< Rx buffer */
S} spi_t;
S
N#else
N/** Non-asynch SPI HAL structure
N */
Ntypedef struct spi_s spi_t;
N
N#endif
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/**
N * \defgroup hal_GeneralSPI SPI Configuration Functions
N * @{
N */
N
N/** Initialize the SPI peripheral
N *
N * Configures the pins used by SPI, sets a default format and frequency, and enables the peripheral
N * @param[out] obj  The SPI object to initialize
N * @param[in]  mosi The pin to use for MOSI
N * @param[in]  miso The pin to use for MISO
N * @param[in]  sclk The pin to use for SCLK
N * @param[in]  ssel The pin to use for SSEL
N */
Nvoid spi_init(spi_t *obj, PinName mosi, PinName miso, PinName sclk, PinName ssel);
N
N/** Release a SPI object
N *
N * TODO: spi_free is currently unimplemented
N * This will require reference counting at the C++ level to be safe
N *
N * Return the pins owned by the SPI object to their reset state
N * Disable the SPI peripheral
N * Disable the SPI clock
N * @param[in] obj The SPI object to deinitialize
N */
Nvoid spi_free(spi_t *obj);
N
N/** Configure the SPI format
N *
N * Set the number of bits per frame, configure clock polarity and phase, shift order and master/slave mode.
N * The default bit order is MSB.
N * @param[in,out] obj   The SPI object to configure
N * @param[in]     bits  The number of bits per frame
N * @param[in]     mode  The SPI mode (clock polarity, phase, and shift direction)
N * @param[in]     slave Zero for master mode or non-zero for slave mode
N */
Nvoid spi_format(spi_t *obj, int bits, int mode, int slave);
N
N/** Set the SPI baud rate
N *
N * Actual frequency may differ from the desired frequency due to available dividers and bus clock
N * Configures the SPI peripheral's baud rate
N * @param[in,out] obj The SPI object to configure
N * @param[in]     hz  The baud rate in Hz
N */
Nvoid spi_frequency(spi_t *obj, int hz);
N
N/**@}*/
N/**
N * \defgroup SynchSPI Synchronous SPI Hardware Abstraction Layer
N * @{
N */
N
N/** Write a byte out in master mode and receive a value
N *
N * @param[in] obj   The SPI peripheral to use for sending
N * @param[in] value The value to send
N * @return Returns the value received during send
N */
Nint  spi_master_write(spi_t *obj, int value);
N
N/** Check if a value is available to read
N *
N * @param[in] obj The SPI peripheral to check
N * @return non-zero if a value is available
N */
Nint  spi_slave_receive(spi_t *obj);
N
N/** Get a received value out of the SPI receive buffer in slave mode
N *
N * Blocks until a value is available
N * @param[in] obj The SPI peripheral to read
N * @return The value received
N */
Nint  spi_slave_read(spi_t *obj);
N
N/** Write a value to the SPI peripheral in slave mode
N *
N * Blocks until the SPI peripheral can be written to
N * @param[in] obj   The SPI peripheral to write
N * @param[in] value The value to write
N */
Nvoid spi_slave_write(spi_t *obj, int value);
N
N/** Checks if the specified SPI peripheral is in use
N *
N * @param[in] obj The SPI peripheral to check
N * @return non-zero if the peripheral is currently transmitting
N */
Nint  spi_busy(spi_t *obj);
N
N/** Get the module number
N *
N * @param[in] obj The SPI peripheral to check
N * @return The module number
N */
Nuint8_t spi_get_module(spi_t *obj);
N
N/**@}*/
N
N#if DEVICE_SPI_ASYNCH
S/**
S * \defgroup AsynchSPI Asynchronous SPI Hardware Abstraction Layer
S * @{
S */
S
S/** Begin the SPI transfer. Buffer pointers and lengths are specified in tx_buff and rx_buff
S *
S * @param[in] obj       The SPI object that holds the transfer information
S * @param[in] tx        The transmit buffer
S * @param[in] tx_length The number of bytes to transmit
S * @param[in] rx        The receive buffer
S * @param[in] rx_length The number of bytes to receive
S * @param[in] bit_width The bit width of buffer words
S * @param[in] event     The logical OR of events to be registered
S * @param[in] handler   SPI interrupt handler
S * @param[in] hint      A suggestion for how to use DMA with this transfer
S */
Svoid spi_master_transfer(spi_t *obj, const void *tx, size_t tx_length, void *rx, size_t rx_length, uint8_t bit_width, uint32_t handler, uint32_t event, DMAUsage hint);
S
S/** The asynchronous IRQ handler
S *
S * Reads the received values out of the RX FIFO, writes values into the TX FIFO and checks for transfer termination
S * conditions, such as buffer overflows or transfer complete.
S * @param[in] obj     The SPI object that holds the transfer information
S * @return Event flags if a transfer termination condition was met; otherwise 0.
S */
Suint32_t spi_irq_handler_asynch(spi_t *obj);
S
S/** Attempts to determine if the SPI peripheral is already in use
S *
S * If a temporary DMA channel has been allocated, peripheral is in use.
S * If a permanent DMA channel has been allocated, check if the DMA channel is in use.  If not, proceed as though no DMA
S * channel were allocated.
S * If no DMA channel is allocated, check whether tx and rx buffers have been assigned.  For each assigned buffer, check
S * if the corresponding buffer position is less than the buffer length.  If buffers do not indicate activity, check if
S * there are any bytes in the FIFOs.
S * @param[in] obj The SPI object to check for activity
S * @return Non-zero if the SPI port is active or zero if it is not.
S */
Suint8_t spi_active(spi_t *obj);
S
S/** Abort an SPI transfer
S *
S * @param obj The SPI peripheral to stop
S */
Svoid spi_abort_asynch(spi_t *obj);
S
S
N#endif
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif // __cplusplus
N
N#endif // SPI_DEVICE
N
N#endif // MBED_SPI_API_H
N
N/** @}*/
L 25 "mbed/./drivers/SPI.h" 2
N#include "platform/SingletonPtr.h"
N
N#if DEVICE_SPI_ASYNCH
S#include "platform/CThunk.h"
S#include "hal/dma_api.h"
S#include "platform/CircularBuffer.h"
S#include "platform/FunctionPointer.h"
S#include "platform/Transaction.h"
N#endif
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A SPI Master, used for communicating with SPI slave devices
N *
N * The default format is set to 8-bits, mode 0, and a clock frequency of 1MHz
N *
N * Most SPI devices will also require Chip Select and Reset signals. These
N * can be controlled using <DigitalOut> pins
N *
N * @Note Synchronization level: Thread safe
N *
N * Example:
N * @code
N * // Send a byte to a SPI slave, and record the response
N *
N * #include "mbed.h"
N *
N * // hardware ssel (where applicable)
N * //SPI device(p5, p6, p7, p8); // mosi, miso, sclk, ssel
N *
N * // software ssel
N * SPI device(p5, p6, p7); // mosi, miso, sclk
N * DigitalOut cs(p8); // ssel
N *
N * int main() {
N *     // hardware ssel (where applicable)
N *     //int response = device.write(0xFF);
N *
N *     device.lock();
N *     // software ssel
N *     cs = 0;
N *     int response = device.write(0xFF);
N *     cs = 1;
N *     device.unlock();
N *
N * }
N * @endcode
N */
Nclass SPI {
N
Npublic:
N
N    /** Create a SPI master connected to the specified pins
N     *
N     *  mosi or miso can be specfied as NC if not used
N     *
N     *  @param mosi SPI Master Out, Slave In pin
N     *  @param miso SPI Master In, Slave Out pin
N     *  @param sclk SPI Clock pin
N     *  @param ssel SPI chip select pin
N     */
N    SPI(PinName mosi, PinName miso, PinName sclk, PinName ssel=NC);
N
N    /** Configure the data transmission format
N     *
N     *  @param bits Number of bits per SPI frame (4 - 16)
N     *  @param mode Clock polarity and phase mode (0 - 3)
N     *
N     * @code
N     * mode | POL PHA
N     * -----+--------
N     *   0  |  0   0
N     *   1  |  0   1
N     *   2  |  1   0
N     *   3  |  1   1
N     * @endcode
N     */
N    void format(int bits, int mode = 0);
N
N    /** Set the spi bus clock frequency
N     *
N     *  @param hz SCLK frequency in hz (default = 1MHz)
N     */
N    void frequency(int hz = 1000000);
N
N    /** Write to the SPI Slave and return the response
N     *
N     *  @param value Data to be sent to the SPI slave
N     *
N     *  @returns
N     *    Response from the SPI slave
N    */
N    virtual int write(int value);
N
N    /** Acquire exclusive access to this SPI bus
N     */
N    virtual void lock(void);
N
N    /** Release exclusive access to this SPI bus
N     */
N    virtual void unlock(void);
N
N#if DEVICE_SPI_ASYNCH
S
S    /** Start non-blocking SPI transfer using 8bit buffers.
S     *
S     * @param tx_buffer The TX buffer with data to be transfered. If NULL is passed,
S     *                  the default SPI value is sent
S     * @param tx_length The length of TX buffer in bytes
S     * @param rx_buffer The RX buffer which is used for received data. If NULL is passed,
S     *                  received data are ignored
S     * @param rx_length The length of RX buffer in bytes
S     * @param callback  The event callback function
S     * @param event     The logical OR of events to modify. Look at spi hal header file for SPI events.
S     * @return Zero if the transfer has started, or -1 if SPI peripheral is busy
S     */
S    template<typename Type>
S    int transfer(const Type *tx_buffer, int tx_length, Type *rx_buffer, int rx_length, const event_callback_t& callback, int event = SPI_EVENT_COMPLETE) {
S        if (spi_active(&_spi)) {
S            return queue_transfer(tx_buffer, tx_length, rx_buffer, rx_length, sizeof(Type)*8, callback, event);
S        }
S        start_transfer(tx_buffer, tx_length, rx_buffer, rx_length, sizeof(Type)*8, callback, event);
S        return 0;
S    }
S
S    /** Abort the on-going SPI transfer, and continue with transfer's in the queue if any.
S     */
S    void abort_transfer();
S
S    /** Clear the transaction buffer
S     */
S    void clear_transfer_buffer();
S
S    /** Clear the transaction buffer and abort on-going transfer.
S     */
S    void abort_all_transfers();
S
S    /** Configure DMA usage suggestion for non-blocking transfers
S     *
S     *  @param usage The usage DMA hint for peripheral
S     *  @return Zero if the usage was set, -1 if a transaction is on-going
S    */
S    int set_dma_usage(DMAUsage usage);
S
Sprotected:
S    /** SPI IRQ handler
S     *
S    */
S    void irq_handler_asynch(void);
S
S    /** Common transfer method
S     *
S     * @param tx_buffer The TX buffer with data to be transfered. If NULL is passed,
S     *                  the default SPI value is sent
S     * @param tx_length The length of TX buffer in bytes
S     * @param rx_buffer The RX buffer which is used for received data. If NULL is passed,
S     *                  received data are ignored
S     * @param rx_length The length of RX buffer in bytes
S     * @param bit_width The buffers element width
S     * @param callback  The event callback function
S     * @param event     The logical OR of events to modify
S     * @return Zero if the transfer has started or was added to the queue, or -1 if SPI peripheral is busy/buffer is full
S    */
S    int transfer(const void *tx_buffer, int tx_length, void *rx_buffer, int rx_length, unsigned char bit_width, const event_callback_t& callback, int event);
S
S    /**
S     *
S     * @param tx_buffer The TX buffer with data to be transfered. If NULL is passed,
S     *                  the default SPI value is sent
S     * @param tx_length The length of TX buffer in bytes
S     * @param rx_buffer The RX buffer which is used for received data. If NULL is passed,
S     *                  received data are ignored
S     * @param rx_length The length of RX buffer in bytes
S     * @param bit_width The buffers element width
S     * @param callback  The event callback function
S     * @param event     The logical OR of events to modify
S     * @return Zero if a transfer was added to the queue, or -1 if the queue is full
S    */
S    int queue_transfer(const void *tx_buffer, int tx_length, void *rx_buffer, int rx_length, unsigned char bit_width, const event_callback_t& callback, int event);
S
S    /** Configures a callback, spi peripheral and initiate a new transfer
S     *
S     * @param tx_buffer The TX buffer with data to be transfered. If NULL is passed,
S     *                  the default SPI value is sent
S     * @param tx_length The length of TX buffer in bytes
S     * @param rx_buffer The RX buffer which is used for received data. If NULL is passed,
S     *                  received data are ignored
S     * @param rx_length The length of RX buffer in bytes
S     * @param bit_width The buffers element width
S     * @param callback  The event callback function
S     * @param event     The logical OR of events to modify
S    */
S    void start_transfer(const void *tx_buffer, int tx_length, void *rx_buffer, int rx_length, unsigned char bit_width, const event_callback_t& callback, int event);
S
S#if TRANSACTION_QUEUE_SIZE_SPI
S
S    /** Start a new transaction
S     *
S     *  @param data Transaction data
S    */
S    void start_transaction(transaction_t *data);
S
S    /** Dequeue a transaction
S     *
S    */
S    void dequeue_transaction();
S    static CircularBuffer<Transaction<SPI>, TRANSACTION_QUEUE_SIZE_SPI> _transaction_buffer;
S#endif
S
N#endif
N
Npublic:
N    virtual ~SPI() {
N    }
N
Nprotected:
N    spi_t _spi;
N
N#if DEVICE_SPI_ASYNCH
S    CThunk<SPI> _irq;
S    event_callback_t _callback;
S    DMAUsage _usage;
N#endif
N
N    void aquire(void);
N    static SPI *_owner;
N    static SingletonPtr<PlatformMutex> _mutex;
N    int _bits;
N    int _mode;
N    int _hz;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 82 "mbed/./mbed.h" 2
N#include "drivers/SPISlave.h"
L 1 "mbed/./drivers/SPISlave.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SPISLAVE_H
N#define MBED_SPISLAVE_H
N
N#include "platform/platform.h"
N
N#if DEVICE_SPISLAVE
X#if 1
N
N#include "hal/spi_api.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A SPI slave, used for communicating with a SPI Master device
N *
N * The default format is set to 8-bits, mode 0, and a clock frequency of 1MHz
N *
N * @Note Synchronization level: Not protected
N *
N * Example:
N * @code
N * // Reply to a SPI master as slave
N *
N * #include "mbed.h"
N *
N * SPISlave device(p5, p6, p7, p8); // mosi, miso, sclk, ssel
N *
N * int main() {
N *     device.reply(0x00);              // Prime SPI with first reply
N *     while(1) {
N *         if(device.receive()) {
N *             int v = device.read();   // Read byte from master
N *             v = (v + 1) % 0x100;     // Add one to it, modulo 256
N *             device.reply(v);         // Make this the next reply
N *         }
N *     }
N * }
N * @endcode
N */
Nclass SPISlave {
N
Npublic:
N
N    /** Create a SPI slave connected to the specified pins
N     *
N     *  mosi or miso can be specfied as NC if not used
N     *
N     *  @param mosi SPI Master Out, Slave In pin
N     *  @param miso SPI Master In, Slave Out pin
N     *  @param sclk SPI Clock pin
N     *  @param ssel SPI chip select pin
N     */
N    SPISlave(PinName mosi, PinName miso, PinName sclk, PinName ssel);
N
N    /** Configure the data transmission format
N     *
N     *  @param bits Number of bits per SPI frame (4 - 16)
N     *  @param mode Clock polarity and phase mode (0 - 3)
N     *
N     * @code
N     * mode | POL PHA
N     * -----+--------
N     *   0  |  0   0
N     *   1  |  0   1
N     *   2  |  1   0
N     *   3  |  1   1
N     * @endcode
N     */
N    void format(int bits, int mode = 0);
N
N    /** Set the spi bus clock frequency
N     *
N     *  @param hz SCLK frequency in hz (default = 1MHz)
N     */
N    void frequency(int hz = 1000000);
N
N    /** Polls the SPI to see if data has been received
N     *
N     *  @returns
N     *    0 if no data,
N     *    1 otherwise
N     */
N    int receive(void);
N
N    /** Retrieve  data from receive buffer as slave
N     *
N     *  @returns
N     *    the data in the receive buffer
N     */
N    int read(void);
N
N    /** Fill the transmission buffer with the value to be written out
N     *  as slave on the next received message from the master.
N     *
N     *  @param value the data to be transmitted next
N     */
N    void reply(int value);
N
Nprotected:
N    spi_t _spi;
N
N    int _bits;
N    int _mode;
N    int _hz;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 83 "mbed/./mbed.h" 2
N#include "drivers/I2C.h"
L 1 "mbed/./drivers/I2C.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_I2C_H
N#define MBED_I2C_H
N
N#include "platform/platform.h"
N
N#if DEVICE_I2C
X#if 1
N
N#include "hal/i2c_api.h"
L 1 "mbed/./hal/i2c_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_I2C_API_H
N#define MBED_I2C_API_H
N
N#include "device.h"
N#include "hal/buffer.h"
N
N#if DEVICE_I2C_ASYNCH
S#include "hal/dma_api.h"
N#endif
N
N#if DEVICE_I2C
X#if 1
N
N/**
N * @defgroup hal_I2CEvents I2C Events Macros
N *
N * @{
N */
N#define I2C_EVENT_ERROR               (1 << 1)
N#define I2C_EVENT_ERROR_NO_SLAVE      (1 << 2)
N#define I2C_EVENT_TRANSFER_COMPLETE   (1 << 3)
N#define I2C_EVENT_TRANSFER_EARLY_NACK (1 << 4)
N#define I2C_EVENT_ALL                 (I2C_EVENT_ERROR |  I2C_EVENT_TRANSFER_COMPLETE | I2C_EVENT_ERROR_NO_SLAVE | I2C_EVENT_TRANSFER_EARLY_NACK)
N
N/**@}*/
N
N#if DEVICE_I2C_ASYNCH
S/** Asynch I2C HAL structure
S */
Stypedef struct {
S    struct i2c_s    i2c;     /**< Target specific I2C structure */
S    struct buffer_s tx_buff; /**< Tx buffer */
S    struct buffer_s rx_buff; /**< Rx buffer */
S} i2c_t;
S
N#else
N/** Non-asynch I2C HAL structure
N */
Ntypedef struct i2c_s i2c_t;
N
N#endif
N
Nenum {
N  I2C_ERROR_NO_SLAVE = -1,
N  I2C_ERROR_BUS_BUSY = -2
N};
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/**
N * \defgroup hal_GeneralI2C I2C Configuration Functions
N * @{
N */
N
N/** Initialize the I2C peripheral. It sets the default parameters for I2C
N *  peripheral, and configures its specifieds pins.
N *  
N *  @param obj  The I2C object
N *  @param sda  The sda pin
N *  @param scl  The scl pin
N */
Nvoid i2c_init(i2c_t *obj, PinName sda, PinName scl);
N
N/** Configure the I2C frequency
N *
N *  @param obj The I2C object
N *  @param hz  Frequency in Hz
N */
Nvoid i2c_frequency(i2c_t *obj, int hz);
N
N/** Send START command
N *
N *  @param obj The I2C object
N */
Nint  i2c_start(i2c_t *obj);
N
N/** Send STOP command
N *
N *  @param obj The I2C object
N */
Nint  i2c_stop(i2c_t *obj);
N
N/** Blocking reading data
N *
N *  @param obj     The I2C object
N *  @param address 7-bit address (last bit is 1)
N *  @param data    The buffer for receiving
N *  @param length  Number of bytes to read
N *  @param stop    Stop to be generated after the transfer is done
N *  @return Number of read bytes
N */
Nint i2c_read(i2c_t *obj, int address, char *data, int length, int stop);
N
N/** Blocking sending data
N *
N *  @param obj     The I2C object
N *  @param address 7-bit address (last bit is 0)
N *  @param data    The buffer for sending
N *  @param length  Number of bytes to write
N *  @param stop    Stop to be generated after the transfer is done
N *  @return 
N *      zero or non-zero - Number of written bytes
N *      negative - I2C_ERROR_XXX status
N */
Nint i2c_write(i2c_t *obj, int address, const char *data, int length, int stop);
N
N/** Reset I2C peripheral. TODO: The action here. Most of the implementation sends stop()
N *
N *  @param obj The I2C object
N */
Nvoid i2c_reset(i2c_t *obj);
N
N/** Read one byte
N *
N *  @param obj The I2C object
N *  @param last Acknoledge
N *  @return The read byte
N */
Nint i2c_byte_read(i2c_t *obj, int last);
N
N/** Write one byte
N *
N *  @param obj The I2C object
N *  @param data Byte to be written
N *  @return 0 if NAK was received, 1 if ACK was received, 2 for timeout.
N */
Nint i2c_byte_write(i2c_t *obj, int data);
N
N/**@}*/
N
N#if DEVICE_I2CSLAVE
X#if 1
N
N/**
N * \defgroup SynchI2C Synchronous I2C Hardware Abstraction Layer for slave
N * @{
N */
N
N/** Configure I2C as slave or master.
N *  @param obj The I2C object
N *  @return non-zero if a value is available
N */
Nvoid i2c_slave_mode(i2c_t *obj, int enable_slave);
N
N/** Check to see if the I2C slave has been addressed.
N *  @param obj The I2C object
N *  @return The status - 1 - read addresses, 2 - write to all slaves,
N *         3 write addressed, 0 - the slave has not been addressed
N */
Nint  i2c_slave_receive(i2c_t *obj);
N
N/** Configure I2C as slave or master.
N *  @param obj The I2C object
N *  @return non-zero if a value is available
N */
Nint  i2c_slave_read(i2c_t *obj, char *data, int length);
N
N/** Configure I2C as slave or master.
N *  @param obj The I2C object
N *  @return non-zero if a value is available
N */
Nint  i2c_slave_write(i2c_t *obj, const char *data, int length);
N
N/** Configure I2C address.
N *  @param obj     The I2C object
N *  @param idx     Currently not used
N *  @param address The address to be set
N *  @param mask    Currently not used
N */
Nvoid i2c_slave_address(i2c_t *obj, int idx, uint32_t address, uint32_t mask);
N
N#endif
N
N/**@}*/
N
N#if DEVICE_I2C_ASYNCH
S
S/**
S * \defgroup hal_AsynchI2C Asynchronous I2C Hardware Abstraction Layer
S * @{
S */
S
S/** Start I2C asynchronous transfer
S *
S *  @param obj       The I2C object
S *  @param tx        The transmit buffer
S *  @param tx_length The number of bytes to transmit
S *  @param rx        The receive buffer
S *  @param rx_length The number of bytes to receive
S *  @param address   The address to be set - 7bit or 9bit
S *  @param stop      If true, stop will be generated after the transfer is done
S *  @param handler   The I2C IRQ handler to be set
S *  @param hint      DMA hint usage
S */
Svoid i2c_transfer_asynch(i2c_t *obj, const void *tx, size_t tx_length, void *rx, size_t rx_length, uint32_t address, uint32_t stop, uint32_t handler, uint32_t event, DMAUsage hint);
S
S/** The asynchronous IRQ handler
S *
S *  @param obj The I2C object which holds the transfer information
S *  @return Event flags if a transfer termination condition was met, otherwise return 0.
S */
Suint32_t i2c_irq_handler_asynch(i2c_t *obj);
S
S/** Attempts to determine if the I2C peripheral is already in use
S *
S *  @param obj The I2C object
S *  @return Non-zero if the I2C module is active or zero if it is not
S */
Suint8_t i2c_active(i2c_t *obj);
S
S/** Abort asynchronous transfer
S *
S *  This function does not perform any check - that should happen in upper layers.
S *  @param obj The I2C object
S */
Svoid i2c_abort_asynch(i2c_t *obj);
S
N#endif
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N#endif
N
N/** @}*/
L 24 "mbed/./drivers/I2C.h" 2
N#include "platform/SingletonPtr.h"
N#include "platform/PlatformMutex.h"
N
N#if DEVICE_I2C_ASYNCH
S#include "platform/CThunk.h"
S#include "hal/dma_api.h"
S#include "platform/FunctionPointer.h"
N#endif
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** An I2C Master, used for communicating with I2C slave devices
N *
N * @Note Synchronization level: Thread safe
N *
N * Example:
N * @code
N * // Read from I2C slave at address 0x62
N *
N * #include "mbed.h"
N *
N * I2C i2c(p28, p27);
N *
N * int main() {
N *     int address = 0x62;
N *     char data[2];
N *     i2c.read(address, data, 2);
N * }
N * @endcode
N */
Nclass I2C {
N
Npublic:
N    enum RxStatus {
N        NoData,
N        MasterGeneralCall,
N        MasterWrite,
N        MasterRead
N    };
N
N    enum Acknowledge {
N        NoACK = 0,
N        ACK   = 1
N    };
N
N    /** Create an I2C Master interface, connected to the specified pins
N     *
N     *  @param sda I2C data line pin
N     *  @param scl I2C clock line pin
N     */
N    I2C(PinName sda, PinName scl);
N
N    /** Set the frequency of the I2C interface
N     *
N     *  @param hz The bus frequency in hertz
N     */
N    void frequency(int hz);
N
N    /** Read from an I2C slave
N     *
N     * Performs a complete read transaction. The bottom bit of
N     * the address is forced to 1 to indicate a read.
N     *
N     *  @param address 8-bit I2C slave address [ addr | 1 ]
N     *  @param data Pointer to the byte-array to read data in to
N     *  @param length Number of bytes to read
N     *  @param repeated Repeated start, true - don't send stop at end
N     *
N     *  @returns
N     *       0 on success (ack),
N     *   non-0 on failure (nack)
N     */
N    int read(int address, char *data, int length, bool repeated = false);
N
N    /** Read a single byte from the I2C bus
N     *
N     *  @param ack indicates if the byte is to be acknowledged (1 = acknowledge)
N     *
N     *  @returns
N     *    the byte read
N     */
N    int read(int ack);
N
N    /** Write to an I2C slave
N     *
N     * Performs a complete write transaction. The bottom bit of
N     * the address is forced to 0 to indicate a write.
N     *
N     *  @param address 8-bit I2C slave address [ addr | 0 ]
N     *  @param data Pointer to the byte-array data to send
N     *  @param length Number of bytes to send
N     *  @param repeated Repeated start, true - do not send stop at end
N     *
N     *  @returns
N     *       0 on success (ack),
N     *   non-0 on failure (nack)
N     */
N    int write(int address, const char *data, int length, bool repeated = false);
N
N    /** Write single byte out on the I2C bus
N     *
N     *  @param data data to write out on bus
N     *
N     *  @returns
N     *    '0' - NAK was received
N     *    '1' - ACK was received,
N     *    '2' - timeout
N     */
N    int write(int data);
N
N    /** Creates a start condition on the I2C bus
N     */
N
N    void start(void);
N
N    /** Creates a stop condition on the I2C bus
N     */
N    void stop(void);
N
N    /** Acquire exclusive access to this I2C bus
N     */
N    virtual void lock(void);
N
N    /** Release exclusive access to this I2C bus
N     */
N    virtual void unlock(void);
N
N    virtual ~I2C() {
N        // Do nothing
N    }
N
N#if DEVICE_I2C_ASYNCH
S
S    /** Start non-blocking I2C transfer.
S     *
S     * @param address   8/10 bit I2c slave address
S     * @param tx_buffer The TX buffer with data to be transfered
S     * @param tx_length The length of TX buffer in bytes
S     * @param rx_buffer The RX buffer which is used for received data
S     * @param rx_length The length of RX buffer in bytes
S     * @param event     The logical OR of events to modify
S     * @param callback  The event callback function
S     * @param repeated Repeated start, true - do not send stop at end
S     * @return Zero if the transfer has started, or -1 if I2C peripheral is busy
S     */
S    int transfer(int address, const char *tx_buffer, int tx_length, char *rx_buffer, int rx_length, const event_callback_t& callback, int event = I2C_EVENT_TRANSFER_COMPLETE, bool repeated = false);
S
S    /** Abort the on-going I2C transfer
S     */
S    void abort_transfer();
Sprotected:
S    void irq_handler_asynch(void);
S    event_callback_t _callback;
S    CThunk<I2C> _irq;
S    DMAUsage _usage;
N#endif
N
Nprotected:
N    void aquire();
N
N    i2c_t _i2c;
N    static I2C  *_owner;
N    int         _hz;
N    static SingletonPtr<PlatformMutex> _mutex;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 84 "mbed/./mbed.h" 2
N#include "drivers/I2CSlave.h"
L 1 "mbed/./drivers/I2CSlave.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_I2C_SLAVE_H
N#define MBED_I2C_SLAVE_H
N
N#include "platform/platform.h"
N
N#if DEVICE_I2CSLAVE
X#if 1
N
N#include "hal/i2c_api.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** An I2C Slave, used for communicating with an I2C Master device
N *
N * @Note Synchronization level: Not protected
N *
N * Example:
N * @code
N * // Simple I2C responder
N * #include <mbed.h>
N *
N * I2CSlave slave(p9, p10);
N *
N * int main() {
N *     char buf[10];
N *     char msg[] = "Slave!";
N *
N *     slave.address(0xA0);
N *     while (1) {
N *         int i = slave.receive();
N *         switch (i) {
N *             case I2CSlave::ReadAddressed:
N *                 slave.write(msg, strlen(msg) + 1); // Includes null char
N *                 break;
N *             case I2CSlave::WriteGeneral:
N *                 slave.read(buf, 10);
N *                 printf("Read G: %s\n", buf);
N *                 break;
N *             case I2CSlave::WriteAddressed:
N *                 slave.read(buf, 10);
N *                 printf("Read A: %s\n", buf);
N *                 break;
N *         }
N *         for(int i = 0; i < 10; i++) buf[i] = 0;    // Clear buffer
N *     }
N * }
N * @endcode
N */
Nclass I2CSlave {
N
Npublic:
N    enum RxStatus {
N        NoData         = 0,
N        ReadAddressed  = 1,
N        WriteGeneral   = 2,
N        WriteAddressed = 3
N    };
N
N    /** Create an I2C Slave interface, connected to the specified pins.
N     *
N     *  @param sda I2C data line pin
N     *  @param scl I2C clock line pin
N     */
N    I2CSlave(PinName sda, PinName scl);
N
N    /** Set the frequency of the I2C interface
N     *
N     *  @param hz The bus frequency in hertz
N     */
N    void frequency(int hz);
N
N    /** Checks to see if this I2C Slave has been addressed.
N     *
N     *  @returns
N     *  A status indicating if the device has been addressed, and how
N     *  - NoData            - the slave has not been addressed
N     *  - ReadAddressed     - the master has requested a read from this slave
N     *  - WriteAddressed    - the master is writing to this slave
N     *  - WriteGeneral      - the master is writing to all slave
N     */
N    int receive(void);
N
N    /** Read from an I2C master.
N     *
N     *  @param data pointer to the byte array to read data in to
N     *  @param length maximum number of bytes to read
N     *
N     *  @returns
N     *       0 on success,
N     *   non-0 otherwise
N     */
N    int read(char *data, int length);
N
N    /** Read a single byte from an I2C master.
N     *
N     *  @returns
N     *    the byte read
N     */
N    int read(void);
N
N    /** Write to an I2C master.
N     *
N     *  @param data pointer to the byte array to be transmitted
N     *  @param length the number of bytes to transmite
N     *
N     *  @returns
N     *       0 on success,
N     *   non-0 otherwise
N     */
N    int write(const char *data, int length);
N
N    /** Write a single byte to an I2C master.
N     *
N     *  @data the byte to write
N     *
N     *  @returns
N     *    '1' if an ACK was received,
N     *    '0' otherwise
N     */
N    int write(int data);
N
N    /** Sets the I2C slave address.
N     *
N     *  @param address The address to set for the slave (ignoring the least
N     *  signifcant bit). If set to 0, the slave will only respond to the
N     *  general call address.
N     */
N    void address(int address);
N
N    /** Reset the I2C slave back into the known ready receiving state.
N     */
N    void stop(void);
N
Nprotected:
N    i2c_t _i2c;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 85 "mbed/./mbed.h" 2
N#include "drivers/Ethernet.h"
L 1 "mbed/./drivers/Ethernet.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_ETHERNET_H
N#define MBED_ETHERNET_H
N
N#include "platform/platform.h"
N
N#if DEVICE_ETHERNET
X#if 1
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** An ethernet interface, to use with the ethernet pins.
N *
N * @Note Synchronization level: Not protected
N *
N * Example:
N * @code
N * // Read destination and source from every ethernet packet
N *
N * #include "mbed.h"
N *
N * Ethernet eth;
N *
N * int main() {
N *     char buf[0x600];
N *
N *     while(1) {
N *         int size = eth.receive();
N *         if(size > 0) {
N *             eth.read(buf, size);
N *             printf("Destination:  %02X:%02X:%02X:%02X:%02X:%02X\n",
N *                     buf[0], buf[1], buf[2], buf[3], buf[4], buf[5]);
N *             printf("Source: %02X:%02X:%02X:%02X:%02X:%02X\n",
N *                     buf[6], buf[7], buf[8], buf[9], buf[10], buf[11]);
N *         }
N *
N *         wait(1);
N *     }
N * }
N * @endcode
N */
Nclass Ethernet {
N
Npublic:
N
N    /** Initialise the ethernet interface.
N     */
N    Ethernet();
N
N    /** Powers the hardware down.
N     */
N    virtual ~Ethernet();
N
N    enum Mode {
N        AutoNegotiate,
N        HalfDuplex10,
N        FullDuplex10,
N        HalfDuplex100,
N        FullDuplex100
N    };
N
N    /** Writes into an outgoing ethernet packet.
N     *
N     *  It will append size bytes of data to the previously written bytes.
N     *
N     *  @param data An array to write.
N     *  @param size The size of data.
N     *
N     *  @returns
N     *   The number of written bytes.
N     */
N    int write(const char *data, int size);
N
N    /** Send an outgoing ethernet packet.
N     *
N     *  After filling in the data in an ethernet packet it must be send.
N     *  Send will provide a new packet to write to.
N     *
N     *  @returns
N     *    0 if the sending was failed,
N     *    or the size of the packet successfully sent.
N     */
N    int send();
N
N    /** Recevies an arrived ethernet packet.
N     *
N     *  Receiving an ethernet packet will drop the last received ethernet packet
N     *  and make a new ethernet packet ready to read.
N     *  If no ethernet packet is arrived it will return 0.
N     *
N     *  @returns
N     *    0 if no ethernet packet is arrived,
N     *    or the size of the arrived packet.
N     */
N    int receive();
N
N    /** Read from an recevied ethernet packet.
N     *
N     *  After receive returnd a number bigger than 0it is
N     *  possible to read bytes from this packet.
N     *  Read will write up to size bytes into data.
N     *
N     *  It is possible to use read multible times.
N     *  Each time read will start reading after the last read byte before.
N     *
N     *  @returns
N     *  The number of byte read.
N     */
N    int read(char *data, int size);
N
N    /** Gives the ethernet address of the mbed.
N     *
N     *  @param mac Must be a pointer to a 6 byte char array to copy the ethernet address in.
N     */
N    void address(char *mac);
N
N    /** Returns if an ethernet link is pressent or not. It takes a wile after Ethernet initializion to show up.
N     *
N     *  @returns
N     *   0 if no ethernet link is pressent,
N     *   1 if an ethernet link is pressent.
N     *
N     * Example:
N     * @code
N     * // Using the Ethernet link function
N     * #include "mbed.h"
N     *
N     * Ethernet eth;
N     *
N     * int main() {
N     *     wait(1); // Needed after startup.
N     *     if (eth.link()) {
N     *          printf("online\n");
N     *     } else {
N     *          printf("offline\n");
N     *     }
N     * }
N     * @endcode
N     */
N    int link();
N
N    /** Sets the speed and duplex parameters of an ethernet link
N     *
N     * - AutoNegotiate      Auto negotiate speed and duplex
N     * - HalfDuplex10       10 Mbit, half duplex
N     * - FullDuplex10       10 Mbit, full duplex
N     * - HalfDuplex100      100 Mbit, half duplex
N     * - FullDuplex100      100 Mbit, full duplex
N     *
N     *  @param mode the speed and duplex mode to set the link to:
N     */
N    void set_link(Mode mode);
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 86 "mbed/./mbed.h" 2
N#include "drivers/CAN.h"
L 1 "mbed/./drivers/CAN.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_CAN_H
N#define MBED_CAN_H
N
N#include "platform/platform.h"
N
N#if DEVICE_CAN
X#if 1
N
N#include "hal/can_api.h"
L 1 "mbed/./hal/can_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2016 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_CAN_API_H
N#define MBED_CAN_API_H
N
N#include "device.h"
N
N#if DEVICE_CAN
X#if 1
N
N#include "PinNames.h"
N#include "PeripheralNames.h"
N#include "hal/can_helper.h"
L 1 "mbed/./hal/can_helper.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_CAN_HELPER_H
N#define MBED_CAN_HELPER_H
N
N#if DEVICE_CAN
X#if 1
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Nenum CANFormat {
N    CANStandard = 0,
N    CANExtended = 1,
N    CANAny = 2
N};
Ntypedef enum CANFormat CANFormat;
N
Nenum CANType {
N    CANData   = 0,
N    CANRemote = 1
N};
Ntypedef enum CANType CANType;
N
Nstruct CAN_Message {
N    unsigned int   id;                 // 29 bit identifier
N    unsigned char  data[8];            // Data field
N    unsigned char  len;                // Length of data field in bytes
N    CANFormat      format;             // 0 - STANDARD, 1- EXTENDED IDENTIFIER
N    CANType        type;               // 0 - DATA FRAME, 1 - REMOTE FRAME
N};
Ntypedef struct CAN_Message CAN_Message;
N
N#ifdef __cplusplus
N};
N#endif
N
N#endif
N
N#endif // MBED_CAN_HELPER_H
N
N/** @}*/
L 29 "mbed/./hal/can_api.h" 2
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
Ntypedef enum {
N    IRQ_RX,
N    IRQ_TX,
N    IRQ_ERROR,
N    IRQ_OVERRUN,
N    IRQ_WAKEUP,
N    IRQ_PASSIVE,
N    IRQ_ARB,
N    IRQ_BUS,
N    IRQ_READY
N} CanIrqType;
N
N
Ntypedef enum {
N    MODE_RESET,
N    MODE_NORMAL,
N    MODE_SILENT,
N    MODE_TEST_LOCAL,
N    MODE_TEST_GLOBAL,
N    MODE_TEST_SILENT
N} CanMode;
N
Ntypedef void (*can_irq_handler)(uint32_t id, CanIrqType type);
N
Ntypedef struct can_s can_t;
N
Nvoid          can_init     (can_t *obj, PinName rd, PinName td);
Nvoid          can_free     (can_t *obj);
Nint           can_frequency(can_t *obj, int hz);
N
Nvoid          can_irq_init (can_t *obj, can_irq_handler handler, uint32_t id);
Nvoid          can_irq_free (can_t *obj);
Nvoid          can_irq_set  (can_t *obj, CanIrqType irq, uint32_t enable);
N
Nint           can_write    (can_t *obj, CAN_Message, int cc);
Nint           can_read     (can_t *obj, CAN_Message *msg, int handle);
Nint           can_mode     (can_t *obj, CanMode mode);
Nint           can_filter(can_t *obj, uint32_t id, uint32_t mask, CANFormat format, int32_t handle);
Nvoid          can_reset    (can_t *obj);
Nunsigned char can_rderror  (can_t *obj);
Nunsigned char can_tderror  (can_t *obj);
Nvoid          can_monitor  (can_t *obj, int silent);
N
N#ifdef __cplusplus
N};
N#endif
N
N#endif    // MBED_CAN_API_H
N
N#endif
N
N/** @}*/
L 24 "mbed/./drivers/CAN.h" 2
N#include "platform/Callback.h"
N#include "platform/PlatformMutex.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** CANMessage class
N *
N * @Note Synchronization level: Thread safe
N */
Nclass CANMessage : public CAN_Message {
N
Npublic:
N    /** Creates empty CAN message.
N     */
N    CANMessage() : CAN_Message() {
N        len    = 8;
N        type   = CANData;
N        format = CANStandard;
N        id     = 0;
N        memset(data, 0, 8);
N    }
N
N    /** Creates CAN message with specific content.
N     */
N    CANMessage(int _id, const char *_data, char _len = 8, CANType _type = CANData, CANFormat _format = CANStandard) {
N      len    = _len & 0xF;
N      type   = _type;
N      format = _format;
N      id     = _id;
N      memcpy(data, _data, _len);
N    }
N
N    /** Creates CAN remote message.
N     */
N    CANMessage(int _id, CANFormat _format = CANStandard) {
N      len    = 0;
N      type   = CANRemote;
N      format = _format;
N      id     = _id;
N      memset(data, 0, 8);
N    }
N};
N
N/** A can bus client, used for communicating with can devices
N */
Nclass CAN {
N
Npublic:
N    /** Creates an CAN interface connected to specific pins.
N     *
N     *  @param rd read from transmitter
N     *  @param td transmit to transmitter
N     *
N     * Example:
N     * @code
N     * #include "mbed.h"
N     *
N     * Ticker ticker;
N     * DigitalOut led1(LED1);
N     * DigitalOut led2(LED2);
N     * CAN can1(p9, p10);
N     * CAN can2(p30, p29);
N     *
N     * char counter = 0;
N     *
N     * void send() {
N     *     if(can1.write(CANMessage(1337, &counter, 1))) {
N     *         printf("Message sent: %d\n", counter);
N     *         counter++;
N     *     }
N     *     led1 = !led1;
N     * }
N     *
N     * int main() {
N     *     ticker.attach(&send, 1);
N     *    CANMessage msg;
N     *     while(1) {
N     *         if(can2.read(msg)) {
N     *             printf("Message received: %d\n\n", msg.data[0]);
N     *             led2 = !led2;
N     *         }
N     *         wait(0.2);
N     *     }
N     * }
N     * @endcode
N     */
N    CAN(PinName rd, PinName td);
N    virtual ~CAN();
N
N    /** Set the frequency of the CAN interface
N     *
N     *  @param hz The bus frequency in hertz
N     *
N     *  @returns
N     *    1 if successful,
N     *    0 otherwise
N     */
N    int frequency(int hz);
N
N    /** Write a CANMessage to the bus.
N     *
N     *  @param msg The CANMessage to write.
N     *
N     *  @returns
N     *    0 if write failed,
N     *    1 if write was successful
N     */
N    int write(CANMessage msg);
N
N    /** Read a CANMessage from the bus.
N     *
N     *  @param msg A CANMessage to read to.
N     *  @param handle message filter handle (0 for any message)
N     *
N     *  @returns
N     *    0 if no message arrived,
N     *    1 if message arrived
N     */
N    int read(CANMessage &msg, int handle = 0);
N
N    /** Reset CAN interface.
N     *
N     * To use after error overflow.
N     */
N    void reset();
N
N    /** Puts or removes the CAN interface into silent monitoring mode
N     *
N     *  @param silent boolean indicating whether to go into silent mode or not
N     */
N    void monitor(bool silent);
N
N    enum Mode {
N        Reset = 0,
N        Normal,
N        Silent,
N        LocalTest,
N        GlobalTest,
N        SilentTest
N    };
N
N    /** Change CAN operation to the specified mode
N     *
N     *  @param mode The new operation mode (CAN::Normal, CAN::Silent, CAN::LocalTest, CAN::GlobalTest, CAN::SilentTest)
N     *
N     *  @returns
N     *    0 if mode change failed or unsupported,
N     *    1 if mode change was successful
N     */
N    int mode(Mode mode);
N
N    /** Filter out incomming messages
N     *
N     *  @param id the id to filter on
N     *  @param mask the mask applied to the id
N     *  @param format format to filter on (Default CANAny)
N     *  @param handle message filter handle (Optional)
N     *
N     *  @returns
N     *    0 if filter change failed or unsupported,
N     *    new filter handle if successful
N     */
N    int filter(unsigned int id, unsigned int mask, CANFormat format = CANAny, int handle = 0);
N
N    /** Returns number of read errors to detect read overflow errors.
N     */
N    unsigned char rderror();
N
N    /** Returns number of write errors to detect write overflow errors.
N     */
N    unsigned char tderror();
N
N    enum IrqType {
N        RxIrq = 0,
N        TxIrq,
N        EwIrq,
N        DoIrq,
N        WuIrq,
N        EpIrq,
N        AlIrq,
N        BeIrq,
N        IdIrq,
N
N        IrqCnt
N    };
N
N    /** Attach a function to call whenever a CAN frame received interrupt is
N     *  generated.
N     *
N     *  @param func A pointer to a void function, or 0 to set as none
N     *  @param event Which CAN interrupt to attach the member function to (CAN::RxIrq for message received, CAN::TxIrq for transmitted or aborted, CAN::EwIrq for error warning, CAN::DoIrq for data overrun, CAN::WuIrq for wake-up, CAN::EpIrq for error passive, CAN::AlIrq for arbitration lost, CAN::BeIrq for bus error)
N     */
N    void attach(Callback<void()> func, IrqType type=RxIrq);
N
N   /** Attach a member function to call whenever a CAN frame received interrupt
N    *  is generated.
N    *
N    *  @param obj pointer to the object to call the member function on
N    *  @param method pointer to the member function to be called
N    *  @param event Which CAN interrupt to attach the member function to (CAN::RxIrq for message received, TxIrq for transmitted or aborted, EwIrq for error warning, DoIrq for data overrun, WuIrq for wake-up, EpIrq for error passive, AlIrq for arbitration lost, BeIrq for bus error)
N    */
N    template<typename T>
N    void attach(T* obj, void (T::*method)(), IrqType type=RxIrq) {
N        // Underlying call thread safe
N        attach(Callback<void()>(obj, method), type);
N    }
N
N   /** Attach a member function to call whenever a CAN frame received interrupt
N    *  is generated.
N    *
N    *  @param obj pointer to the object to call the member function on
N    *  @param method pointer to the member function to be called
N    *  @param event Which CAN interrupt to attach the member function to (CAN::RxIrq for message received, TxIrq for transmitted or aborted, EwIrq for error warning, DoIrq for data overrun, WuIrq for wake-up, EpIrq for error passive, AlIrq for arbitration lost, BeIrq for bus error)
N    */
N    template<typename T>
N    void attach(T* obj, void (*method)(T*), IrqType type=RxIrq) {
N        // Underlying call thread safe
N        attach(Callback<void()>(obj, method), type);
N    }
N
N    static void _irq_handler(uint32_t id, CanIrqType type);
N
Nprotected:
N    virtual void lock();
N    virtual void unlock();
N    can_t               _can;
N    Callback<void()>    _irq[IrqCnt];
N    PlatformMutex       _mutex;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif    // MBED_CAN_H
N
N/** @}*/
L 87 "mbed/./mbed.h" 2
N#include "drivers/RawSerial.h"
L 1 "mbed/./drivers/RawSerial.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_RAW_SERIAL_H
N#define MBED_RAW_SERIAL_H
N
N#include "platform/platform.h"
N
N#if DEVICE_SERIAL
X#if 1
N
N#include "drivers/SerialBase.h"
N#include "hal/serial_api.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A serial port (UART) for communication with other serial devices
N * This is a variation of the Serial class that doesn't use streams,
N * thus making it safe to use in interrupt handlers with the RTOS.
N *
N * Can be used for Full Duplex communication, or Simplex by specifying
N * one pin as NC (Not Connected)
N *
N * @Note Synchronization level: Not protected
N *
N * Example:
N * @code
N * // Send a char to the PC
N *
N * #include "mbed.h"
N *
N * RawSerial pc(USBTX, USBRX);
N *
N * int main() {
N *     pc.putc('A');
N * }
N * @endcode
N */
Nclass RawSerial: public SerialBase {
N
Npublic:
N    /** Create a RawSerial port, connected to the specified transmit and receive pins, with the specified baud.
N     *
N     *  @param tx Transmit pin
N     *  @param rx Receive pin
N     *  @param baud The baud rate of the serial port (optional, defaults to MBED_CONF_PLATFORM_DEFAULT_SERIAL_BAUD_RATE)
N     *
N     *  @note
N     *    Either tx or rx may be specified as NC if unused
N     */
N    RawSerial(PinName tx, PinName rx, int baud = MBED_CONF_PLATFORM_DEFAULT_SERIAL_BAUD_RATE);
X    RawSerial(PinName tx, PinName rx, int baud = 9600);
N
N    /** Write a char to the serial port
N     *
N     * @param c The char to write
N     *
N     * @returns The written char or -1 if an error occured
N     */
N    int putc(int c);
N
N    /** Read a char from the serial port
N     *
N     * @returns The char read from the serial port
N     */
N    int getc();
N
N    /** Write a string to the serial port
N     *
N     * @param str The string to write
N     *
N     * @returns 0 if the write succeeds, EOF for error
N     */
N    int puts(const char *str);
N
N    int printf(const char *format, ...);
N
Nprotected:
N
N    /** Acquire exclusive access to this serial port
N     */
N    virtual void lock(void);
N
N    /** Release exclusive access to this serial port
N     */
N    virtual void unlock(void);
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 88 "mbed/./mbed.h" 2
N#include "drivers/FlashIAP.h"
L 1 "mbed/./drivers/FlashIAP.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2017 ARM Limited
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy
N * of this software and associated documentation files (the "Software"), to deal
N * in the Software without restriction, including without limitation the rights
N * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
N * copies of the Software, and to permit persons to whom the Software is
N * furnished to do so, subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in
N * all copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
N * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
N * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
N * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
N * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
N * SOFTWARE.
N */
N#ifndef MBED_FLASHIAP_H
N#define MBED_FLASHIAP_H
N
N#ifdef DEVICE_FLASH
S
S#include "flash_api.h"
S#include "platform/SingletonPtr.h"
S#include "platform/PlatformMutex.h"
S
Snamespace mbed {
S
S/** \addtogroup drivers */
S/** @{*/
S
S/** Flash IAP driver. It invokes flash HAL functions.
S *
S * Note Synchronization level: Thread safe
S */
Sclass FlashIAP {
Spublic:
S    FlashIAP();
S    ~FlashIAP();
S
S    /** Initialize a flash IAP device
S     *
S     *  Should be called once per lifetime of the object.
S     *  @return 0 on success or a negative error code on failure
S     */
S    int init();
S
S    /** Deinitialize a flash IAP device
S     *
S     *  @return 0 on success or a negative error code on failure
S     */
S    int deinit();
S
S    /** Read data from a flash device. 
S     *
S     *  This method invokes memcpy - reads number of bytes from the address
S     *
S     *  @param buffer Buffer to write to
S     *  @param addr   Flash address to begin reading from
S     *  @param size   Size to read in bytes
S     *  @return       0 on success, negative error code on failure
S     */
S    int read(void *buffer, uint32_t addr, uint32_t size);
S
S    /** Program data to pages
S     *
S     *  The sectors must have been erased prior to being programmed
S     *
S     *  @param buffer Buffer of data to be written
S     *  @param addr   Address of a page to begin writing to, must be a multiple of program and sector sizes
S     *  @param size   Size to write in bytes, must be a multiple of program and sector sizes
S     *  @return       0 on success, negative error code on failure
S     */
S    int program(const void *buffer, uint32_t addr, uint32_t size);
S
S    /** Erase sectors
S     *
S     *  The state of an erased sector is undefined until it has been programmed
S     *
S     *  @param addr Address of a sector to begin erasing, must be a multiple of the sector size
S     *  @param size Size to erase in bytes, must be a multiple of the sector size
S     *  @return     0 on success, negative error code on failure
S     */
S    int erase(uint32_t addr, uint32_t size);
S
S    /** Get the sector size at the defined address
S     *
S     *  Sector size might differ at address ranges. 
S     *  An example <0-0x1000, sector size=1024; 0x10000-0x20000, size=2048>
S     *
S     *  @param addr Address of or inside the sector to query
S     *  @return Size of a sector in bytes or MBED_FLASH_INVALID_SIZE if not mapped
S     */
S    uint32_t get_sector_size(uint32_t addr) const;
S
S    /** Get the flash start address 
S     *
S     *  @return Flash start address 
S     */
S    uint32_t get_flash_start() const;
S
S    /** Get the flash size
S     *
S     *  @return Flash size 
S     */
S    uint32_t get_flash_size() const;
S
S    /** Get the program page size
S     *
S     *  @return Size of a program page in bytes
S     */
S    uint32_t get_page_size() const;
S
Sprivate:
S
S    /** Check if address and size are aligned to a sector
S     *
S     *  @param addr Address of block to check for alignment
S     *  @param size Size of block to check for alignment
S     *  @return true if the block is sector aligned, false otherwise
S     */
S    bool is_aligned_to_sector(uint32_t addr, uint32_t size);
S
S    flash_t _flash;
S    static SingletonPtr<PlatformMutex> _mutex;
S};
S
S} /* namespace mbed */
S
N#endif  /* DEVICE_FLASH */
N
N#endif  /* MBED_FLASHIAP_H */
N
N/** @}*/
L 89 "mbed/./mbed.h" 2
N
N// mbed Internal components
N#include "drivers/Timer.h"
L 1 "mbed/./drivers/Timer.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_TIMER_H
N#define MBED_TIMER_H
N
N#include "platform/platform.h"
N#include "hal/ticker_api.h"
L 1 "mbed/./hal/ticker_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_TICKER_API_H
N#define MBED_TICKER_API_H
N
N#include <stdint.h>
N#include "device.h"
N
Ntypedef uint32_t timestamp_t;
N
N/** Ticker's event structure
N */
Ntypedef struct ticker_event_s {
N    timestamp_t            timestamp; /**< Event's timestamp */
N    uint32_t               id;        /**< TimerEvent object */
N    struct ticker_event_s *next;      /**< Next event in the queue */
N} ticker_event_t;
N
Ntypedef void (*ticker_event_handler)(uint32_t id);
N
N/** Ticker's interface structure - required API for a ticker
N */
Ntypedef struct {
N    void (*init)(void);                           /**< Init function */
N    uint32_t (*read)(void);                       /**< Read function */
N    void (*disable_interrupt)(void);              /**< Disable interrupt function */
N    void (*clear_interrupt)(void);                /**< Clear interrupt function */
N    void (*set_interrupt)(timestamp_t timestamp); /**< Set interrupt function */
N} ticker_interface_t;
N
N/** Ticker's event queue structure
N */
Ntypedef struct {
N    ticker_event_handler event_handler; /**< Event handler */
N    ticker_event_t *head;               /**< A pointer to head */
N} ticker_event_queue_t;
N
N/** Ticker's data structure
N */
Ntypedef struct {
N    const ticker_interface_t *interface; /**< Ticker's interface */
N    ticker_event_queue_t *queue;         /**< Ticker's event queue */
N} ticker_data_t;
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/**
N * \defgroup hal_ticker Ticker HAL functions
N * @{
N */
N
N/** Initialize a ticker and set the event handler
N *
N * @param data    The ticker's data
N * @param handler A handler to be set
N */
Nvoid ticker_set_handler(const ticker_data_t *const data, ticker_event_handler handler);
N
N/** IRQ handler that goes through the events to trigger overdue events.
N *
N * @param data    The ticker's data
N */
Nvoid ticker_irq_handler(const ticker_data_t *const data);
N
N/** Remove an event from the queue
N *
N * @param data The ticker's data
N * @param obj  The event object to be removed from the queue
N */
Nvoid ticker_remove_event(const ticker_data_t *const data, ticker_event_t *obj);
N
N/** Insert an event to the queue
N *
N * @param data      The ticker's data
N * @param obj       The event object to be inserted to the queue
N * @param timestamp The event's timestamp
N * @param id        The event object
N */
Nvoid ticker_insert_event(const ticker_data_t *const data, ticker_event_t *obj, timestamp_t timestamp, uint32_t id);
N
N/** Read the current ticker's timestamp
N *
N * @param data The ticker's data
N * @return The current timestamp
N */
Ntimestamp_t ticker_read(const ticker_data_t *const data);
N
N/** Read the next event's timestamp
N *
N * @param data The ticker's data
N * @return 1 if timestamp is pending event, 0 if there's no event pending
N */
Nint ticker_get_next_timestamp(const ticker_data_t *const data, timestamp_t *timestamp);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 21 "mbed/./drivers/Timer.h" 2
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A general purpose timer
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example:
N * @code
N * // Count the time to toggle a LED
N *
N * #include "mbed.h"
N *
N * Timer timer;
N * DigitalOut led(LED1);
N * int begin, end;
N *
N * int main() {
N *     timer.start();
N *     begin = timer.read_us();
N *     led = !led;
N *     end = timer.read_us();
N *     printf("Toggle the led takes %d us", end - begin);
N * }
N * @endcode
N */
Nclass Timer {
N
Npublic:
N    Timer();
N    Timer(const ticker_data_t *data);
N
N    /** Start the timer
N     */
N    void start();
N
N    /** Stop the timer
N     */
N    void stop();
N
N    /** Reset the timer to 0.
N     *
N     * If it was already counting, it will continue
N     */
N    void reset();
N
N    /** Get the time passed in seconds
N     */
N    float read();
N
N    /** Get the time passed in mili-seconds
N     */
N    int read_ms();
N
N    /** Get the time passed in micro-seconds
N     */
N    int read_us();
N
N    /** An operator shorthand for read()
N     */
N    operator float();
N
Nprotected:
N    int slicetime();
N    int _running;          // whether the timer is running
N    unsigned int _start;   // the start time of the latest slice
N    int _time;             // any accumulated time from previous slices
N    const ticker_data_t *_ticker_data;
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 92 "mbed/./mbed.h" 2
N#include "drivers/Ticker.h"
L 1 "mbed/./drivers/Ticker.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_TICKER_H
N#define MBED_TICKER_H
N
N#include "drivers/TimerEvent.h"
L 1 "mbed/./drivers/TimerEvent.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_TIMEREVENT_H
N#define MBED_TIMEREVENT_H
N
N#include "hal/ticker_api.h"
N#include "hal/us_ticker_api.h"
L 1 "mbed/./hal/us_ticker_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_US_TICKER_API_H
N#define MBED_US_TICKER_API_H
N
N#include <stdint.h>
N#include "hal/ticker_api.h"
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/**
N * \defgroup hal_UsTicker Microseconds Ticker Functions
N * @{
N */
N
N/** Get ticker's data
N *
N * @return The low power ticker data
N */
Nconst ticker_data_t* get_us_ticker_data(void);
N
N
N/** The wrapper for ticker_irq_handler, to pass us ticker's data
N *
N */
Nvoid us_ticker_irq_handler(void);
N
N/* HAL us ticker */
N
N/** Initialize the ticker
N *
N */
Nvoid us_ticker_init(void);
N
N/** Read the current counter
N *
N * @return The current timer's counter value in microseconds
N */
Nuint32_t us_ticker_read(void);
N
N/** Set interrupt for specified timestamp
N *
N * @param timestamp The time in microseconds to be set
N */
Nvoid us_ticker_set_interrupt(timestamp_t timestamp);
N
N/** Disable us ticker interrupt
N *
N */
Nvoid us_ticker_disable_interrupt(void);
N
N/** Clear us ticker interrupt
N *
N */
Nvoid us_ticker_clear_interrupt(void);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 21 "mbed/./drivers/TimerEvent.h" 2
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** Base abstraction for timer interrupts
N *
N * @Note Synchronization level: Interrupt safe
N */
Nclass TimerEvent {
Npublic:
N    TimerEvent();
N    TimerEvent(const ticker_data_t *data);
N
N    /** The handler registered with the underlying timer interrupt
N     */
N    static void irq(uint32_t id);
N
N    /** Destruction removes it...
N     */
N    virtual ~TimerEvent();
N
Nprotected:
N    // The handler called to service the timer event of the derived class
N    virtual void handler() = 0;
N
N    // insert in to linked list
N    void insert(timestamp_t timestamp);
N
N    // remove from linked list, if in it
N    void remove();
N
N    ticker_event_t event;
N
N    const ticker_data_t *_ticker_data;
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 20 "mbed/./drivers/Ticker.h" 2
N#include "platform/Callback.h"
N#include "platform/mbed_toolchain.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A Ticker is used to call a function at a recurring interval
N *
N *  You can use as many seperate Ticker objects as you require.
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example:
N * @code
N * // Toggle the blinking led after 5 seconds
N *
N * #include "mbed.h"
N *
N * Ticker timer;
N * DigitalOut led1(LED1);
N * DigitalOut led2(LED2);
N *
N * int flip = 0;
N *
N * void attime() {
N *     flip = !flip;
N * }
N *
N * int main() {
N *     timer.attach(&attime, 5);
N *     while(1) {
N *         if(flip == 0) {
N *             led1 = !led1;
N *         } else {
N *             led2 = !led2;
N *         }
N *         wait(0.2);
N *     }
N * }
N * @endcode
N */
Nclass Ticker : public TimerEvent {
N
Npublic:
N    Ticker() : TimerEvent() {
N    }
N
N    Ticker(const ticker_data_t *data) : TimerEvent(data) {
N        data->interface->init();
N    }
N
N    /** Attach a function to be called by the Ticker, specifiying the interval in seconds
N     *
N     *  @param func pointer to the function to be called
N     *  @param t the time between calls in seconds
N     */
N    void attach(Callback<void()> func, float t) {
N        attach_us(func, t * 1000000.0f);
N    }
N
N    /** Attach a member function to be called by the Ticker, specifiying the interval in seconds
N     *
N     *  @param obj pointer to the object to call the member function on
N     *  @param method pointer to the member function to be called
N     *  @param t the time between calls in seconds
N     *  @deprecated
N     *      The attach function does not support cv-qualifiers. Replaced by
N     *      attach(callback(obj, method), t).
N     */
N    template<typename T, typename M>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "The attach function does not support cv-qualifiers. Replaced by "
N        "attach(callback(obj, method), t).")
X    __attribute__((deprecated))
N    void attach(T *obj, M method, float t) {
N        attach(callback(obj, method), t);
N    }
N
N    /** Attach a function to be called by the Ticker, specifiying the interval in micro-seconds
N     *
N     *  @param fptr pointer to the function to be called
N     *  @param t the time between calls in micro-seconds
N     */
N    void attach_us(Callback<void()> func, timestamp_t t) {
N        _function = func;
N        setup(t);
N    }
N
N    /** Attach a member function to be called by the Ticker, specifiying the interval in micro-seconds
N     *
N     *  @param tptr pointer to the object to call the member function on
N     *  @param mptr pointer to the member function to be called
N     *  @param t the time between calls in micro-seconds
N     *  @deprecated
N     *      The attach_us function does not support cv-qualifiers. Replaced by
N     *      attach_us(callback(obj, method), t).
N     */
N    template<typename T, typename M>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "The attach_us function does not support cv-qualifiers. Replaced by "
N        "attach_us(callback(obj, method), t).")
X    __attribute__((deprecated))
N    void attach_us(T *obj, M method, timestamp_t t) {
N        attach_us(Callback<void()>(obj, method), t);
N    }
N
N    virtual ~Ticker() {
N        detach();
N    }
N
N    /** Detach the function
N     */
N    void detach();
N
Nprotected:
N    void setup(timestamp_t t);
N    virtual void handler();
N
Nprotected:
N    timestamp_t         _delay;     /**< Time delay (in microseconds) for re-setting the multi-shot callback. */
N    Callback<void()>    _function;  /**< Callback. */
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 93 "mbed/./mbed.h" 2
N#include "drivers/Timeout.h"
L 1 "mbed/./drivers/Timeout.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_TIMEOUT_H
N#define MBED_TIMEOUT_H
N
N#include "drivers/Ticker.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A Timeout is used to call a function at a point in the future
N *
N * You can use as many seperate Timeout objects as you require.
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example:
N * @code
N * // Blink until timeout.
N *
N * #include "mbed.h"
N *
N * Timeout timeout;
N * DigitalOut led(LED1);
N *
N * int on = 1;
N *
N * void attimeout() {
N *     on = 0;
N * }
N *
N * int main() {
N *     timeout.attach(&attimeout, 5);
N *     while(on) {
N *         led = !led;
N *         wait(0.2);
N *     }
N * }
N * @endcode
N */
Nclass Timeout : public Ticker {
N
Nprotected:
N    virtual void handler();
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 94 "mbed/./mbed.h" 2
N#include "drivers/LowPowerTimeout.h"
L 1 "mbed/./drivers/LowPowerTimeout.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_LOWPOWERTIMEOUT_H
N#define MBED_LOWPOWERTIMEOUT_H
N
N#include "platform/platform.h"
N
N#if DEVICE_LOWPOWERTIMER
S
S#include "hal/lp_ticker_api.h"
S#include "drivers/LowPowerTicker.h"
S
Snamespace mbed {
S/** \addtogroup drivers */
S/** @{*/
S
S/** Low Power Timout
S *
S * @Note Synchronization level: Interrupt safe
S */
Sclass LowPowerTimeout : public LowPowerTicker {
S
Sprivate:
S    virtual void handler(void) {
S        _function.call();
S    }
S};
S
S}
S
N#endif
N
N#endif
N
N/** @}*/
L 95 "mbed/./mbed.h" 2
N#include "drivers/LowPowerTicker.h"
L 1 "mbed/./drivers/LowPowerTicker.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_LOWPOWERTICKER_H
N#define MBED_LOWPOWERTICKER_H
N
N#include "platform/platform.h"
N#include "drivers/Ticker.h"
N
N#if DEVICE_LOWPOWERTIMER
S
S#include "hal/lp_ticker_api.h"
S
Snamespace mbed {
S/** \addtogroup drivers */
S/** @{*/
S
S/** Low Power Ticker
S *
S * @Note Synchronization level: Interrupt safe
S */
Sclass LowPowerTicker : public Ticker {
S
Spublic:
S    LowPowerTicker() : Ticker(get_lp_ticker_data()) {
S    }
S
S    virtual ~LowPowerTicker() {
S    }
S};
S
S} // namespace mbed
S
N#endif
N
N#endif
N
N/** @}*/
L 96 "mbed/./mbed.h" 2
N#include "drivers/LowPowerTimer.h"
L 1 "mbed/./drivers/LowPowerTimer.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_LOWPOWERTIMER_H
N#define MBED_LOWPOWERTIMER_H
N
N#include "platform/platform.h"
N#include "drivers/Timer.h"
N
N#if DEVICE_LOWPOWERTIMER
S
S#include "hal/lp_ticker_api.h"
S
Snamespace mbed {
S/** \addtogroup drivers */
S/** @{*/
S
S/** Low power timer
S *
S * @Note Synchronization level: Interrupt safe
S */
Sclass LowPowerTimer : public Timer {
S
Spublic:
S    LowPowerTimer() : Timer(get_lp_ticker_data()) {
S    }
S
S};
S
S} // namespace mbed
S
N#endif
N
N#endif
N
N/** @}*/
L 97 "mbed/./mbed.h" 2
N#include "drivers/LocalFileSystem.h"
L 1 "mbed/./drivers/LocalFileSystem.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_LOCALFILESYSTEM_H
N#define MBED_LOCALFILESYSTEM_H
N
N#include "platform/platform.h"
N
N#if DEVICE_LOCALFILESYSTEM
X#if 1
N
N#include "drivers/FileSystemLike.h"
L 1 "mbed/./drivers/FileSystemLike.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_FILESYSTEMLIKE_H
N#define MBED_FILESYSTEMLIKE_H
N
N#include "platform/platform.h"
N
N#include "drivers/FileBase.h"
N#include "drivers/FileHandle.h"
N#include "drivers/DirHandle.h"
L 1 "mbed/./drivers/DirHandle.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_DIRHANDLE_H
N#define MBED_DIRHANDLE_H
N
N#include <stdint.h>
N#include "platform/platform.h"
N
N#include "FileHandle.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** Represents a directory stream. Objects of this type are returned
N *  by a FileSystemLike's opendir method. Implementations must define
N *  at least closedir, readdir and rewinddir.
N *
N *  If a FileSystemLike class defines the opendir method, then the
N *  directories of an object of that type can be accessed by
N *  DIR *d = opendir("/example/directory") (or opendir("/example")
N *  to open the root of the filesystem), and then using readdir(d) etc.
N *
N *  The root directory is considered to contain all FileLike and
N *  FileSystemLike objects, so the DIR* returned by opendir("/") will
N *  reflect this.
N *
N *  @Note Synchronization level: Set by subclass
N */
Nclass DirHandle {
Npublic:
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "The mbed 2 filesystem classes have been superseeded by the FileSystem api, "
N        "Replaced by File")
X    __attribute__((deprecated))
N    DirHandle() {}
N
N    /** Closes the directory.
N     *
N     *  @returns
N     *    0 on success,
N     *   -1 on error.
N     */
N    virtual int closedir()=0;
N
N    /** Return the directory entry at the current position, and
N     *  advances the position to the next entry.
N     *
N     * @returns
N     *  A pointer to a dirent structure representing the
N     *  directory entry at the current position, or NULL on reaching
N     *  end of directory or error.
N     */
N    virtual struct dirent *readdir()=0;
N
N    /** Resets the position to the beginning of the directory.
N     */
N    virtual void rewinddir()=0;
N
N    /** Returns the current position of the DirHandle.
N     *
N     * @returns
N     *   the current position,
N     *  -1 on error.
N     */
N    virtual off_t telldir() { return -1; }
N
N    /** Sets the position of the DirHandle.
N     *
N     *  @param location The location to seek to. Must be a value returned by telldir.
N     */
N    virtual void seekdir(off_t location) { (void)location;}
N
N    virtual ~DirHandle() {}
N
Nprotected:
N
N    /** Acquire exclusive access to this object.
N     */
N    virtual void lock() {
N        // Stub
N    }
N
N    /** Release exclusive access to this object.
N     */
N    virtual void unlock() {
N        // Stub
N    }
N
Nprotected:
N    /** Internal-only constructor to work around deprecated notices when not used
N     *. due to nested deprecations and difficulty of compilers finding their way around
N     *  the class hierarchy
N     */
N    friend class FileSystemLike;
N    DirHandle(int) {}
N};
N
N} // namespace mbed
N
N#endif /* MBED_DIRHANDLE_H */
N
N/** @}*/
L 24 "mbed/./drivers/FileSystemLike.h" 2
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A filesystem-like object is one that can be used to open files
N *  though it by fopen("/name/filename", mode)
N *
N *  Implementations must define at least open (the default definitions
N *  of the rest of the functions just return error values).
N *
N * @Note Synchronization level: Set by subclass
N */
Nclass FileSystemLike : public FileBase {
N
Npublic:
N    /** FileSystemLike constructor
N     *
N     *  @param name The name to use for the filesystem.
N     */
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "The mbed 2 filesystem classes have been superseeded by the FileSystem api, "
N        "Replaced by FileSystem")
X    __attribute__((deprecated))
N    FileSystemLike(const char *name);
N
N    virtual ~FileSystemLike();
N
N    MBED_DEPRECATED_SINCE("mbed-os-5.4",
N        "The mbed 2 filesystem classes have been superseeded by the FileSystem api, "
N        "Replaced by FileSystem")
X    __attribute__((deprecated))
N    static DirHandle *opendir();
N    friend class BaseDirHandle;
N
N    /** Opens a file from the filesystem
N     *
N     *  @param filename The name of the file to open.
N     *  @param flags One of O_RDONLY, O_WRONLY, or O_RDWR, OR'd with
N     *    zero or more of O_CREAT, O_TRUNC, or O_APPEND.
N     *
N     *  @returns
N     *    A pointer to a FileHandle object representing the
N     *   file on success, or NULL on failure.
N     */
N    virtual FileHandle *open(const char *filename, int flags) = 0;
N
N    /** Remove a file from the filesystem.
N     *
N     *  @param filename the name of the file to remove.
N     *  @param returns 0 on success, -1 on failure.
N     */
N    virtual int remove(const char *filename) { (void) filename; return -1; };
N
N    /** Rename a file in the filesystem.
N     *
N     *  @param oldname the name of the file to rename.
N     *  @param newname the name to rename it to.
N     *
N     *  @returns
N     *    0 on success,
N     *   -1 on failure.
N     */
N    virtual int rename(const char *oldname, const char *newname) { (void) oldname, (void) newname; return -1; };
N
N    /** Opens a directory in the filesystem and returns a DirHandle
N     *   representing the directory stream.
N     *
N     *  @param name The name of the directory to open.
N     *
N     *  @returns
N     *    A DirHandle representing the directory stream, or
N     *   NULL on failure.
N     */
N    virtual DirHandle *opendir(const char *name) { (void) name; return NULL; };
X    virtual DirHandle *opendir(const char *name) { (void) name; return 0; };
N
N    /** Creates a directory in the filesystem.
N     *
N     *  @param name The name of the directory to create.
N     *  @param mode The permissions to create the directory with.
N     *
N     *  @returns
N     *    0 on success,
N     *   -1 on failure.
N     */
N    virtual int mkdir(const char *name, mode_t mode) { (void) name, (void) mode; return -1; }
N
N    /** Store information about file in stat structure
N     *
N     *  @param name The name of the file to find information about
N     *  @param st The stat buffer to write to
N     *  @returns
N     *    0 on success or un-needed,
N     *   -1 on error
N     */
N    virtual int stat(const char *name, struct stat *st) { return -1; };
N};
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 24 "mbed/./drivers/LocalFileSystem.h" 2
N#include "platform/PlatformMutex.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
NFILEHANDLE local_file_open(const char* name, int flags);
N
Nclass LocalFileHandle : public FileHandle {
N
Npublic:
N    LocalFileHandle(FILEHANDLE fh);
N
N    virtual int close();
N
N    virtual ssize_t write(const void *buffer, size_t length);
N
N    virtual ssize_t read(void *buffer, size_t length);
N
N    virtual int isatty();
N
N    virtual off_t lseek(off_t position, int whence);
N
N    virtual int fsync();
N
N    virtual off_t flen();
N
Nprotected:
N    virtual void lock();
N    virtual void unlock();
N    FILEHANDLE _fh;
N    int pos;
N    PlatformMutex _mutex;
N};
N
N/** A filesystem for accessing the local mbed Microcontroller USB disk drive
N *
N *  This allows programs to read and write files on the same disk drive that is used to program the
N *  mbed Microcontroller. Once created, the standard C file access functions are used to open,
N *  read and write files.
N *
N * @Note Synchronization level: Thread safe
N *
N * Example:
N * @code
N * #include "mbed.h"
N *
N * LocalFileSystem local("local");               // Create the local filesystem under the name "local"
N *
N * int main() {
N *     FILE *fp = fopen("/local/out.txt", "w");  // Open "out.txt" on the local file system for writing
N *     fprintf(fp, "Hello World!");
N *     fclose(fp);
N *     remove("/local/out.txt");                 // Removes the file "out.txt" from the local file system
N *
N *     DIR *d = opendir("/local");               // Opens the root directory of the local file system
N *     struct dirent *p;
N *     while((p = readdir(d)) != NULL) {         // Print the names of the files in the local file system
N *       printf("%s\n", p->d_name);              // to stdout.
N *     }
N *     closedir(d);
N * }
N * @endcode
N *
N * @note
N *  If the microcontroller program makes an access to the local drive, it will be marked as "removed"
N *  on the Host computer. This means it is no longer accessible from the Host Computer.
N *
N *  The drive will only re-appear when the microcontroller program exists. Note that if the program does
N *  not exit, you will need to hold down reset on the mbed Microcontroller to be able to see the drive again!
N */
Nclass LocalFileSystem : public FileSystemLike {
N    // No modifiable state
N
Npublic:
N    LocalFileSystem(const char* n) : FileSystemLike(n) {
N
N    }
N
N    virtual FileHandle *open(const char* name, int flags);
N    virtual int remove(const char *filename);
N    virtual DirHandle *opendir(const char *name);
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 98 "mbed/./mbed.h" 2
N#include "drivers/InterruptIn.h"
L 1 "mbed/./drivers/InterruptIn.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_INTERRUPTIN_H
N#define MBED_INTERRUPTIN_H
N
N#include "platform/platform.h"
N
N#if DEVICE_INTERRUPTIN
X#if 1
N
N#include "hal/gpio_api.h"
N#include "hal/gpio_irq_api.h"
L 1 "mbed/./hal/gpio_irq_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_GPIO_IRQ_API_H
N#define MBED_GPIO_IRQ_API_H
N
N#include "device.h"
N
N#if DEVICE_INTERRUPTIN
X#if 1
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** GPIO IRQ events
N */
Ntypedef enum {
N    IRQ_NONE,
N    IRQ_RISE,
N    IRQ_FALL
N} gpio_irq_event;
N
N/** GPIO IRQ HAL structure. gpio_irq_s is declared in the target's HAL
N */
Ntypedef struct gpio_irq_s gpio_irq_t;
N
Ntypedef void (*gpio_irq_handler)(uint32_t id, gpio_irq_event event);
N
N/**
N * \defgroup hal_gpioirq GPIO IRQ HAL functions
N * @{
N */
N
N/** Initialize the GPIO IRQ pin
N *
N * @param obj     The GPIO object to initialize
N * @param pin     The GPIO pin name
N * @param handler The handler to be attached to GPIO IRQ
N * @param id      The object ID (id != 0, 0 is reserved)
N * @return -1 if pin is NC, 0 otherwise
N */
Nint gpio_irq_init(gpio_irq_t *obj, PinName pin, gpio_irq_handler handler, uint32_t id);
N
N/** Release the GPIO IRQ PIN
N *
N * @param obj The gpio object
N */
Nvoid gpio_irq_free(gpio_irq_t *obj);
N
N/** Enable/disable pin IRQ event
N *
N * @param obj    The GPIO object
N * @param event  The GPIO IRQ event
N * @param enable The enable flag
N */
Nvoid gpio_irq_set(gpio_irq_t *obj, gpio_irq_event event, uint32_t enable);
N
N/** Enable GPIO IRQ
N *
N * This is target dependent, as it might enable the entire port or just a pin
N * @param obj The GPIO object
N */
Nvoid gpio_irq_enable(gpio_irq_t *obj);
N
N/** Disable GPIO IRQ
N *
N * This is target dependent, as it might disable the entire port or just a pin
N * @param obj The GPIO object
N */
Nvoid gpio_irq_disable(gpio_irq_t *obj);
N
N/**@}*/
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N#endif
N
N/** @}*/
L 25 "mbed/./drivers/InterruptIn.h" 2
N#include "platform/Callback.h"
N#include "platform/mbed_critical.h"
N#include "platform/mbed_toolchain.h"
N
Nnamespace mbed {
N/** \addtogroup drivers */
N/** @{*/
N
N/** A digital interrupt input, used to call a function on a rising or falling edge
N *
N * @Note Synchronization level: Interrupt safe
N *
N * Example:
N * @code
N * // Flash an LED while waiting for events
N *
N * #include "mbed.h"
N *
N * InterruptIn event(p16);
N * DigitalOut led(LED1);
N *
N * void trigger() {
N *     printf("triggered!\n");
N * }
N *
N * int main() {
N *     event.rise(&trigger);
N *     while(1) {
N *         led = !led;
N *         wait(0.25);
N *     }
N * }
N * @endcode
N */
Nclass InterruptIn {
N
Npublic:
N
N    /** Create an InterruptIn connected to the specified pin
N     *
N     *  @param pin InterruptIn pin to connect to
N     *  @param name (optional) A string to identify the object
N     */
N    InterruptIn(PinName pin);
N    virtual ~InterruptIn();
N
N    /** Read the input, represented as 0 or 1 (int)
N     *
N     *  @returns
N     *    An integer representing the state of the input pin,
N     *    0 for logical 0, 1 for logical 1
N     */
N    int read();
N
N    /** An operator shorthand for read()
N     */
N    operator int();
N
N
N    /** Attach a function to call when a rising edge occurs on the input
N     *
N     *  @param func A pointer to a void function, or 0 to set as none
N     */
N    void rise(Callback<void()> func);
N
N    /** Attach a member function to call when a rising edge occurs on the input
N     *
N     *  @param obj pointer to the object to call the member function on
N     *  @param method pointer to the member function to be called
N     *  @deprecated
N     *      The rise function does not support cv-qualifiers. Replaced by
N     *      rise(callback(obj, method)).
N     */
N    template<typename T, typename M>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "The rise function does not support cv-qualifiers. Replaced by "
N        "rise(callback(obj, method)).")
X    __attribute__((deprecated))
N    void rise(T *obj, M method) {
N        core_util_critical_section_enter();
N        rise(callback(obj, method));
N        core_util_critical_section_exit();
N    }
N
N    /** Attach a function to call when a falling edge occurs on the input
N     *
N     *  @param func A pointer to a void function, or 0 to set as none
N     */
N    void fall(Callback<void()> func);
N
N    /** Attach a member function to call when a falling edge occurs on the input
N     *
N     *  @param obj pointer to the object to call the member function on
N     *  @param method pointer to the member function to be called
N     *  @deprecated
N     *      The rise function does not support cv-qualifiers. Replaced by
N     *      rise(callback(obj, method)).
N     */
N    template<typename T, typename M>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "The fall function does not support cv-qualifiers. Replaced by "
N        "fall(callback(obj, method)).")
X    __attribute__((deprecated))
N    void fall(T *obj, M method) {
N        core_util_critical_section_enter();
N        fall(callback(obj, method));
N        core_util_critical_section_exit();
N    }
N
N    /** Set the input pin mode
N     *
N     *  @param mode PullUp, PullDown, PullNone
N     */
N    void mode(PinMode pull);
N
N    /** Enable IRQ. This method depends on hw implementation, might enable one
N     *  port interrupts. For further information, check gpio_irq_enable().
N     */
N    void enable_irq();
N
N    /** Disable IRQ. This method depends on hw implementation, might disable one
N     *  port interrupts. For further information, check gpio_irq_disable().
N     */
N    void disable_irq();
N
N    static void _irq_handler(uint32_t id, gpio_irq_event event);
N
Nprotected:
N    gpio_t gpio;
N    gpio_irq_t gpio_irq;
N
N    Callback<void()> _rise;
N    Callback<void()> _fall;
N};
N
N} // namespace mbed
N
N#endif
N
N#endif
N
N/** @}*/
L 99 "mbed/./mbed.h" 2
N#include "platform/mbed_wait_api.h"
L 1 "mbed/./platform/mbed_wait_api.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_WAIT_API_H
N#define MBED_WAIT_API_H
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Generic wait functions.
N *
N * These provide simple NOP type wait capabilities.
N *
N * Example:
N * @code
N * #include "mbed.h"
N *
N * DigitalOut heartbeat(LED1);
N *
N * int main() {
N *     while (1) {
N *         heartbeat = 1;
N *         wait(0.5);
N *         heartbeat = 0;
N *         wait(0.5);
N *     }
N * }
N */
N
N/** Waits for a number of seconds, with microsecond resolution (within
N *  the accuracy of single precision floating point).
N *
N *  @param s number of seconds to wait
N */
Nvoid wait(float s);
N
N/** Waits a number of milliseconds.
N *
N *  @param ms the whole number of milliseconds to wait
N */
Nvoid wait_ms(int ms);
N
N/** Waits a number of microseconds.
N *
N *  @param us the whole number of microseconds to wait
N */
Nvoid wait_us(int us);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 100 "mbed/./mbed.h" 2
N#include "hal/sleep_api.h"
L 1 "mbed/./hal/sleep_api.h" 1
N
N/** \addtogroup hal */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SLEEP_API_H
N#define MBED_SLEEP_API_H
N
N#include "device.h"
N
N#if DEVICE_SLEEP
X#if 1
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Send the microcontroller to sleep
N *
N * The processor is setup ready for sleep, and sent to sleep using __WFI(). In this mode, the
N * system clock to the core is stopped until a reset or an interrupt occurs. This eliminates
N * dynamic power used by the processor, memory systems and buses. The processor, peripheral and
N * memory state are maintained, and the peripherals continue to work and can generate interrupts.
N *
N * The processor can be woken up by any internal peripheral interrupt or external pin interrupt.
N *
N * @note
N *  The mbed interface semihosting is disconnected as part of going to sleep, and can not be restored.
N * Flash re-programming and the USB serial port will remain active, but the mbed program will no longer be
N * able to access the LocalFileSystem
N */
Nvoid hal_sleep(void);
N
N/** Send the microcontroller to deep sleep
N *
N * This processor is setup ready for deep sleep, and sent to sleep using __WFI(). This mode
N * has the same sleep features as sleep plus it powers down peripherals and clocks. All state
N * is still maintained.
N *
N * The processor can only be woken up by an external interrupt on a pin or a watchdog timer.
N *
N * @note
N *  The mbed interface semihosting is disconnected as part of going to sleep, and can not be restored.
N * Flash re-programming and the USB serial port will remain active, but the mbed program will no longer be
N * able to access the LocalFileSystem
N */
Nvoid hal_deepsleep(void);
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N#endif
N
N/** @}*/
L 101 "mbed/./mbed.h" 2
N#include "platform/mbed_sleep.h"
L 1 "mbed/./platform/mbed_sleep.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2017 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_SLEEP_H
N#define MBED_SLEEP_H
N
N#include "sleep_api.h"
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Send the microcontroller to sleep
N *
N * @note This function can be a noop if not implemented by the platform.
N * @note This function will only put device to sleep in release mode (small profile or when NDEBUG is defined).
N *
N * The processor is setup ready for sleep, and sent to sleep using __WFI(). In this mode, the
N * system clock to the core is stopped until a reset or an interrupt occurs. This eliminates
N * dynamic power used by the processor, memory systems and buses. The processor, peripheral and
N * memory state are maintained, and the peripherals continue to work and can generate interrupts.
N *
N * The processor can be woken up by any internal peripheral interrupt or external pin interrupt.
N *
N * @note
N *  The mbed interface semihosting is disconnected as part of going to sleep, and can not be restored.
N * Flash re-programming and the USB serial port will remain active, but the mbed program will no longer be
N * able to access the LocalFileSystem
N */
N__INLINE static void sleep(void)
X__inline static void sleep(void)
N{
N#ifdef NDEBUG
S#if DEVICE_SLEEP
S    hal_sleep();
S#endif /* DEVICE_SLEEP */
N#endif /* NDEBUG */
N}
N
N/** Send the microcontroller to deep sleep
N *
N * @note This function can be a noop if not implemented by the platform.
N * @note This function will only put device to sleep in release mode (small profile or when NDEBUG is defined).
N *
N * This processor is setup ready for deep sleep, and sent to sleep using __WFI(). This mode
N * has the same sleep features as sleep plus it powers down peripherals and clocks. All state
N * is still maintained.
N *
N * The processor can only be woken up by an external interrupt on a pin or a watchdog timer.
N *
N * @note
N *  The mbed interface semihosting is disconnected as part of going to sleep, and can not be restored.
N * Flash re-programming and the USB serial port will remain active, but the mbed program will no longer be
N * able to access the LocalFileSystem
N */
N__INLINE static void deepsleep(void)
X__inline static void deepsleep(void)
N{
N#ifdef NDEBUG
S#if DEVICE_SLEEP
S    hal_deepsleep();
S#endif /* DEVICE_SLEEP */
N#endif /* NDEBUG */
N}
N
N#ifdef __cplusplus
N}
N#endif
N
N#endif
N
N/** @}*/
L 102 "mbed/./mbed.h" 2
N#include "platform/mbed_rtc_time.h"
L 1 "mbed/./platform/mbed_rtc_time.h" 1
N
N/** \addtogroup platform */
N/** @{*/
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2013 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#include <time.h>
N
N#ifdef __cplusplus
Nextern "C" {
N#endif
N
N/** Implementation of the C time.h functions
N *
N * Provides mechanisms to set and read the current time, based
N * on the microcontroller Real-Time Clock (RTC), plus some
N * standard C manipulation and formating functions.
N *
N * Example:
N * @code
N * #include "mbed.h"
N *
N * int main() {
N *     set_time(1256729737);  // Set RTC time to Wed, 28 Oct 2009 11:35:37
N *
N *     while(1) {
N *         time_t seconds = time(NULL);
N *
N *         printf("Time as seconds since January 1, 1970 = %d\n", seconds);
N *
N *         printf("Time as a basic string = %s", ctime(&seconds));
N *
N *         char buffer[32];
N *         strftime(buffer, 32, "%I:%M %p\n", localtime(&seconds));
N *         printf("Time as a custom formatted string = %s", buffer);
N *
N *         wait(1);
N *     }
N * }
N * @endcode
N */
N
N/** Set the current time
N *
N * Initialises and sets the time of the microcontroller Real-Time Clock (RTC)
N * to the time represented by the number of seconds since January 1, 1970
N * (the UNIX timestamp).
N *
N * @param t Number of seconds since January 1, 1970 (the UNIX timestamp)
N *
N * @Note Synchronization level: Thread safe
N *
N * Example:
N * @code
N * #include "mbed.h"
N *
N * int main() {
N *     set_time(1256729737); // Set time to Wed, 28 Oct 2009 11:35:37
N * }
N * @endcode
N */
Nvoid set_time(time_t t);
N
N/** Attach an external RTC to be used for the C time functions
N *
N * @Note Synchronization level: Thread safe
N *
N * @param read_rtc pointer to function which returns current UNIX timestamp
N * @param write_rtc pointer to function which sets current UNIX timestamp, can be NULL
N * @param init_rtc pointer to funtion which initializes RTC, can be NULL
N * @param isenabled_rtc pointer to function wich returns if the rtc is enabled, can be NULL
N */
Nvoid attach_rtc(time_t (*read_rtc)(void), void (*write_rtc)(time_t), void (*init_rtc)(void), int (*isenabled_rtc)(void));
N
N#ifdef __cplusplus
N}
N#endif
N
N/** @}*/
L 103 "mbed/./mbed.h" 2
N
N// mbed Non-hardware components
N#include "platform/Callback.h"
N#include "platform/FunctionPointer.h"
L 1 "mbed/./platform/FunctionPointer.h" 1
N/* mbed Microcontroller Library
N * Copyright (c) 2006-2015 ARM Limited
N *
N * Licensed under the Apache License, Version 2.0 (the "License");
N * you may not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N *     http://www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an "AS IS" BASIS,
N * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N#ifndef MBED_FUNCTIONPOINTER_H
N#define MBED_FUNCTIONPOINTER_H
N
N#include "platform/Callback.h"
N#include "platform/mbed_toolchain.h"
N#include <string.h>
N#include <stdint.h>
N
Nnamespace mbed {
N/** \addtogroup platform */
N/** @{*/
N
N
N// Declarations for backwards compatibility
N// To be foward compatible, code should adopt the Callback class
Ntemplate <typename R, typename A1>
Nclass FunctionPointerArg1 : public Callback<R(A1)> {
Npublic:
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "FunctionPointerArg1<R, A> has been replaced by Callback<R(A)>")
X    __attribute__((deprecated))
N    FunctionPointerArg1(R (*function)(A1) = 0)
N        : Callback<R(A1)>(function) {}
N
N    template<typename T>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "FunctionPointerArg1<R, A> has been replaced by Callback<R(A)>")
X    __attribute__((deprecated))
N    FunctionPointerArg1(T *object, R (T::*member)(A1))
N        : Callback<R(A1)>(object, member) {}
N
N    R (*get_function())(A1) {
N        return *reinterpret_cast<R (**)(A1)>(this);
N    }
N
N    R call(A1 a1) const {
N        if (!Callback<R(A1)>::operator bool()) {
N            return (R)0;
N        }
N
N        return Callback<R(A1)>::call(a1);
N    }
N
N    R operator()(A1 a1) const {
N        return Callback<R(A1)>::call(a1);
N    }
N};
N
Ntemplate <typename R>
Nclass FunctionPointerArg1<R, void> : public Callback<R()> {
Npublic:
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "FunctionPointer has been replaced by Callback<void()>")
X    __attribute__((deprecated))
N    FunctionPointerArg1(R (*function)() = 0)
N        : Callback<R()>(function) {}
N
N    template<typename T>
N    MBED_DEPRECATED_SINCE("mbed-os-5.1",
N        "FunctionPointer has been replaced by Callback<void()>")
X    __attribute__((deprecated))
N    FunctionPointerArg1(T *object, R (T::*member)())
N        : Callback<R()>(object, member) {}
N
N    R (*get_function())() {
N        return *reinterpret_cast<R (**)()>(this);
N    }
N
N    R call() const {
N        if (!Callback<R()>::operator bool()) {
N            return (R)0;
N        }
N
N        return Callback<R()>::call();
N    }
N
N    R operator()() const {
N        return Callback<R()>::call();
N    }
N};
N
Ntypedef FunctionPointerArg1<void, void> FunctionPointer;
N
N
N} // namespace mbed
N
N#endif
N
N/** @}*/
L 107 "mbed/./mbed.h" 2
N
Nusing namespace mbed;
Nusing namespace std;
N
N#endif
L 2 "main.cpp" 2
N
N#include "MixerController.h"
L 1 "MixerController.h" 1
N#ifndef MIXER_CONTROLLER_H_INCLUDED
N#define MIXER_CONTROLLER_H_INCLUDED
N
N#include <bitset>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\bitset" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * <bitset> - definition of the bitset template
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_BITSET_INCLUDED
N#define _RWSTD_BITSET_INCLUDED
N
N
N#include <iosfwd>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\iosfwd" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * iosfwd - forward declarations for the iostreams
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_IOSFWD_INCLUDED
N#define _RWSTD_IOSFWD_INCLUDED
N
N#include <rw/_defs.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 1
N/***************************************************************************
N *
N * _defs.h - Common macro definitions to be included by every library file
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_DEFS_H_INCLUDED
N#define _RWSTD_DEFS_H_INCLUDED
N
N#include <rw/_config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 1
N/***************************************************************************
N *
N * _config.h - Compiler and C library configuration definitions
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2000 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_CONFIG_H_INCLUDED
N#define _RWSTD_CONFIG_H_INCLUDED
N
N// Always use the auto-generated config file for ARM Compilers
N#include <rw/config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/config.h" 1
N/* Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved. */
N/* Copyright (c) 2002 ARM Ltd. All Rights Reserved.                        */
N#ifndef __RW_CONFIG_H_INCLUDED
N#define __RW_CONFIG_H_INCLUDED
N
N#define _RWSTD_NO_NATIVE_IO // Rogue Wave global config options
N#define _RWSTD_NO_CONST_FLT_ROUNDS // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_EXCEPTIONS // auto config
N#else
N#endif
N#define _RWSTD_NO_FILENO // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_FUNCTION_TRY_BLOCK // auto config
N#endif
N#define _RWSTD_NO_IEEEFP_H_REQUIRED // auto config
N#define _RWSTD_LLONG_PRINTF_PREFIX "ll"
N#define _RWSTD_NO_LRAND48 // auto config
N#define _RWSTD_NO_MATH_EXCEPTION // auto config
N#define _RWSTD_NO_MBSTATE_COMPARE // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_NEW_THROWS // auto config
N#else
N#endif
N#define _RWSTD_NO_NL_TYPES_H // auto config
N#define _RWSTD_NO_SSIZE_T // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_UNCAUGHT_EXCEPTION // auto config
N#else
N#endif
N#define _RWSTD_WINT_T int
N
N#endif /* __RW_CONFIG_H_INCLUDED */
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 2
N
N// Library version number
N// 
N#define _RWSTD_VER 0x02020300
N//                    | | | |
N//                   AABBCCDD
N//                    | | | |
N//                    | | | +--- DD = Point release or "patch" release. 
N//                    | | |      Left D-digit is reserved for alpha releases
N//                    | | |      and right D-digit for beta releases
N//                    | | |      
N//                    | | +----- CC = Maintenance number
N//                    | +------- BB = Minor Release number
N//                    +--------- AA = Major Release number
N
N/*********************************************************************
N *                OVERRIDES FOR CONFIGURATION MACROS                 *
N *********************************************************************/
N
N/********************** ARM armcc **************************************/
N
N/* If implicit includes are switched off, include the file.cc explicitly */
N#ifndef __IMPLICIT_INCLUDE
S#  define _RWSTD_COMPILE_INSTANTIATE
N#endif /* __IMPLICIT_INCLUDE */
N#if __TARGET_ARCH_AARCH64
S#  define _RWSTD_NO_LONG_DOUBLE 1
N#endif /* __TARGET_ARCH_AARCH64 */
N
N/********************** EDG eccp *************************************/
N
N// NOTE: the __EDG__ macro is #defined by most edg-based compilers
N
N#if defined (__EDG__) && !defined (__DECCXX)
X#if 1L && !0L
N#  define _RWSTD_NO_DEPRECATED_C_HEADERS
N#  undef _RWSTD_NO_NEW_HEADER
N#  undef _RWSTD_NO_LIBC_IN_STD
N
N#  ifdef _RWSTD_MULTI_THREAD
S     // std::uncaught_exception() not thread-safe
S     // in the vanilla front-end (demo)
S#    define _RWSTD_NO_UNCAUGHT_EXCEPTION
N#  endif   // _RWSTD_MULTI_THREAD
N#endif   // __EDG__
N
N/********************** gcc ******************************************/
N
N/* armcc supports __attribute__ */
N#define _RWSTD_GNUC_ATTRIBUTE(attr)   __attribute__ (attr)
N
N/********************** Threads ***************************************/
N
N#ifdef _RWSTD_DCE_THREADS
S#  define _RWSTD_NO_STATIC_MUTEX_INIT
N#endif   // _RWSTD_DCE_THREADS
N
N/********************** Miscellaneous *********************************/
N
N// g++ cannot inline functions that take a variable number of arguments
N// or functions that contain static (local) variables
N#if !defined (__GNUG__) || __GNUG__ > 2 || __GNUG_MINOR__ > 96
X#if !1L || 4 > 2 || __GNUG_MINOR__ > 96
N#  define _INLINE_VARARGS      inline
N#  if !defined (__HP_aCC) || __HP_aCC > 012100
X#  if !0L || __HP_aCC > 012100
N     // working around a known aCC 1.21 bug
N#    define _INLINE_WITH_STATICS inline
N#  endif   // !__HP_aCC || __HP_aCC > 012100
N#endif   // !__GNUG__ || __GNUG__ > 2 || __GNUG_MINOR__ > 96
N
N#ifdef _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
S   // static mutex initialization depends on the compiler's (and the
S   // linker's in gcc's case) ability to correctly handle explicitly
S   // initialized static members of class templates
S#  ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S#    define _RWSTD_NO_STATIC_MUTEX_INIT
S#  endif
N#endif   // _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
N
N/********************** Environment *********************************/
N
N/*
N * Most (but not all) non-unix systems convert new line to carriage
N * return / line feed on output:
N */
N#if defined (__OS2__) || defined (_WIN32) || defined (_WIN64)
X#if 0L || 0L || 0L
S#  define _RWSTD_CRLF_CONVENTION
N#endif
N
N
N// define wherever atomic instructions are not provided
N// affects the size of string reference (i.e., is binary incompatible)
N#if    !defined (__DECCXX)                           \
N    && !(defined (__i386__) && defined (__GNUG__))   \
N    && !defined (_WIN32) && !defined (_WIN64)
X#if    !0L                               && !(0L && 1L)       && !0L && !0L
N#  ifndef _RWSTD_NO_TEST_AND_SET
N#    define _RWSTD_NO_TEST_AND_SET
N#  endif   // _RWSTD_NO_TEST_AND_SET
N#endif   // !_WIN32 && !(__i386__ && __GNUG__)
N
N
N#ifdef _RWSTD_NO_WCHAR_T
S#  ifndef _RWSTD_NO_NATIVE_WCHAR_T /* may be defined in config.h */
S#    define _RWSTD_NO_NATIVE_WCHAR_T 1
S#  endif
N#endif
N
N
N#ifndef _RWSTD_NO_STL_SPECIALIZATION
N// #ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC
N// disable partial specialization for void* of STL sequences
N#  define _RWSTD_NO_STL_SPECIALIZATION
N// #endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N#endif   // _RWSTD_NO_STL_SPECIALIZATION
N
N// 
N// Macro for path to the ANSI 'C' headers 
N// Must be set specifically for each platform when the
N// C++ wrappers for 'C' headers are used.
N//
N#define _RWSTD_ANSIC(x) </usr/include/x>
N
N// define unless already specified
N#ifndef _RWSTD_LDBL_PRINTF_PREFIX
N#  define _RWSTD_LDBL_PRINTF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_PRINTF_PREFIX
N
N#ifndef _RWSTD_LDBL_SCANF_PREFIX
N#  define _RWSTD_LDBL_SCANF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_SCANF_PREFIX
N
N
N/********************** Library Option Dependencies *************************/
N
N/*
N * The following macro sets the default size of file stream internal buffers
N */
N
N#ifndef _RWSTD_DEFAULT_BUFSIZE         // specified on command line?
N#  define _RWSTD_DEFAULT_BUFSIZE   512
N#endif
N
N#ifndef _RWSTD_NO_LONG_LONG
N   #if defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__) && !defined(__clang__)
X   #if 1L && !0L && !0L
N     /* strict armcc has '__int64' */
N     #define _RWSTD_LONG_LONG __int64
N   #endif
N   /* armclang and non-strict armcc allow 'long long' in system headers */
N   // Win32/64 #defines _RWSTD_LONG_LONG to __int64
N#  ifndef _RWSTD_LONG_LONG
S#    define _RWSTD_LONG_LONG long long
N#  endif   // _RWSTD_LONG_LONG
N#endif   // _RWSTD_NO_LONG_LONG
N
N
N// disable all extensions in strict ANSI mode
N#ifdef _RWSTD_STRICT_ANSI
S#  define _RWSTD_NO_EXT_FILEBUF
S#  define _RWSTD_NO_EXT_VECTOR_BOOL_REF_OPS
S#  define _RWSTD_NO_EXT_LOCALE
S#  define _RWSTD_NO_EXT_DEEP_STRING_COPY
S   // no support for exceptions derived from ios_base::failure
S#  define _RWSTD_NO_EXT_FAILURE
S   // no support for writing out integral values in base 2
S#  define _RWSTD_NO_EXT_BIN_IO
S   // no support for optional mt-locking in iostreams
S#  define _RWSTD_NO_EXT_REENTRANT_IO
S   // allocator<const T> not possible
S#  define _RWSTD_NO_EXT_CONST_ALLOCATOR
S   // no definitions provided for missing operator new or delete
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
S   // void std::count<>() not provided (except when necessary)
S#  define _RWSTD_NO_EXT_VOID_COUNT
S   // void std::distance<>()  not provided
S#  define _RWSTD_NO_EXT_VOID_DISTANCE
N#endif   // _RWSTD_STRICT_ANSI
N
N   // macros that are enabled in library source files
N#ifdef _RWSTD_LIB_SRC
S   // don't instantiate templates in library source code
S   //  (but see _RWSTD_INSTANTIATE_TEMPLATES macro below) 
S#  define _RWSTD_NO_TEMPLATE_DEFINITIONS
S   // don't provide definitions of operator new in library 
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _RWSTD_LIB_SRC
N
N#if _MSC_VER <= 1300
N   // msvc60 expects a definition to be provided for all variants
N   // of operator new/delete that are declared. This means that either
N   // the operators must be defined - preventing redefinition in user code -
N   // or that they must be undeclared - preventing them from being called
N   // directly in user code. We have chosen the former option.
N#  undef _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _MSC_VER
N
N#ifdef _RWSTD_INSTANTIATE_TEMPLATES
S   // instantiate templates (this macro appears in instance.cpp)
S#  undef _RWSTD_NO_TEMPLATE_DEFINITIONS
N#endif
N
N
N#endif   // _RWSTD_CONFIG_H_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 2
N
N
N// provide definitions for C++ versions of standard C headers
N// if a header is not available its name is #defined to the name of
N// this file (it's harmless and avoids polluting code with
N// tons of ugly platform-specific #ifdefs)
N#ifndef _RWSTD_NO_NEW_HEADER
N
N#  define _RWSTD_CASSERT   <cassert>
N#  define _RWSTD_CCTYPE    <cctype>
N#  define _RWSTD_CERRNO    <cerrno>
N#  define _RWSTD_CFLOAT    <cfloat>
N#  define _RWSTD_CISO646   <ciso646>
N#  define _RWSTD_CLIMITS   <climits>
N#  define _RWSTD_CLOCALE   <clocale>
N#  define _RWSTD_CMATH     <cmath>
N#  define _RWSTD_CSETJMP   <csetjmp>
N#  define _RWSTD_CSIGNAL   <csignal>
N#  define _RWSTD_CSTDARG   <cstdarg>
N#  define _RWSTD_CSTDDEF   <cstddef>
N#  define _RWSTD_CSTDIO    <cstdio>
N#  define _RWSTD_CSTDLIB   <cstdlib>
N#  define _RWSTD_CSTRING   <cstring>
N#  define _RWSTD_CTIME     <ctime>
N
N#  ifndef _RWSTD_NO_WCHAR_H
N#    define _RWSTD_CWCHAR  <cwchar>
N#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCHAR_H
N
N#  ifndef _RWSTD_NO_WCTYPE_H
N#    define _RWSTD_CWCTYPE <cwctype>
N#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCTYPE_H
N
N#else   // if defined (_RWSTD_NO_NEW_HEADER)
S
S#  define _RWSTD_CASSERT   <assert.h>
S#  define _RWSTD_CCTYPE    <ctype.h>
S#  define _RWSTD_CERRNO    <errno.h>
S#  define _RWSTD_CFLOAT    <float.h>
S#  define _RWSTD_CISO646   <iso646.h>
S#  define _RWSTD_CLIMITS   <limits.h>
S#  define _RWSTD_CLOCALE   <locale.h>
S#  define _RWSTD_CMATH     <math.h>
S#  define _RWSTD_CSETJMP   <setjmp.h>
S#  define _RWSTD_CSIGNAL   <signal.h>
S#  define _RWSTD_CSTDARG   <stdarg.h>
S#  define _RWSTD_CSTDDEF   <stddef.h>
S#  define _RWSTD_CSTDIO    <stdio.h>
S#  define _RWSTD_CSTDLIB   <stdlib.h>
S#  define _RWSTD_CSTRING   <string.h>
S#  define _RWSTD_CTIME     <time.h>
S
S#  ifndef _RWSTD_NO_WCHAR_H
S#    define _RWSTD_CWCHAR  <wchar.h>
S#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCHAR_H
S
S#  ifndef _RWSTD_NO_WCTYPE_H
S#    define _RWSTD_CWCTYPE <wctype.h>
S#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCTYPE_H
S
N#endif   // _RWSTD_NO_NEW_HEADER
N
N
N#if defined(_WIN64)
X#if 0L
S#  define _RWSTD_SYS_TYPES_H <basetsd.h>
S#elif defined(_WIN32)
X#elif 0L
S#  define _RWSTD_SYS_TYPES_H <rw/_defs.h>
N#else
N#  define _RWSTD_SYS_TYPES_H <sys/types.h>
N#endif   // _WIN32
N
N
N#ifdef _RWSTD_REQUIRES_IEEEFP
S// non-standard file required on Some platforms (e.g., Siemens) for <limits>
S#  define _RWSTD_IEEEFP <ieeefp.h>
N#else
N#  define _RWSTD_IEEEFP <rw/_defs.h>
N#endif
N
N
N// provide default #definitions of ANSI C library headers
N#if !defined (_RWSTD_NO_ASSERT_H) && !defined (_RWSTD_ANSI_C_ASSERT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ASSERT_H "/usr/include/assert.h"
N#endif
N#if !defined (_RWSTD_NO_CTYPE_H) && !defined (_RWSTD_ANSI_C_CTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_CTYPE_H "/usr/include/ctype.h"
N#endif
N#if !defined (_RWSTD_NO_ERRNO_H) && !defined (_RWSTD_ANSI_C_ERRNO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ERRNO_H "/usr/include/errno.h"
N#endif
N#if !defined (_RWSTD_NO_FLOAT_H) && !defined (_RWSTD_ANSI_C_FLOAT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_FLOAT_H "/usr/include/float.h"
N#endif
N#if !defined (_RWSTD_NO_ISO646_H) && !defined (_RWSTD_ANSI_C_ISO646_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ISO646_H "/usr/include/iso646.h"
N#endif
N#if !defined (_RWSTD_NO_LIMITS_H) && !defined (_RWSTD_ANSI_C_LIMITS_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LIMITS_H "/usr/include/limits.h"
N#endif
N#if !defined (_RWSTD_NO_LOCALE_H) && !defined (_RWSTD_ANSI_C_LOCALE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LOCALE_H "/usr/include/locale.h"
N#endif
N#if !defined (_RWSTD_NO_MATH_H) && !defined (_RWSTD_ANSI_C_MATH_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_MATH_H "/usr/include/math.h"
N#endif
N#if !defined (_RWSTD_NO_SETJMP_H) && !defined (_RWSTD_ANSI_C_SETJMP_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SETJMP_H "/usr/include/setjmp.h"
N#endif
N#if !defined (_RWSTD_NO_SIGNAL_H) && !defined (_RWSTD_ANSI_C_SIGNAL_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SIGNAL_H "/usr/include/signal.h"
N#endif
N#if !defined (_RWSTD_NO_STDARG_H) && !defined (_RWSTD_ANSI_C_STDARG_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDARG_H "/usr/include/stdarg.h"
N#endif
N#if !defined (_RWSTD_NO_STDDEF_H) && !defined (_RWSTD_ANSI_C_STDDEF_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDDEF_H "/usr/include/stddef.h"
N#endif
N#if !defined (_RWSTD_NO_STDIO_H) && !defined (_RWSTD_ANSI_C_STDIO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDIO_H "/usr/include/stdio.h"
N#endif
N#if !defined (_RWSTD_NO_STDLIB_H) && !defined (_RWSTD_ANSI_C_STDLIB_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDLIB_H "/usr/include/stdlib.h"
N#endif
N#if !defined (_RWSTD_NO_STRING_H) && !defined (_RWSTD_ANSI_C_STRING_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STRING_H "/usr/include/string.h"
N#endif
N#if !defined (_RWSTD_NO_TIME_H) && !defined (_RWSTD_ANSI_C_TIME_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_TIME_H "/usr/include/time.h"
N#endif
N#if !defined (_RWSTD_NO_WCHAR_H) && !defined (_RWSTD_ANSI_C_WCHAR_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCHAR_H "/usr/include/wchar.h"
N#endif
N#if !defined (_RWSTD_NO_WCTYPE_H) && !defined (_RWSTD_ANSI_C_WCTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCTYPE_H "/usr/include/wctype.h"
N#endif
N
N
N// Macro for determining the number of bits in a word.
N// Used by vector<bool>.
N//
N#define _RWSTD_WORD_BIT (int(CHAR_BIT*sizeof(unsigned int)))
N
N
N//
N// These macros tune the speed vs. space optimization of container
N// performance with regard to allocation of memory. These have been tuned
N// with speed efficiency as a primary conern. Space efficiency was
N// considered, but was secondary. (refer to Onyx QA Entry #4920)
N//
N// The ratio parameter must be above one for an amortized constant time
N// algorithm.  Lowering the ratio will lower rapidity and improve space
N// efficiency. This effect will be most noticable when working with
N// containers of few elements (few being less than 32 for the general case)
N// If your use case is with containers that typically have many elements
N// lowering the ratio will have less effect on rapidity.
N//
N// The minimum elements parameter refers to minimum amount of additional
N// capcity requested (in number of elements) when more memory is needed.
N// Rapidity with containers of few elements will be affected most noticably
N// as this amount this is lowered.
N//
N// For strings, the specializations on char and wchar_t were seen as an
N// exploitable common case, and have their own more specialized template
N// function overloads in the string header.  These are tweakable here
N// with the STRING version of these macros.
N//
N#if !defined(_RWSTD_MINIMUM_NEW_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_NEW_CAPACITY _RWSTD_C::size_t (32)
N#endif
N#if !defined(_RWSTD_NEW_CAPACITY_RATIO)
X#if !0L
N   // using long doubles to eliminate bogus warnings on g++ 2.95.2/sparc
N   // (-W -O2/3 only): warning: overflow on truncation to integer
N   //#  define _RWSTD_NEW_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_CAPACITY(x) ((x) + ((x) >> 1) + ((x) >> 3)) // 'x * 1.625'
N#endif
N#if !defined(_RWSTD_MINIMUM_STRING_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_STRING_CAPACITY _RWSTD_C::size_t (128)
N#endif
N#if !defined(_RWSTD_STRING_CAPACITY_RATIO)
X#if !0L
N   //#  define _RWSTD_STRING_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_STRING_CAPACITY(x) _RWSTD_INCREASE_CAPACITY(x)
N#endif
N
N
N// set up Win32/64 DLL export/import directives
N// _DLL - defined by the compiler when either -MD or -MDd is used
N// RWDLL - defined for all Rogue Wave products to be built as shared libs
N// _RWSHARED - defined for stdlib to be built/used as a shared lib
N#if    (defined (_WIN32) || defined (_WIN64)) \
N    && (defined (RWDLL) || defined (_RWSHARED))
X#if    (0L || 0L)     && (0L || 0L)
S#  ifdef _RWBUILD_std
S     // building a shared lib, export names
S#    define _RWSTD_EXPORT   __declspec (dllexport)
S#  else
S     // using a shared lib, import names
S#    define _RWSTD_EXPORT   __declspec (dllimport)
S#  endif
S
S   // disable warnings:
S   // C4251: class needs to have dll-interface to be used by cliens
S   // C4275: non dll-interface class used as base for dll-interface class
S#  pragma warning (disable: 4251)
S#  pragma warning (disable: 4275)
N#else
N// disable Windows hacks
N#  define _RWSTD_EXPORT
N#endif
N
N
N// The member variable string::npos is required to be static to allow its
N// use in constant expressions.  For compilers that do not support static
N// intialization an enumeration is used.  This workaround is not available
N// on LLP64 architectures however, where enums are 32 bit.  In this case it
N// we don't have a workaround to support the use of npos in constant
N// expressions, the macro _RWSTD_NPOS must be used instead
N#if defined(_RWSTD_LLP64_ARCHITECTURE) && defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if 0L && 0L
S#  define _RWSTD_NPOS _RWSTD_C::size_t(-1)
N#else
N#  define _RWSTD_NPOS string::npos
N#endif
N
N
N/*
N** Miscellaneous workarounds.
N*/
N
N#ifdef _RWSTD_NO_BOOL
S#  ifdef _RWSTD_MSVC_BOOL_WARNING
S#    pragma warning ( disable : 4237 )
S#  endif
S
S   typedef int     bool;
S
S#  ifndef true
S#    define true    1
S#  endif
S
S#  ifndef false
S#    define false   0
S#  endif
N#endif // _RWSTD_NO_BOOL
N
N
N#ifndef _RWSTD_NO_TYPENAME
N#  define _TYPENAME typename
N#else
S#  define _TYPENAME
N#endif
N
N#if defined (SNI) || defined (__SUNPRO_CC) && __SUNPRO_CC <= 0x520
X#if 0L || 0L && __SUNPRO_CC <= 0x520
S#  define _TYPENAME_CTOR
N#else
N#  define _TYPENAME_CTOR _TYPENAME
N#endif
N
N#ifndef _RWSTD_NO_EXPLICIT
N#  define _EXPLICIT explicit
N#else
S#  define _EXPLICIT
N#endif
N
N
N#ifndef _RWSTD_NO_MUTABLE
N#  define _MUTABLE mutable
N#else
S#  define _MUTABLE
N#endif
N
N
N//
N// Macro for forming or omitting default template arguments in constructors
N//
N
N#ifndef _RWSTD_NO_DEFAULT_TEMPLATE_ARGS
N#  define _RWSTD_DEFAULT_ARG(n) = n
N#else
S#  define _RWSTD_DEFAULT_ARG(n)
N#endif
N
N
N// MSVC version 12.00.xxxx (and perhaps prior) can't parse template
N// re-declarations if the previous declaration contains two or more
N// default template parameters (go figure)
N#if defined (_MSC_VER) && _MSC_VER <= 1300
X#if 0L && _MSC_VER <= 1300
S#  define _RWSTD_REDECLARED_DEFAULT(arg)   = arg
N#else   // if !(!defined (_MSC_VER) || (_MSC_VER <= 1300))
N#  define _RWSTD_REDECLARED_DEFAULT(ignore)
N#endif   // !defined (_MSC_VER) || (_MSC_VER <= 1300)
N
N
N//
N// Macro for forming or ommitting default template parameters.
N//
N#ifndef _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N#  define _RWSTD_SIMPLE_DEFAULT(a)  = a
N#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N#    define _RWSTD_COMPLEX_DEFAULT(a)  = a
N#  else
S#    define _RWSTD_COMPLEX_DEFAULT(a)
N#  endif
N#else   // if defined (_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES)
S#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#  endif
S#  define _RWSTD_SIMPLE_DEFAULT(a)
S#  define _RWSTD_COMPLEX_DEFAULT(a)
S#  ifndef _RWSTD_NO_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_DEFAULT_TEMPLATES
S#  endif
N#endif   // _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N
N
N// Macro for casting, using either the "old" method
N// or the new C++ cast system
N#ifdef _RWSTD_NO_STATIC_CAST
S#  define _RWSTD_STATIC_CAST(x, y)      ((x)y)
S#  define _RWSTD_REINTERPRET_CAST(x, y) ((x)y)
S#  define _RWSTD_CONST_CAST(x, y)       ((x)y)
N#else
N#  define _RWSTD_STATIC_CAST(x, y)      static_cast< x >(y)
N#  define _RWSTD_REINTERPRET_CAST(x, y) reinterpret_cast< x >(y)
N#  define _RWSTD_CONST_CAST(x, y)       const_cast< x >(y)
N#endif   // _RWSTD_NO_STATIC_CAST
N
N//
N// Macros for the new template specialization syntax
N//
N
N#ifdef _RWSTD_NO_NEW_FUNC_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_FUNCTION
N#else
N#  define _RWSTD_SPECIALIZED_FUNCTION template<>
N#endif
N
N#ifdef _RWSTD_NO_NEW_CLASS_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_CLASS
N#else
N#  define _RWSTD_SPECIALIZED_CLASS template<>
N#endif
N
N// for compilers or environments that do not support namespaces
N#ifndef _RWSTD_NO_NAMESPACE
N#  define _RWSTD_NAMESPACE_BEGIN(name)    namespace name {
N#  define _RWSTD_NAMESPACE_END            }
N
N#  define _USING(name)                    using name
N
N#  ifdef _MSC_VER
S#    define _STD                       ::std
S#    define _STD_RW                    ::std
S#    define _RW                        ::__rw
N#  else
N#    define _STD                       std
N#    define _STD_RW                    std
N#    define _RW                        __rw
N#  endif
N
N#else   // if defined (_RWSTD_NO_NAMESPACE)
S#  define _RWSTD_NAMESPACE_BEGIN(ignore)
S#  define _RWSTD_NAMESPACE_END
S
S#  define _USING(ignore)              typedef void __rw_unused_typedef
S
S#  define _STD
S#  define _STD_RW
S#  define _RW
N#endif   // _RWSTD_NO_NAMESPACE
N
N//
N// for compilers that don't like specialized friends
N// such as operator== in template classes
N//
N#ifdef _RWSTD_NO_SPECIALIZED_FRIEND
S#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
S#  else   // if !defined (__TURBOC__)
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   name
S#  endif   // __TURBOC__
N#else   // if defined (_RWSTD_NO_SPECIALIZED_FRIEND)
N#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
N#  else   // if !defined (__TURBOC__)
N     // the space between `name' and `<>' is necessary
N     // to prevent ..._FRIEND (operator<) from expanding into operator<<>
N     // (only the GNU preprocessor inserts a space)
N#    define _RWSTD_SPECIALIZED_FRIEND(name)   name <>
N#  endif  // __TURBOC__
N#endif   // _RWSTD_NO_SPECIALIZED_FRIEND
N
N
N//
N// If compiler supports member and default templates then it support
N// the _RWSTD_ALLLOCATOR
N//
N#if    !defined(_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined(_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) \
N    && !defined(_RWSTD_NO_MEM_CLASS_TEMPLATES)
X#if    !0L     && !0L     && !0L
N#  define _RWSTD_ALLOCATOR
N#endif
N
N
N#define _RWSTD_MB_CUR_MAX 16  //???  Need to find absolute maximum for this
N
N
N// helper macros for token pasting
N#define _RWSTD_DO_PASTE(a, b)   a ## b
N#define _RWSTD_PASTE(a, b)      _RWSTD_DO_PASTE (a, b)
N
N#ifdef _RWSTD_MULTI_THREAD
S// synchronizes access by all objects holding the same mutex
S#  define _RWSTD_MT_GUARD(mutex)  \
S          _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
X#  define _RWSTD_MT_GUARD(mutex)            _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
S
S// synchronizes access by all threads
S#  define _RWSTD_MT_STATIC_GUARD(name)        \
S          static _RW::__rw_mutex name; \
S          _RWSTD_MT_GUARD (name)
X#  define _RWSTD_MT_STATIC_GUARD(name)                  static _RW::__rw_mutex name;           _RWSTD_MT_GUARD (name)
S
S// synchronizes access by all objects of the same type
S#  define _RWSTD_MT_CLASS_GUARD(name, type) \
S          _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
X#  define _RWSTD_MT_CLASS_GUARD(name, type)           _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
S
S#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex) \
S          _RW::__rw_atomic_preincrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex)           _RW::__rw_atomic_preincrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex) \
S          _RW::__rw_atomic_predecrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex)           _RW::__rw_atomic_predecrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_SWAP(x, y, mutex) \
S          _RW::__rw_atomic_exchange  (x, y, mutex)
X#  define _RWSTD_ATOMIC_SWAP(x, y, mutex)           _RW::__rw_atomic_exchange  (x, y, mutex)
S
S#  ifndef _RWSTD_NO_EXT_REENTRANT_IO
S// conditional swap used in iostreams
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            ((this->flags () & _RWSTD_IOS_NOLOCK) ?      \
S                _RW::__rw_ordinary_exchange  (x, y)      \
S             :  _RW::__rw_atomic_exchange  (x, y, mutex))
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       ((this->flags () & _RWSTD_IOS_NOLOCK) ?                      _RW::__rw_ordinary_exchange  (x, y)                   :  _RW::__rw_atomic_exchange  (x, y, mutex))
S
S#  else
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            _RWSTD_ATOMIC_SWAP(x, y, mutex)
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       _RWSTD_ATOMIC_SWAP(x, y, mutex)
S#  endif    // _RWSTD_NO_EXT_REENTRANT_IO
S
N#else   // if !defined _RWSTD_MULTI_THREAD
N
N#  define _RWSTD_MT_GUARD(ignore)                   ((void)0)
N#  define _RWSTD_MT_STATIC_GUARD(name)              _RWSTD_MT_GUARD (name)
N#  define _RWSTD_MT_CLASS_GUARD(name, ignore)       _RWSTD_MT_GUARD (name)
N
N#  define _RWSTD_ATOMIC_PREINCREMENT(x, ignore)     ++(x)
N#  define _RWSTD_ATOMIC_PREDECREMENT(x, ignore)     --(x)
N#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)  \
N          _RW::__rw_atomic_exchange ((x), (y), false)
X#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)            _RW::__rw_atomic_exchange ((x), (y), false)
N
N#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)  \
N          _RW::__rw_ordinary_exchange ((x), (y))
X#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)            _RW::__rw_ordinary_exchange ((x), (y))
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N// macro for qualifying C library names in the std namespace
N#ifndef _RWSTD_NO_LIBC_IN_STD
N# define _RWSTD_C std
N#else
S# define _RWSTD_C
N#endif
N
N#define _RWSTD_INVALID_FILE_DESC -1
N#define _RWSTD_INVALID_FILE_PTR   0
N
N#ifndef _RWSTD_NO_NATIVE_IO
S# define _RWSTD_INVALID_FILE     -1
S# define _RWSTD_INVALID_OPENMODE -1
N#else
N# define _RWSTD_INVALID_FILE      (FILE*)0
N# define _RWSTD_INVALID_OPENMODE  0
N#endif // _RWSTD_NO_NATIVE_IO
N
N
N// std::ios_base static const data members' values
N#define _RWSTD_IOS_BOOLALPHA    0x00001
N#define _RWSTD_IOS_DEC          0x00002
N#define _RWSTD_IOS_FIXED        0x00004
N#define _RWSTD_IOS_HEX          0x00008
N#define _RWSTD_IOS_INTERNAL     0x00010
N#define _RWSTD_IOS_LEFT         0x00020
N#define _RWSTD_IOS_OCT          0x00040
N#define _RWSTD_IOS_RIGHT        0x00080
N#define _RWSTD_IOS_SCIENTIFIC   0x00100
N#define _RWSTD_IOS_SHOWBASE     0x00200
N#define _RWSTD_IOS_SHOWPOINT    0x00400
N#define _RWSTD_IOS_SHOWPOS      0x00800
N#define _RWSTD_IOS_SKIPWS       0x01000
N#define _RWSTD_IOS_UNITBUF      0x02000
N#define _RWSTD_IOS_UPPERCASE    0x04000
N#define _RWSTD_IOS_BIN          0x08000
N// NOLOCK[BUF] used rather than LOCK[BUF] to maintain functional compatibility
N// with release 2.2 (which was always safe when these bits were cleared)
N#define _RWSTD_IOS_NOLOCK       0x10000
N#define _RWSTD_IOS_NOLOCKBUF    0x20000
N
N#define _RWSTD_IOS_FLOATFIELD   _RWSTD_IOS_FIXED | _RWSTD_IOS_SCIENTIFIC
N
N#define _RWSTD_IOS_ADJUSTFIELD    \
N        (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
X#define _RWSTD_IOS_ADJUSTFIELD            (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
N
N#ifndef _RWSTD_NO_EXT_BIN_IO
N#  define _RWSTD_IOS_BASEFIELD    \
N          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
N#else
S#  define _RWSTD_IOS_BASEFIELD    \
S          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
N#endif   // _RWSTD_NO_EXT_BIN_IO
N
N
N#define _RWSTD_IOS_GOODBIT       0x00
N#define _RWSTD_IOS_BADBIT        0x01
N#define _RWSTD_IOS_EOFBIT        0x02
N#define _RWSTD_IOS_FAILBIT       0x04
N
N#define _RWSTD_IOS_APP           0x01
N#define _RWSTD_IOS_BINARY        0x02
N#define _RWSTD_IOS_IN            0x04
N#define _RWSTD_IOS_OUT           0x08
N#define _RWSTD_IOS_TRUNC         0x10
N#define _RWSTD_IOS_ATE           0x20
N
N#ifndef _RWSTD_STRICT_ANSI
N#  define _RWSTD_IOS_NOCREATE    0x40
N#  define _RWSTD_IOS_NOREPLACE   0x80
N#else
S#  define _RWSTD_IOS_NOCREATE    0
S#  define _RWSTD_IOS_NOREPLACE   0
N#endif
N
N#define _RWSTD_IOS_MASK                         \
N        (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY   \
N         | _RWSTD_IOS_IN | _RWSTD_IOS_OUT       \
N         | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE    \
N         | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
X#define _RWSTD_IOS_MASK                                 (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY            | _RWSTD_IOS_IN | _RWSTD_IOS_OUT                | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE             | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
N
N
N#if    !defined (_RWSTD_NO_STATIC_IOSTREAM_INIT)  \
N    && !defined (_RWSTD_NO_IOSTREAM_OBJECT_REFS)
X#if    !0L      && !0L
N   // standard iostream objects are references
N#  define _RWSTD_IOSTREAM_OBJECT(name)   &name
N#else
S   // standard iostream objects are declared to be real objects
S   // they may be implemented as real objects of the same type
S   // that get destroyed during program lifetime or as objects
S   // of some POD type that do not get destroyed at all
S#  define _RWSTD_IOSTREAM_OBJECT(name)   name
N#endif   //  _RWSTD_NO_STATIC_IOSTREAM_INIT && !_RWSTD_NO_IOSTREAM_OBJECT_REFS
N
N
N// exceptions can be completely disabled (bodies of catch blocks are still
N// compiled but will be removed by the optimizing stage of the compiler)
N// this approach reveals any errors even if _RWSTD_NO_EXCEPTIONS is #defined
N#ifndef _RWSTD_NO_EXCEPTIONS
S#  define _TRY           try
S#  define _CATCH(ex)     catch (ex)
S#  define _CATCH_T(ex)   catch (ex)
S#  define _THROW(ex)     throw ex
S#  define _RETHROW       throw
N#else   // if defined (_RWSTD_NO_EXCEPTIONS)
N#  define _TRY
N#  define _CATCH(ignore)   while (0)
N#  define _CATCH_T(type)   for (type; 0;) 
N#  define _THROW(ignore)   ((void)0)
N#  define _RETHROW         ((void)0)
N#endif   // _RWSTD_NO_EXCEPTIONS
N
N
N// for compilers that can't handle standard allocators we provide four
N// workarounds: _RWSTD_REBIND, used in place of _Allocator::rebind, allows
N// containers to use the same allocator for different data types
N// _RWSTD_ALLOC_TYPE is required to "rebind", or rather wrap,  the user
N// supplied non-conforming allocator in allocator_interface so that the
N// container need not be aware of the allocator's special properties (namely
N// the fact that the allocator allocates in terms of bytes rather than
N// elemements)
N//
N// _RWSTD_VALUE_ALLOC creates a temporary allocator_interface wrapper
N// from the given parameter (usually *this) when allocating values in
N// the sequence containers with non-conforming allocators.
N// _RWSTD_VALUE_ALLOC_CAST casts the given container to a reference to
N// a value allocator, allowing access to inherited allocator members
N// outside of the class.  For non-conforming compilers, this macro is
N// equivalent to _RWSTD_VALUE_ALLOC.
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `to' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifdef _RWSTD_ALLOCATOR
N#  define _RWSTD_REBIND(from, to) \
N          _TYPENAME from::template rebind < to >::other
X#  define _RWSTD_REBIND(from, to)           _TYPENAME from::template rebind < to >::other
N#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   _Allocator
N#  define _RWSTD_VALUE_ALLOC(ignore, call)            allocator_type::call
N#  define _RWSTD_VALUE_ALLOC_CAST(rvalue) \
N          _RWSTD_STATIC_CAST (allocator_type&, rvalue)
X#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)           _RWSTD_STATIC_CAST (allocator_type&, rvalue)
N#else   // if !defined (_RWSTD_ALLOCATOR)
S#  define _RWSTD_REBIND(from, to) \
S          _STD_RW::allocator_interface < from, to >
X#  define _RWSTD_REBIND(from, to)           _STD_RW::allocator_interface < from, to >
S#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   \
S          _RWSTD_REBIND (_Allocator, _ValueType)
X#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)             _RWSTD_REBIND (_Allocator, _ValueType)
S#  define _RWSTD_VALUE_ALLOC(type, call)      type(*this).call
S#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)     _C_value_alloc_type(rvalue)
N#endif   // _RWSTD_ALLOCATOR
N
N
N// for compilers that can't deal with template functions parametrized
N// on the function's return type (as opposed to function arguments)
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `type' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N#  define _STD_USE_FACET(type, arg)    _STD::use_facet < type >(arg)
N#  define _USE_FACET(type, arg)        use_facet < type >(arg)
N#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer < type >(size)
N#else   // if defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
S#  define _STD_USE_FACET(type, arg)    _STD::use_facet (arg, (type*)(0))
S#  define _USE_FACET(type, arg)        use_facet (arg, (type*)(0))
S#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer (size, (type*)0)
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N#ifndef _RWSTD_NO_NONCLASS_ARROW_RETURN
N   // expected signature: "_TypeT* operator->()"
N   // and/or:             "const _TypeT* operator->() const"
N#  define _RWSTD_OPERATOR_ARROW(signature) signature { return &**this; }
N#else
S#  define _RWSTD_OPERATOR_ARROW(ignore)
N#endif   // _RWSTD_NO_NONCLASS_ARROW_RETURN
N
N
N// to prevent warnings about unused arguments
N#define _RWSTD_UNUSED(arg)   ((void)&arg)
N
N
N// allows all externs to be declared/defined only in headers
N// and defined just by first #defining _RWSTD_DEFINE_EXTERNS
N// and then #including the header in a .cpp file
N#ifndef _RWSTD_DEFINE_EXTERNS
N#  define _RWSTD_EXTERN(decl, ignore)   extern decl
N#else
S#  define _RWSTD_EXTERN(decl, value)    extern decl = value
N#endif   // _RWSTD_DEFINE_EXTERNS
N
N
N// allows static const integral or enum class members to be initialized
N// inside the class and defined (w/o being initialized) outside
N// of the class (as required by 9.4.2, p4)
N#if !defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if !0L
N#  define _RWSTD_STATIC_CONST(type, init)    static const type init
N#  define _RWSTD_DEFINE_STATIC_CONST(decl)   decl
N#else
S#  define _RWSTD_STATIC_CONST(ignore, init)  enum { init }
S#  define _RWSTD_DEFINE_STATIC_CONST(ignore)
N#endif   // _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N
N
N// Selection of vendor dependent "format" string argument to wcsftime()
N#ifndef _RWSTD_NO_WCSFTIME
N   // 7.24.5.1 of C99 - wcsftime()'s 3rd arg is const wchar* [restrict]
N   //                   HP-UX 11 (and perhaps others) still uses const char*
N#  ifndef _RWSTD_NO_WCSFTIME_WCHAR_T_FMAT
N#     define _RWSTD_FMT_TYPE(arg)  const wchar_t* arg
N#     define _RWSTD_FMT_ASSGN(str) L##str
N#  else
S#     define _RWSTD_FMT_TYPE(arg)  const char* arg
S#     define _RWSTD_FMT_ASSGN(str) str
N#  endif
N#else   // if defined (_RWSTD_NO_WCSFTIME)
S#  define _RWSTD_FMT_TYPE(arg)     const char* arg
S#  define _RWSTD_FMT_ASSGN(str)    str
N#endif // _RWSTD_NO_WCSFTIME
N
N
N// _Iterator typedefs
N// (note that you must use a semi-colon at the end of this macro)
N#define _RWSTD_ITERATOR_TYPES(_Iterator)                               \
N     typedef _TYPENAME _Iterator::difference_type difference_type;     \
N     typedef _TYPENAME _Iterator::value_type value_type;               \
N     typedef _TYPENAME _Iterator::pointer pointer;                     \
N     typedef _TYPENAME _Iterator::reference reference;                 \
N     typedef _TYPENAME _Iterator::iterator_category iterator_category
X#define _RWSTD_ITERATOR_TYPES(_Iterator)                                    typedef _TYPENAME _Iterator::difference_type difference_type;          typedef _TYPENAME _Iterator::value_type value_type;                    typedef _TYPENAME _Iterator::pointer pointer;                          typedef _TYPENAME _Iterator::reference reference;                      typedef _TYPENAME _Iterator::iterator_category iterator_category
N
N// helpers making working w/o iterator_traits transparent
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_VALUE_TYPE(iterT) \
N       (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
X#  define _RWSTD_VALUE_TYPE(iterT)        (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
N#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
N       (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
N#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore) \
N       _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
X#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore)        _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S#  define _RWSTD_VALUE_TYPE(iterT) __value_type ((iterT*)0)
S   // assume default ctor is defined and accessible
S#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
S       _STD::__distance_type (iterT ())
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          _STD::__distance_type (iterT ())
S   // macro cannot use the default ctor to construct a temporary
S   // with the type of the first argument since the default ctor
S   // may not exist or be accessible (e.g., istream_iterator<>)
S#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter) \
S       _STD::__iterator_category (iter)
X#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter)        _STD::__iterator_category (iter)
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// Use -D_RWSTDDEBUG to compile a version of the libraries to debug
N// the user's code.  This will perform pre- and post-condition checks
N// upon entering routines, but will be larger and run more slowly.
N// This option affects the binary compatibility of generated code.
N
N
N#if defined(RWDEBUG) && !defined(_RWSTDDEBUG)
X#if 0L && !0L
S#  define _RWSTDDEBUG 1
N#endif
N
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_ASSERT(expr)                                                \
S     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__, \
S                                                __PRETTY_FUNCTION__))
X#  define _RWSTD_ASSERT(expr)                                                     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__,                                                 __PRETTY_FUNCTION__))
N#else   //  if !defined (_RWSTDDEBUG)
N#  define _RWSTD_ASSERT(ignore)         ((void)0)
N#endif   // _RWSTDDEBUG
N
N// compile-time assertion - asserts constant expressions during
N// compilation with no runtime overhead; failed assertions are reported
N// as compilation errors
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
Ntemplate <bool __b>
Nstruct __rw_compile_assert;
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_compile_assert<true> { enum { _C_ok }; };
N
N#define _RWSTD_COMPILE_ASSERT(const_expr) \
N        ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
X#define _RWSTD_COMPILE_ASSERT(const_expr)         ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
N
N// called for failed assertions
Nvoid _RWSTD_EXPORT
Xvoid 
N__rw_assert_fail (const char *__expr,
N                       const char *__file, int __line, const char *__func);
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N#  define _RWSTD_STR(x)       #x
N#  define _RWSTD_STRSTR(x)    _RWSTD_STR(x)
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, __PRETTY_FUNCTION__
S#  define _RWSTD_FILE_LINE   __MODULE__ ":" _RWSTD_STRSTR (__LINE__)
N#else
N#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, ""
N#  define _RWSTD_FILE_LINE   ""
N#endif
N
N/* at least some of the _RWSTD_REQUIRES are needed for conformance */
N#  define _RWSTD_REQUIRES(pred, args)   (pred) ? (void)0 : _RW::__rw_throw args
N
N// function exception specification
N#if    !defined (_RWSTD_NO_EXCEPTIONS) \
N    && !defined (_RWSTD_NO_EXCEPTION_SPECIFICATION)
X#if    !1L     && !0L
S   // type_id_list is a possibly empty parenthesized list
S   //of comma-separated type-id's
S#  define _THROWS(type_id_list)   throw type_id_list
N#else   // if _RWSTD_NO_EXCEPTIONS || _RWSTD_NO_EXCEPTION_SPECIFICATION
N#  define _THROWS(ignore)
N#endif   // !_RWSTD_NO_EXCEPTIONS && !_RWSTD_NO_EXCEPTION_SPECIFICATION
N
N
N// for convenience
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N#  define _DISTANCE(first, last, ignore) _STD_RW::distance (first, last)
N#else
S#  define _DISTANCE(first, last, type) _RW::__rw_distance (first, last, type())
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// pointers to the incomplete types declared below are used
N// to disambiguate calls to template member functions
N// bodies provided only to work around an HP aCC 3.14.10 bug
Ntemplate <bool __b>
Nstruct __rw_select { };
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_select<true> { };
N
N#define _RWSTD_DISPATCH_INT(yes) const _RW::__rw_select < yes >*
N#define _RWSTD_DISPATCH(iter) \
N        ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
X#define _RWSTD_DISPATCH(iter)         ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#if defined (__IBMCPP__) && __IBMCPP <= 500
X#if 0L && __IBMCPP <= 500
S
S// working around an xlC 5.0 bug
S_USING (__rw::__rw_select);
S
N#endif
N
N
N// select appropriate C multibyte conversion function based on
N// whether "restartable" functions are available.
N
N
N#ifndef _RWSTD_NO_MBRTOWC
N   // reentrant versions return size_t - see 7.24.6.3.2 of C99
N#  define _RWSTD_MBTOWC(to, from, size, state) mbrtowc (to, from, size, state)
N#elif !defined (_RWSTD_NO_MBTOWC)
X#elif !0L
S   // non-reentrant versions return int - see 7.20.7.2 of C99
S#  define _RWSTD_MBTOWC(to, from, size, ignore_state) \
S          _RWSTD_C::size_t (mbtowc(to, from, size))
X#  define _RWSTD_MBTOWC(to, from, size, ignore_state)           _RWSTD_C::size_t (mbtowc(to, from, size))
S#else
S   // mbtowc not supported
S#  define _RWSTD_MBTOWC(ign1, ign2, ign3, ign4) _RWSTD_C::size_t (-1)
N#endif   // _RWSTD_NO_MBRTOWC
N
N#ifndef _RWSTD_NO_WCRTOMB
N#  define _RWSTD_WCTOMB(to, from, state)       wcrtomb (to, from, state)
N#else   // if defined (_RWSTD_NO_WCRTOMB)
S#  define _RWSTD_WCTOMB(to, from, ignore_state) \
S          _RWSTD_C::size_t (wctomb (to, from))
X#  define _RWSTD_WCTOMB(to, from, ignore_state)           _RWSTD_C::size_t (wctomb (to, from))
N#endif   // _RWSTD_NO_WCRTOMB
N
N
N// unsafe when underlying libc doesn't support mbsinit
N// as described in 7.24.6.3.1 of C99
N#ifndef _RWSTD_NO_MBSINIT
N# if defined(SNI) && defined(_RWSTD_STRICT_ANSI)
X# if 0L && 0L
S#  define _MBSINIT(ps)   __SNI::mbsinit (ps)
N# else
N#  define _MBSINIT(ps)   mbsinit (ps)
N# endif
N#else   // if defined (_RWSTD_NO_MBSINIT)
S#  define _MBSINIT(ps)   (0 == (ps))
N#endif   // _RWSTD_NO_MBSINIT
N
N
N// enable only in debug mode and only id partial class specialization
N// is supported; prevent multiple definition of _RWSTD_NO_DEBUG_ITER
N#if    defined(_RWSTDDEBUG) && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_DEBUG_ITER) && !defined (SNI)
X#if    0L && !0L     && !0L && !0L
S#  define _RWSTD_ASSERT_RANGE(first, last) \
S      _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
X#  define _RWSTD_ASSERT_RANGE(first, last)       _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
S#  define _RWSTD_ASSERT_IN_RANGE(it, first, last) \
S      _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
X#  define _RWSTD_ASSERT_IN_RANGE(it, first, last)       _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
S#  define _RWSTD_ASSERT_DEREF(it) \
S      _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
X#  define _RWSTD_ASSERT_DEREF(it)       _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
N#else
N#  ifndef _RWSTD_NO_DEBUG_ITER
N#    define  _RWSTD_NO_DEBUG_ITER
N#  endif   // _RWSTD_NO_DEBUG_ITER
N
N#  define _RWSTD_ASSERT_RANGE(ign1, ign2)          ((void)0)
N#  define _RWSTD_ASSERT_IN_RANGE(ign1, ign2, ign3) ((void)0)
N#  define _RWSTD_ASSERT_DEREF(ignore)              ((void)0)
N#endif   // _RWSTDDEBUG && !_RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// convenience macro to get the "real" iterator embedded in __rw_debug_iter<>
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  define _ITER_BASE(it)   ((it).base ())
N#else   // if defined (_RWSTD_NO_DEBUG_ITER)
N#  define _ITER_BASE(it)   (it)
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N// will use the deduced native type rather than the typedef to prevent
N// conflicts caused by inconsistent definition of wint_t (gcc 2.95.2/AIX)
N#ifndef _RWSTD_WINT_T
S   // hardcode if wint_t is not available in <wchar.h>
S   // used by std::traits and std::basic_[i|o]stream
S#  define _RWSTD_WINT_T int
N#endif   // _RWSTD_WINT_T
N
N
N// used by std::traits and std::basic_[i|o]stream,
N// required to be int by 21.1.3.1, p2
N#define _RWSTD_INT_T int
N
N
N// ssize_t is defined by POSIX.1
N#ifndef _RWSTD_SSIZE_T
N#  ifdef _WIN64
S#    define _RWSTD_SSIZE_T SSIZE_T
N#  else
N#    define _RWSTD_SSIZE_T long
N#  endif
N#endif
N
N
N#if defined(SNI)
X#if 0L
S#  define _RWSTD_USING_SNI(name) _USING(__SNI::name)
S#  if defined(_RWSTD_STRICT_ANSI)
S#    define fileno(p)       (int) ((p)->_file)
S#  endif
N#else
N#  define _RWSTD_USING_SNI(ignore)    typedef void __rw_unused_typedef
N#endif
N
N
N#ifndef _RWSTD_TMPBUF_SIZE
N#  define _RWSTD_TMPBUF_SIZE 4096
N#endif
N
N#ifndef _RWSTD_NO_STRTOLL
N#  define _STRTOLL           strtoll
N#else
S   // libc has no strtoll, use strtol instead
S#  define _STRTOLL           (_RWSTD_LONG_LONG)strtol
N#endif   // _RWSTD_NO_STRTOLL
N
N
N#ifndef _RWSTD_NO_STRTOULL
N#  define _STRTOULL          strtoull
N#else
S   // libc has no strtoull, use strtoul instead
S#  define _STRTOULL          (unsigned _RWSTD_LONG_LONG)strtoul
N#endif   // _RWSTD_NO_STRTOULL
N
N
N#if     defined (_RWSTD_INSTANTIATE_TEMPLATES)       \
N    && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N    && !defined (_RWSTD_NO_INSTANTIATE)
X#if     0L           && !0L       && !0L
S#  define _RWSTD_INSTANTIATE_1(arg)          template arg
S#  define _RWSTD_INSTANTIATE_2(a1, a2)       template a1, a2
S#  define _RWSTD_INSTANTIATE_3(a1, a2, a3)   template a1, a2, a3
N#else
N#  if    defined (_MSC_VER)                          \
N      && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION) \
N      && !defined (_RWSTD_NO_INSTANTIATE)
X#  if    0L                                && !0L       && !0L
S     // disable warning C4231: nonstandard extension used :
S     //         'extern' before template explicit instantiation
S#    pragma warning (disable: 4231)
S#    define _RWSTD_INSTANTIATE_1(arg)        extern template arg
S#    define _RWSTD_INSTANTIATE_2(a1, a2)     extern template a1, a2
S#    define _RWSTD_INSTANTIATE_3(a1, a2, a3) extern template a1, a2, a3
N#  else
N#    define _RWSTD_INSTANTIATE_1(ignore)           \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_1(ignore)                       typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_2(ign1, ign2)       \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_2(ign1, ign2)                   typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3) \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3)             typedef void __rw_unused_typedef
N#  endif
N#endif   // _RWSTD_INSTANTIATE_TEMPLATES
N
N
N#ifndef _RWSTD_NO_UNCAUGHT_EXCEPTION
S#  define _UNCAUGHT_EXCEPTION()   uncaught_exception()
N#else   // if defined (_RWSTD_NO_UNCAUGHT_EXCEPTION)
N#  define _UNCAUGHT_EXCEPTION()   true
N#endif   // _RWSTD_NO_UNCAUGHT_EXCEPTION
N
N// allows for efficient compilation without implicit inclusion; only
N// specializations explicitly instantiated in the library are available
N#if     defined _RWSTD_COMPILE_INSTANTIATE               \
N    && (   !defined (_RWSTD_NO_TEMPLATE_DEFINITIONS)     \
N        ||  defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_IMPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_INSTANTIATE))
X#if     0L                   && (   !0L             ||  0L           ||  0L           ||  0L)
S#  define _RWSTD_DEFINE_TEMPLATE(name)     !(_RWSTD_NO_ ## name ## _DEFINITION)
N#else
N#  define _RWSTD_DEFINE_TEMPLATE(ignore)   0
N#endif
N
N
N// introduce namespace std so that "using namespace std;" always works
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#ifndef _RWSTD_NO_NAMESPACE
N#ifdef __EDG_IMPLICIT_USING_STD 
S/* Implicitly include a using directive for the STD namespace when this */ 
S/* preprocessing flag is TRUE. */ 
Susing namespace ::std; 
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */ 
N#endif /* _RWSTD_NO_NAMESPACE */
N
N#endif   // _RWSTD_DEFS_H_INCLUDED
N
L 36 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\iosfwd" 2
N
N
N#ifndef _RWSTD_NO_MBSTATE_T
N
N#  if defined (__GNUG__) && __GNUG__ < 3 &&__GNUC_MINOR__ < 96
X#  if 1L && 4 < 3 &&7 < 96
S     // <cstring> included to work around a g++ 2.95.2 bug
S#    include _RWSTD_CSTRING
N#  endif
N
N   // get mbstate_t (and wchar_t for MSVC 6.0)
N#  include _RWSTD_CWCHAR   
X#  include <cwchar>   
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cwchar" 1
N/*
N * C++ header for C header wchar.h
N * Copyright 2002 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cwchar
N#define __cwchar
N#define __ARMCLIB_VERSION 5060037
N
N  #define __WCHAR_NO_EXPORTS 1
N  #include <wchar.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\wchar.h" 1
N/* wchar.h: C99 header */
N/* Copyright 2002 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __wchar_h
N#define __wchar_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __WCHAR_DECLS
N  #define __WCHAR_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
N        #define __CLIBNS ::std::
N        namespace std {
N        extern "C" {
N    #else /* ndef __cplusplus */
S      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N    #if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X    #if 1L || !0L || !0L
N     /* always defined in C++ and non-strict C for consistency of debug info */
N      #if __sizeof_ptr == 8
X      #if 4 == 8
S        typedef unsigned long size_t;   /* see <stddef.h> */
N      #else
N        typedef unsigned int size_t;   /* see <stddef.h> */
N      #endif
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !1L && 0L
S        #define __size_t 1
N      #endif
N    #endif
N
N    #ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S      #if !defined(__STRICT_ANSI__) || !defined(__wchar_t)
S       /* always defined in non-strict C for consistency of debug info */
S        #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S          typedef unsigned int wchar_t; /* see <stddef.h> */
S        #else
S          typedef unsigned short wchar_t; /* see <stddef.h> */
S        #endif
S        #ifdef __STRICT_ANSI__
S          #define __wchar_t 1
S        #endif
S      #endif
N    #endif
N
N    #if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__wint_t)
X    #if 1L || !0L || !0L
N     /* always defined in C++ and non-strict C for consistency of debug info */
N      typedef int wint_t;   /* see also <wctype.h> */
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !1L && 0L
S        #define __wint_t 1
N      #endif
N    #endif
N
N        /* limits of wchar_t */
N        /* NB we have to undef and redef because they're defined in both
N         * stdint.h and wchar.h */
N    #undef WCHAR_MIN
N    #undef WCHAR_MAX
N
N    #if defined(__WCHAR32)  || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L  || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      #define WCHAR_MIN   0
S      #define WCHAR_MAX   0xffffffffU
N    #else
N      #define WCHAR_MIN   0
N      #define WCHAR_MAX   65535
N    #endif
N
N    #undef NULL
N    #define NULL 0                   /* see <stddef.h> */
N
N    /* ANSI forbids va_list to be defined here */
N    /* keep in step with <stdarg.h> and <stdio.h> */
N    #if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X    #if !0L && (1L || !0L || !0L)
N    /* always defined in C++ and non-strict C for consistency of debug info */
N      #ifdef __clang__
S        typedef __builtin_va_list __va_list;
N      #else
N        typedef struct __va_list __va_list;
N      #endif
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !1L && 0L
S        #define __va_list_defined 1
N      #endif
N    #endif
N
N  #ifndef __ARM_WCHAR_NO_IO
N    #undef WEOF
N    #define WEOF ((__CLIBNS wint_t)-1)
N
N    /* ANSI forbids FILE to be defined here */
N    #if !defined(__STRICT_ANSI__)
X    #if !0L
N    /* always defined in non-strict C/C++ for consistency of debug info */
N      typedef struct __FILE FILE;
N    #else
S      struct __FILE;
N    #endif
N  #endif /* __ARM_WCHAR_NO_IO */
N
N    /*
N     * If the compiler supports signalling nans as per N965 then it
N     * will define __SUPPORT_SNAN__, in which case a user may define
N     * _WANT_SNAN in order to obtain compliant versions of the
N     * fwprintf, fwscanf, and wcstod families of functions.
N     */
N    #if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X    #if 0L && 0L
S    #pragma import(__use_snan)
N    #endif
N
N
N    /*
N     * mbstate_t must be able to contain all the data from an
N     * incomplete MB character, plus shift states. CJK-specific
N     * encodings seem to tend to have at most three bytes per
N     * character, and a single-figure number of shift states, so 32
N     * bits is sufficient for any of these. UTF-8 encoding a full
N     * 32-bit value is the hardest thing to deal with, and in that
N     * situation the worst case is having to store 25 bits of
N     * character (1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx) plus
N     * a few bits saying what sort of state is being stored. This is
N     * still easy enough to fit into 32 bits, so I think a single
N     * 32-bit integer is enough in here.
N     */
N    typedef struct __mbstate_t {
N        unsigned int __state, __state2;
N    } mbstate_t;
N
N    /*
N     * `struct tm' must be declared in this header as an incomplete
N     * type.
N     */
N    struct tm;
N            
N    extern _ARMABI size_t wcsftime(wchar_t * __restrict /*s*/, size_t /*maxsize*/,
X    extern __declspec(__nothrow) size_t wcsftime(wchar_t * __restrict  , size_t  ,
N                       const wchar_t * __restrict /*format*/, const struct tm * __restrict /*timeptr*/) __attribute__((__nonnull__(1,3,4)));
N
N  #ifndef __ARM_WCHAR_NO_IO
N    /*
N     * Formatted wide-character I/O functions
N     */
N#pragma __printf_args
N    int swprintf(wchar_t * __restrict /*s*/, size_t /*n*/,
N                 const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N#pragma __printf_args
N    int vswprintf(wchar_t * __restrict /*s*/, size_t /*n*/,
N                  const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#pragma __scanf_args
N    int swscanf(const wchar_t * __restrict /*s*/,
N                const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int vswscanf(const wchar_t * __restrict /*s*/,
N                 const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N
N
N#pragma __printf_args
N    int fwprintf(struct __FILE * __restrict /*stream*/,
N                 const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __printf_args
N    int vfwprintf(struct __FILE * __restrict /*stream*/,
N                  const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int fwscanf(struct __FILE * __restrict /*stream*/,
N                const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int vfwscanf(struct __FILE * __restrict /*stream*/,
N                 const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N
N
N#pragma __printf_args
N    int wprintf(const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
N#pragma __printf_args
N    int vwprintf(const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
N#pragma __scanf_args
N    int wscanf(const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
N#pragma __scanf_args
N    int vwscanf(const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
N
N    /* 
N     * Unformatted wide-character I/O functions
N     */
N    wint_t fgetwc(struct __FILE * /*stream*/) __attribute__((__nonnull__(1)));
N    wchar_t *fgetws(wchar_t * __restrict /*s*/, int /*n*/, struct __FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N    wint_t fputwc(wchar_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N    int fputws(const wchar_t * __restrict /*s*/, struct __FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
N    int fwide(struct __FILE * /*stream*/, int /*mode*/) __attribute__((__nonnull__(1)));
N    wint_t getwc(struct __FILE * /*stream*/) __attribute__((__nonnull__(1)));
N    wint_t getwchar(void);
N    wint_t putwc(wchar_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N    wint_t putwchar(wchar_t /*c*/);
N    wint_t ungetwc(wint_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N  #endif /* __ARM_WCHAR_NO_IO */
N
N    wint_t btowc(int /*c*/);
N    wint_t wctob(int /*c*/);
N    int mbsinit(const mbstate_t * /*ps*/);
N    size_t mbrlen(const char * __restrict /*s*/, size_t /*n*/,
N                  mbstate_t * __restrict /*ps*/);
N    size_t mbrtowc(wchar_t * __restrict /*pwc*/,
N                   const char * __restrict /*s*/,
N                   size_t /*n*/, mbstate_t * __restrict /*ps*/);
N    size_t wcrtomb(char * __restrict /*s*/, wchar_t /*wc*/,
N                   mbstate_t * __restrict /*ps*/);
N    size_t mbsrtowcs(wchar_t * __restrict /*dst*/,
N                     const char ** __restrict /*src*/,
N                     size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t wcsrtombs(char * __restrict /*dst*/,
N                     const wchar_t ** __restrict /*src*/,
N                     size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t _mbsnrtowcs(wchar_t * __restrict /*dst*/,
N                       const char ** __restrict /*src*/,
N                       size_t /*nmb*/,
N                       size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t _wcsnrtombs(char * __restrict /*dst*/,
N                       const wchar_t ** __restrict /*src*/,
N                       size_t /*nwc*/,
N                       size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N#if !defined(__STRICT_ANSI__)
X#if !0L
N    size_t mbsnrtowcs(wchar_t * __restrict /*dst*/,
N                      const char ** __restrict /*src*/,
N                      size_t /*nmb*/,
N                      size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t wcsnrtombs(char * __restrict /*dst*/,
N                      const wchar_t ** __restrict /*src*/,
N                      size_t /*nwc*/,
N                      size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N#endif
N
N    /*
N     * Wide-character string-to-number conversions. Parallel to strto*.
N     */
N    double wcstod(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    float wcstof(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    long double wcstold(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    long int wcstol(const wchar_t * /*nptr*/, wchar_t **/*endptr*/,
N                    int /*base*/) __attribute__((__nonnull__(1)));
N    unsigned long int wcstoul(const wchar_t * /*nptr*/,
N                              wchar_t ** /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N    long long int wcstoll(const wchar_t * __restrict /*nptr*/,
N                          wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    unsigned long long int wcstoull(const wchar_t * __restrict /*nptr*/,
N                                    wchar_t ** __restrict /*endptr*/,
N                                    int /*base*/) __attribute__((__nonnull__(1)));
N#endif
N
N    /*
N     * General wide-character string utilities.
N     */
N    wchar_t *wcscpy(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcsncpy(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wmemcpy(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wmemmove(wchar_t * __restrict /*s1*/,
N                      const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcscat(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcsncat(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscmp(const wchar_t * __restrict /*s1*/,
N               const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    int wcsncmp(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscasecmp(const wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    int wcsncasecmp(const wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscoll(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    size_t wcsxfrm(wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N    int wmemcmp(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    size_t wcscspn(const wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    size_t wcsspn(const wchar_t * __restrict /*s1*/,
N                  const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcstok(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/,
N                    wchar_t ** __restrict /*ptr*/) __attribute__((__nonnull__(2,3)));
N    size_t wcslen(const wchar_t * __restrict /*s*/) __attribute__((__nonnull__(1)));
N    wchar_t *wmemset(wchar_t * __restrict /*s*/, wchar_t /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 1L && !0L
N    /*
N     * C++'s overloading allows us to provide versions of these
N     * functions which search a const string and return a const
N     * pointer into it, and separate versions which search a
N     * non-const string and return a non-const pointer.
N     */
N    const wchar_t *wcschr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
N    const wchar_t *wcspbrk(const wchar_t * __restrict /*s1*/,
N                           const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    const wchar_t *wcsrchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
N    const wchar_t *wcsstr(const wchar_t * __restrict /*s1*/,
N                          const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    const wchar_t *wmemchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/,
N                           size_t /*n*/) __attribute__((__nonnull__(1)));
N#ifndef __WCHAR_DISABLED
N    extern "C++" wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
N    extern "C++" inline wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c)
N      { return const_cast<wchar_t *>(wcschr(const_cast<const wchar_t *>(__s), __c)); }
N    extern "C++" wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
N    extern "C++" inline wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2)
N      { return const_cast<wchar_t *>(wcspbrk(const_cast<const wchar_t *>(__s1), __s2)); }
N    extern "C++" wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
N    extern "C++" inline wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c)
N      { return const_cast<wchar_t *>(wcsrchr(const_cast<const wchar_t *>(__s), __c)); }
N    extern "C++" wchar_t *wcsstr(wchar_t * __restrict __s1,
N                          const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
N    extern "C++" inline wchar_t *wcsstr(wchar_t * __restrict __s1,
N                          const wchar_t * __restrict __s2)
N      { return const_cast<wchar_t *>(wcsstr(const_cast<const wchar_t *>(__s1), __s2)); }
N    extern "C++" wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
N                                  size_t __n) __attribute__((__nonnull__(1)));
N    extern "C++" inline wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
N                                  size_t __n)
N    { return const_cast<wchar_t *>(wmemchr(const_cast<const wchar_t *>(__s), __c, __n)); }
N#endif
N#else
S    /*
S     * C's approximation to the above is to have all of these
S     * functions search a const string and return a non-const
S     * pointer. This is the only way to prevent compile errors in
S     * all sensible uses of the functions, but unfortunately
S     * renders them unable to spot a lot of the possible error
S     * cases.
S     */
S#if defined(__cplusplus) && defined(__ARMCOMPILER_LIBCXX)
S  }  /* extern "C" */
S  }  /* namespace std */
S  extern "C" {
S#endif
S    wchar_t *wcschr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
S    wchar_t *wcspbrk(const wchar_t * __restrict /*s1*/,
S                     const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S    wchar_t *wcsrchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
S    wchar_t *wcsstr(const wchar_t * __restrict /*s1*/,
S                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S    wchar_t *wmemchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/,
S                     __CLIBNS size_t /*n*/) __attribute__((__nonnull__(1)));
S#if defined(__cplusplus) && defined(__ARMCOMPILER_LIBCXX)
S  }  /* extern "C" */
S  namespace std {
S  extern "C" {
S#endif
N#endif
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __WCHAR_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
N    #ifndef __WCHAR_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::wint_t;
S      using ::std::mbstate_t;
S      using ::std::tm;
S      using ::std::wcsftime;
S    #ifndef __ARM_WCHAR_NO_IO
S      using ::std::swprintf;
S      using ::std::vswprintf;
S      using ::std::swscanf;
S      using ::std::vswscanf;
S      using ::std::fwprintf;
S      using ::std::vfwprintf;
S      using ::std::fwscanf;
S      using ::std::vfwscanf;
S      using ::std::wprintf;
S      using ::std::vwprintf;
S      using ::std::wscanf;
S      using ::std::vwscanf;
S      using ::std::fgetwc;
S      using ::std::fgetws;
S      using ::std::fputwc;
S      using ::std::fputws;
S      using ::std::fwide;
S      using ::std::getwc;
S      using ::std::getwchar;
S      using ::std::putwc;
S      using ::std::putwchar;
S      using ::std::ungetwc;
S      using ::std::btowc;
S    #endif /* __ARM_WCHAR_NO_IO */
S      using ::std::wctob;
S      using ::std::mbsinit;
S      using ::std::mbrlen;
S      using ::std::mbrtowc;
S      using ::std::wcrtomb;
S      using ::std::mbsrtowcs;
S      using ::std::wcsrtombs;
S      using ::std::_mbsnrtowcs;
S      using ::std::_wcsnrtombs;
S#if !defined(__STRICT_ANSI__)
S      using ::std::mbsnrtowcs;
S      using ::std::wcsnrtombs;
S#endif
S      using ::std::wcstod;
S      using ::std::wcstof;
S      using ::std::wcstold;
S      using ::std::wcstol;
S      using ::std::wcstoul;
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::wcstoll;
S      using ::std::wcstoull;
S#endif /* !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus) */
S      using ::std::wcscpy;
S      using ::std::wcsncpy;
S      using ::std::wmemcpy;
S      using ::std::wmemmove;
S      using ::std::wcscat;
S      using ::std::wcsncat;
S      using ::std::wcscmp;
S      using ::std::wcsncmp;
S      using ::std::wcscasecmp;
S      using ::std::wcsncasecmp;
S      using ::std::wcscoll;
S      using ::std::wcsxfrm;
S      using ::std::wmemcmp;
S#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
S      using ::std::wcschr;
S      using ::std::wcspbrk;
S      using ::std::wcsrchr;
S      using ::std::wcsstr;
S      using ::std::wmemchr;
S#endif /* defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX) */
S      using ::std::wcscspn;
S      using ::std::wcsspn;
S      using ::std::wcstok;
S      using ::std::wcslen;
S      using ::std::wmemset;
S#if !defined(__STRICT_ANSI__) && !defined(__ARM_WCHAR_NO_IO)
S      using ::std::FILE;
S#endif
N    #endif /* __WCHAR_NO_EXPORTS */
N  #endif /* __cplusplus */
N#endif /* ndef __wchar_h */
N
N/* end of wchar.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cwchar" 2
N  #undef __WCHAR_NO_EXPORTS
N
N  #undef __wchar_h  // later inclusion of wchar.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cwchar */
N
L 47 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\iosfwd" 2
N
N#  if defined (_RWSTD_NO_LIBC_IN_STD)
X#  if 0L
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
S// bring global mbstate_t into namespace std if it's not there yet
S_USING (::mbstate_t);
S
S_RWSTD_NAMESPACE_END   // std
S
N#  endif   // _RWSTD_NO_LIBC_IN_STD
N
N#else   // if defined (_RWSTD_NO_MBSTATE_T)
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
Sstruct mbstate_t
S{ 
S    mbstate_t () 
S        : _C_state (0) { }
S    
S    mbstate_t (const mbstate_t & __rhs) 
S        : _C_state(__rhs._C_state) { }
S    
S    mbstate_t& operator= (const mbstate_t &__rhs) {
S        if (&__rhs != this)
S            _C_state = __rhs._C_state;              
S        return *this;
S    }
S
S    bool operator== (const mbstate_t &__rhs) const {
S        return _C_state == __rhs._C_state;
S    }
S
S    bool operator!= (const mbstate_t &__rhs) const {
S        return !(*this == __rhs);
S    }
S                   
S    long _C_state;                
S};
S
S_RWSTD_NAMESPACE_END   // std
S
N#endif // _RWSTD_NO_MBSTATE_T 
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _TypeT>
Nclass allocator;
N
Ntemplate<class _CharT>
Nstruct char_traits;
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct char_traits<char>;
N
N#ifndef _RWSTD_NO_WCHAR_T
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct char_traits<wchar_t>;
N
N#endif   // _RWSTD_NO_WCHAR_T
N
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ios;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_streambuf;
N
N// 27.2, p4
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_istream;
N
N// 27.2, p5
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ostream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>) > 
X         class _Allocator = allocator<_CharT> > 
Nclass basic_stringbuf;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>)  > 
X         class _Allocator = allocator<_CharT>  > 
Nclass basic_istringstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>) > 
X         class _Allocator = allocator<_CharT> > 
Nclass basic_ostringstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_filebuf;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ifstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ofstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) > 
X         class _Traits = char_traits<_CharT> > 
Nclass ostreambuf_iterator;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) > 
X         class _Traits = char_traits<_CharT> > 
Nclass istreambuf_iterator;
N
N// 27.2, p6
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_iostream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_fstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>)  > 
X         class _Allocator = allocator<_CharT>  > 
Nclass basic_stringstream;
N
N
N#ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N
Ntypedef basic_ios<char>                                    ios;
Ntypedef basic_streambuf<char>                              streambuf;
Ntypedef basic_istream<char>                                istream;
Ntypedef basic_ostream<char>                                ostream;
Ntypedef basic_stringbuf<char>                              stringbuf;
Ntypedef basic_istringstream<char>                          istringstream;
Ntypedef basic_ostringstream<char>                          ostringstream;
Ntypedef basic_filebuf<char>                                filebuf;
Ntypedef basic_ifstream<char>                               ifstream;
Ntypedef basic_ofstream<char>                               ofstream;
Ntypedef basic_fstream<char>                                fstream;
Ntypedef basic_iostream<char>                               iostream;
Ntypedef basic_stringstream<char>                           stringstream;
N
N#ifndef _RWSTD_NO_WCHAR_T
N
Ntypedef basic_ios<wchar_t>                                 wios;
Ntypedef basic_streambuf<wchar_t>                           wstreambuf;
Ntypedef basic_istream<wchar_t>                             wistream;
Ntypedef basic_ostream<wchar_t>                             wostream;
Ntypedef basic_stringbuf<wchar_t>                           wstringbuf;
Ntypedef basic_istringstream<wchar_t>                       wistringstream;
Ntypedef basic_ostringstream<wchar_t>                       wostringstream;
Ntypedef basic_filebuf<wchar_t>                             wfilebuf;
Ntypedef basic_ifstream<wchar_t>                            wifstream;
Ntypedef basic_ofstream<wchar_t>                            wofstream;
Ntypedef basic_fstream<wchar_t>                             wfstream;
Ntypedef basic_iostream<wchar_t>                            wiostream;
Ntypedef basic_stringstream<wchar_t>                        wstringstream;
N
N#endif // _RWSTD_NO_WCHAR_T
N
N#else
S
Stypedef basic_ios<char, char_traits<char> >                ios;
Stypedef basic_streambuf<char, char_traits<char> >          streambuf;
Stypedef basic_istream<char, char_traits<char> >            istream;
Stypedef basic_ostream<char, char_traits<char> >            ostream;
Stypedef basic_stringbuf<char, char_traits<char>, allocator<char> >
S        stringbuf;
Stypedef basic_istringstream<char, char_traits<char>, allocator<char> >
S        istringstream;
Stypedef basic_ostringstream<char, char_traits<char>, allocator<char> >
S        ostringstream;
Stypedef basic_filebuf<char, char_traits<char> >            filebuf;
Stypedef basic_ifstream<char, char_traits<char> >           ifstream;
Stypedef basic_ofstream<char, char_traits<char> >           ofstream;
Stypedef basic_fstream<char, char_traits<char> >            fstream;
Stypedef basic_iostream<char, char_traits<char> >           iostream;
Stypedef basic_stringstream<char, char_traits<char>, allocator<char> >
S        stringstream;
S
S#ifndef _RWSTD_NO_WCHAR_T
S
Stypedef basic_ios<wchar_t, char_traits<wchar_t> >          wios;
Stypedef basic_streambuf<wchar_t, char_traits<wchar_t> >    wstreambuf;
Stypedef basic_istream<wchar_t, char_traits<wchar_t> >      wistream;
Stypedef basic_ostream<wchar_t, char_traits<wchar_t> >      wostream;
Stypedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
S        wstringbuf;
Stypedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
S        wistringstream;
Stypedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
S        wostringstream;
Stypedef basic_filebuf<wchar_t, char_traits<wchar_t> >      wfilebuf;
Stypedef basic_ifstream<wchar_t, char_traits<wchar_t> >     wifstream;
Stypedef basic_ofstream<wchar_t, char_traits<wchar_t> >     wofstream;
Stypedef basic_fstream<wchar_t,char_traits<wchar_t> >       wfstream;
Stypedef basic_iostream<wchar_t, char_traits<wchar_t> >     wiostream;
Stypedef basic_stringstream<wchar_t,char_traits<wchar_t>, allocator<wchar_t> >
S        wstringstream;
S
S#endif // _RWSTD_NO_WCHAR_T
N#endif // _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N
N
N// 27.2, p8
Ntemplate <class _StateT>
Nclass fpos;
N
N// 27.2, p9 - identical to std::fpos<char_traits<char>::state_type>
N//            and std::fpos<char_traits<wchar_t>::state_type>, respectively
Ntypedef fpos<mbstate_t>                                    streampos;
Ntypedef fpos<mbstate_t>                                    wstreampos;
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_IOSFWD_INCLUDED
N
L 37 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\bitset" 2
N#include <string>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * <string> - definition of the C++ Standard Library basic_string template
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_STRING_INCLUDED
N#define _RWSTD_STRING_INCLUDED
N
N#include <iosfwd>
N#include <limits>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * limits - Declarations for the C++ Standard Library class numeric_limits
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_LIMITS_INCLUDED
N#define _RWSTD_LIMITS_INCLUDED
N
N#include <rw/_defs.h>
N#include <rw/_math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_math.h" 1
N/***************************************************************************
N *
N * _math.h - Standard Library vs math.h exception conflict hack.
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_MATH_H_INCLUDED
N#define _RWSTD_MATH_H_INCLUDED
N
N#include <rw/_defs.h>
N
N// avoid a conflicting exception structure on platforms where
N// struct exception is defined unguarded in <math.h>
N#ifndef _RWSTD_NO_MATH_EXCEPTION
S#  undef exception
S#  define exception math_exception
N#endif   // _RWSTD_NO_MATH_EXCEPTION
N
N#include _RWSTD_CMATH
X#include <cmath>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cmath" 1
N/*
N * C++ header for C header math.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cmath
N#define __cmath
N#define __ARMCLIB_VERSION 5060037
N
N  #define __MATH_NO_EXPORTS 1
N  #include <math.h>
N  #undef __MATH_NO_EXPORTS 
N
N  #undef __math_h  // later inclusion of math.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __cmath */
N
N/* end of cmath */
N
L 47 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_math.h" 2
N
N#undef exception
N
N// MSVC provides its own complex macro
N#ifdef _MSC_VER
S#  ifdef complex
S#    undef complex
S#  endif
N#endif
N
N
N#endif   // _RWSTD_MATH_H_INCLUDED
N
L 37 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N
N#include _RWSTD_CFLOAT
X#include <cfloat>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cfloat" 1
N/*
N * C++ header for C header float.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cfloat
N#define __cfloat
N#define __ARMCLIB_VERSION 5060037
N
N  #define __FLOAT_NO_EXPORTS 1
N  #include <float.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\float.h" 1
N/* float.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd, 1988                             */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.01 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __float_h
N#define __float_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __FLOAT_DECLS
N  #define __FLOAT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N      #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* IEEE version: the following values are taken from the above ANSI draft.  */
N/* The ACORN FPE (v17) is known not to precisely implement IEEE arithmetic. */
N
N#define FLT_RADIX     2
N    /* radix of exponent representation */
N#ifdef __FP_FENV_ROUNDING
Sextern unsigned __ieee_status(unsigned,unsigned); /* from fenv.h */
S#define FLT_ROUNDS ((1+(__CLIBNS __ieee_status(0, 0)>>22))&3)
N#else
N#define FLT_ROUNDS    1
N#endif
N    /*
N     * The rounding mode for floating-point addition is characterised by the
N     * value of FLT_ROUNDS:
N     *  -1 : indeterminable.
N     *   0 : towards zero.
N     *   1 : to nearest.
N     *   2 : towards positive infinity.
N     *   3 : towards negative infinity.
N     *   ? : any other is implementation-defined.
N     */
N
N#define FLT_MANT_DIG        24
N#define DBL_MANT_DIG        53
N#define LDBL_MANT_DIG       53
N    /* number of base-FLT_RADIX digits in the floating point mantissa */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N#define DECIMAL_DIG 17
N    /* number of decimal digits that the widest floating point type
N       can be rounded to and back again without changing the value */
N#ifdef __FP_FAST
S#  define FLT_EVAL_METHOD (-1)
N#else
N#  define FLT_EVAL_METHOD 0
N#endif
N    /*
N     * The use of evaluation formats is characterized by the value of
N     * FLT_EVAL_METHOD:
N     *  -1 : indeterminable.
N     *   0 : evaluate all operations and constants just to the range
N     *       and precision of the type.
N     *   1 : evaluate operations and constants of type float and
N     *       double to the range and precision of the double type,
N     *       evaluate long double operations and constants to the
N     *       range and precision of the long double type.
N     *   2 : evaluate all opertations and constants to the range and
N     *       precision of the long double type.
N     */
N#endif
N
N/* The values that follow are not achieved under Acorn's FPE version 17  */
N/* but they should be correct in due course!                             */
N
N#define FLT_DIG      6
N#define DBL_DIG      15
N#define LDBL_DIG     15
N    /* number of decimal digits of precision */
N
N#define FLT_MIN_EXP  (-125)
N#define DBL_MIN_EXP  (-1021)
N#define LDBL_MIN_EXP (-1021)
N    /* minimum negative integer such that FLT_RADIX raised to that power */
N    /* minus 1 is a normalised floating-point number. */
N
N#define FLT_MIN_10_EXP  (-37)
N#define DBL_MIN_10_EXP  (-307)
N#define LDBL_MIN_10_EXP (-307)
N    /* minimum negative integer such that 10 raised to that power is in the */
N    /* range of normalised floating-point numbers. */
N
N#define FLT_MAX_EXP  128
N#define DBL_MAX_EXP  1024
N#define LDBL_MAX_EXP 1024
N    /* maximum integer such that FLT_RADIX raised to that power minus 1 is a */
N#define FLT_MAX_10_EXP  38
N#define DBL_MAX_10_EXP  308
N#define LDBL_MAX_10_EXP 308
N    /* maximum integer such that 10 raised to that power is in the range of */
N    /* representable finite floating-point numbers. */
N
N#define FLT_MAX  3.40282347e+38F
N#define DBL_MAX  1.79769313486231571e+308
N#define LDBL_MAX 1.79769313486231571e+308L
N    /* maximum representable finite floating-point number. */
N
N#define FLT_EPSILON         1.19209290e-7F
N#define DBL_EPSILON         2.2204460492503131e-16
N#define LDBL_EPSILON        2.2204460492503131e-16L
N    /* minimum positive floating point number x such that 1.0 + x != 1.0 */
N
N#define FLT_MIN  1.175494351e-38F
N#define DBL_MIN  2.22507385850720138e-308
N#define LDBL_MIN 2.22507385850720138e-308L
N    /* minimum normalised positive floating-point number. */
N
N/*
N * The Microsoft <float.h> extensions.
N */
N#ifdef __cplusplus
Nextern "C" {
N#endif
Nunsigned _controlfp(unsigned, unsigned);
Nunsigned _clearfp(void);
Nunsigned _statusfp(void);
N#ifdef __cplusplus
N}
N#endif
N
N
N/*
N * Because the _EM_ constants are shared between _controlfp (masks)
N * and _statusfp (sticky bits), we adopt the convention that
N * _controlfp will shift its arguments left by 8 bits before using
N * them.
N */
N
N#define _MCW_EM         0x001F
N#define _EM_INVALID     0x0001
N#define _EM_ZERODIVIDE  0x0002
N#define _EM_OVERFLOW    0x0004
N#define _EM_UNDERFLOW   0x0008
N#define _EM_INEXACT     0x0010
N
N#define _MCW_RC         0xC000
N#define _RC_CHOP        0xC000
N#define _RC_UP          0x4000
N#define _RC_DOWN        0x8000
N#define _RC_NEAR        0x0000
N
N/*
N * _FPE_ constants passed as the hidden second argument to SIGFPE
N * handlers.
N */
N#define _FPE_INVALID     0x04000000
N#define _FPE_ZERODIVIDE  0x08000000
N#define _FPE_OVERFLOW    0x10000000
N#define _FPE_UNDERFLOW   0x20000000
N#define _FPE_INEXACT     0x40000000
N
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __FLOAT_DECLS */
N
N  #if defined(__cplusplus) && !defined(__FLOAT_NO_EXPORTS)
X  #if 1L && !1L
S    using ::std::_controlfp;
S    using ::std::_clearfp;
S    using ::std::_statusfp;
N  #endif
N
N#endif /* __float_h */
N
N/* end of float.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cfloat" 2
N  #undef __FLOAT_NO_EXPORTS
N
N  #undef __float_h  // later inclusion of float.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif
N
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N#include _RWSTD_CLIMITS
X#include <climits>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\climits" 1
N/*
N * C++ header for C header limits.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __climits
N#define __climits
N#define __ARMCLIB_VERSION 5060037
N
N#include <limits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060037
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 17 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\climits" 2
N
N#endif
N
L 40 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N#include _RWSTD_IEEEFP
X#include <rw/_defs.h>
N
N
N/**************************************************************************
N *
N * Assumptions made in this implementation:
N *
N *   1) numeric_limits<T>::digits is 1 for bool and is computed as
N *      (CHAR_BIT * sizeof (T) - numeric_limits<T>::is_signed for
N *      all native integral T
N *
N *   2) numeric_limits<T>::radix is the same (2 by default) for all
N *      specializations of native integral T
N *
N *   3) numeric_limits<T>::is_modulo is true if numeric_limits<T>::max()
N *      + 1 == numeric_limits<T>::min for all specializations
N *      of native integral T
N *
N *   4) numeric_limts<T>::traps == false for all native integral T
N *
N *   5) OEM vendors are expected to provide correct values where supplied
N *      values (VENDOR) differ from those defined by the implementation
N *
N **************************************************************************/
N
N#define _RWSTD_HAS_INFINITY true  // VENDOR
N#define _RWSTD_HAS_QUIET_NAN true // VENDOR
N
N#ifdef __FP_IEEE
S  #define _RWSTD_IS_IEC559 true // VENDOR
S  #define _RWSTD_HAS_DENORM_LOSS true // VENDOR
S  #define _RWSTD_HAS_DENORM      denorm_present // VENDOR
S  #define _RWSTD_FLT_DENORM_MIN  1.4012984643248171e-45F   // VENDOR
S  #define _RWSTD_DBL_DENORM_MIN  4.9406564584124654e-324   // VENDOR
S  #define _RWSTD_LDBL_DENORM_MIN 4.9406564584124654e-324L  // VENDOR
N#else
N  #define _RWSTD_IS_IEC559 false // VENDOR
N  #define _RWSTD_HAS_DENORM_LOSS false // VENDOR
N  #define _RWSTD_HAS_DENORM      denorm_absent // VENDOR
N  #define _RWSTD_FLT_DENORM_MIN  FLT_MIN   // VENDOR
N  #define _RWSTD_DBL_DENORM_MIN  DBL_MIN    // VENDOR
N  #define _RWSTD_LDBL_DENORM_MIN LDBL_MIN  // VENDOR
N#endif
N
N#ifdef __FP_FENV_ROUNDING
S  /* We only include the relevant parts of fenv.h to avoid polluting the user's
S   * namespace.
S  #include <fenv.h>
S  */
S  extern "C" unsigned __ieee_status(unsigned, unsigned);
S  #define __FE_IEEE_ROUND_MASK         (0x00C00000)
S  #define __FE_IEEE_ROUND_TONEAREST    (0x00000000)
S  /* end of <fenv.h> */
S  // rounding can be changed at runtime
S  #define _RWSTD_ROUND_TONEAREST ((__ieee_status(0,0) & __FE_IEEE_ROUND_MASK) == __FE_IEEE_ROUND_TONEAREST)
S  #define _RWSTD_FLT_ROUND_ERROR  (_RWSTD_ROUND_TONEAREST ? 0.5F : 1.0F)
S  #define _RWSTD_DBL_ROUND_ERROR  (_RWSTD_ROUND_TONEAREST ? 0.5  : 1.0)
S  #define _RWSTD_LDBL_ROUND_ERROR (_RWSTD_ROUND_TONEAREST ? 0.5L : 1.0L)
N#else
N  // rounding is fixed to round to nearest
N  #define _RWSTD_FLT_ROUND_ERROR  0.5F
N  #define _RWSTD_DBL_ROUND_ERROR  0.5
N  #define _RWSTD_LDBL_ROUND_ERROR 0.5L
N#endif
N
N// signalling NAN
N#define _RWSTD_HAS_SIG_NAN true // VENDOR
N
N#undef _RWSTD_STATIC_INIT
N#undef _RWSTD_STATIC_DEF
N
N
N#ifndef _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N#  ifndef _RWSTD_DEFINE_EXPORTS
N#    define _RWSTD_STATIC_INIT(name, value)   name = (value)
N#  else
S#    define _RWSTD_STATIC_INIT(name, value)   name
N#  endif
N#else
S#  ifndef _RWSTD_DEFINE_EXPORTS
S#    define _RWSTD_STATIC_INIT(name, value)   name
S#  else
S#    define _RWSTD_STATIC_INIT(name, value)   name = (value)
S#  endif
N#endif   // _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N
N
N#undef _RWSTD_CLASS_BEGIN
N#undef _RWSTD_CLASS_END
N#undef _RWSTD_TYPEDEF
N#undef _RWSTD_STATIC
N#undef _RWSTD_STATIC_ROUNDS
N#undef _RWSTD_STATIC_FUN
N
N
N#ifndef _RWSTD_DEFINE_EXPORTS
N
N// declarations - expanded in every translation unit
N// that #includes <limits>
N
N#  define _RWSTD_CLASS_BEGIN(name) name { public: 
N#  define _RWSTD_CLASS_END              };
N#  define _RWSTD_TYPEDEF(def)           typedef def;
N#  define _RWSTD_STATIC(ignore, type, name, value)            \
N          static const type            \
N              _RWSTD_STATIC_INIT (name, value)
X#  define _RWSTD_STATIC(ignore, type, name, value)                      static const type                          _RWSTD_STATIC_INIT (name, value)
N
N#  ifndef _RWSTD_NO_CONST_FLT_ROUNDS
S#    define _RWSTD_STATIC_ROUNDS(ignore, type, name, value)   \
S            _RWSTD_STATIC (ignore, type, name,                \
S                           _RWSTD_STATIC_CAST (float_round_style, value))
X#    define _RWSTD_STATIC_ROUNDS(ignore, type, name, value)               _RWSTD_STATIC (ignore, type, name,                                           _RWSTD_STATIC_CAST (float_round_style, value))
N#  else
N#    define _RWSTD_STATIC_ROUNDS(ign1, type, name, ign2)      \
N            static const type _RWSTD_EXPORT name
X#    define _RWSTD_STATIC_ROUNDS(ign1, type, name, ign2)                  static const type _RWSTD_EXPORT name
N#  endif   // _RWSTD_NO_CONST_FLT_ROUNDS
N
N#  define _RWSTD_STATIC_FUN(type, name, value)                \
N          static type name () _THROWS (()) { return value; }
X#  define _RWSTD_STATIC_FUN(type, name, value)                          static type name () _THROWS (()) { return value; }
N
N#else   // defined (_RWSTD_DEFINE_EXPORTS)
S
S// definitions - expanded in a single translation unit that defines
S// static const data members outside of each numeric_limits<> specialization
S
S#  define _RWSTD_CLASS_BEGIN(ignore)
S#  define _RWSTD_CLASS_END
S#  define _RWSTD_TYPEDEF(ignore)
S#  define _RWSTD_STATIC(limtype, type, name, value)           \
S          const type _RWSTD_STATIC_INIT (numeric_limits<limtype>::name, value)
X#  define _RWSTD_STATIC(limtype, type, name, value)                     const type _RWSTD_STATIC_INIT (numeric_limits<limtype>::name, value)
S
S#  ifndef _RWSTD_NO_CONST_FLT_ROUNDS
S#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)  \
S            _RWSTD_STATIC (limtype, type, name,               \
S                           _RWSTD_STATIC_CAST (float_round_style, value))
X#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)              _RWSTD_STATIC (limtype, type, name,                                          _RWSTD_STATIC_CAST (float_round_style, value))
S#  else
S#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)  \
S            const type numeric_limits<limtype>::name =        \
S                           _RWSTD_STATIC_CAST (float_round_style, value)
X#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)              const type numeric_limits<limtype>::name =                                   _RWSTD_STATIC_CAST (float_round_style, value)
S#  endif   // _RWSTD_NO_CONST_FLT_ROUNDS
S
S#  define _RWSTD_STATIC_FUN(ign1, ign2, ign3)
S#  define _RWSTD_STATIC_FUN_HEXFLOAT(ign1, ign2, ign3)
S#  define _RWSTD_STATIC_FUN_HEXDOUBLE(ign1, ign2, ign3, ign4)
S
N#endif   // _RWSTD_DEFINE_EXPORTS
N
N
N// 18.2.1.2, p6 - 7
N#define _RWSTD_DIGITS(type, min, max) \
N        (1 == (max) ? 1 : (CHAR_BIT * sizeof (type) - ((min) != 0)))
X#define _RWSTD_DIGITS(type, min, max)         (1 == (max) ? 1 : (CHAR_BIT * sizeof (type) - ((min) != 0)))
N
N// 18.2.1.2, p9
N#define _RWSTD_DIGITS10(digits)   (((digits) * 301) / 1000)
N
N
N#undef max
N#undef min
N
N
N#undef _RWSTD_LIMITS_BODY
N
N#define _RWSTD_LIMITS_BODY(type, conv_type, cpfx)                           \
N    _RWSTD_STATIC (type, bool, is_specialized, true);                       \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, min, cpfx##_MIN)                               \
N    _RWSTD_STATIC_FUN (type, max, cpfx##_MAX)                               \
N                                                                            \
N    _RWSTD_STATIC (type, bool, is_signed,  cpfx##_MIN != 0);                \
N    _RWSTD_STATIC (type, bool, is_integer, true);                           \
N    _RWSTD_STATIC (type, bool, is_exact,   true);                           \
N                                                                            \
N    _RWSTD_STATIC (type, int, digits,                                       \
N                   _RWSTD_DIGITS (type, cpfx##_MIN, cpfx##_MAX));           \
N                                                                            \
N    /* spelled out to work around a bug in IBM xlC 5.0 */                   \
N    _RWSTD_STATIC (type, int, digits10,                                     \
N                   _RWSTD_DIGITS10 (_RWSTD_DIGITS (type, cpfx##_MIN,        \
N                                                         cpfx##_MAX)));     \
N                                                                            \
N    _RWSTD_STATIC (type, int, radix, 2);   /* VENDOR */                     \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, epsilon,     0)                                \
N    _RWSTD_STATIC_FUN (type, round_error, 0)                                \
N                                                                            \
N    _RWSTD_STATIC (type, int, min_exponent,   0);                           \
N    _RWSTD_STATIC (type, int, min_exponent10, 0);                           \
N    _RWSTD_STATIC (type, int, max_exponent,   0);                           \
N    _RWSTD_STATIC (type, int, max_exponent10, 0);                           \
N                                                                            \
N    _RWSTD_STATIC (type, bool, has_infinity,             false);            \
N    _RWSTD_STATIC (type, bool, has_quiet_NaN,            false);            \
N    _RWSTD_STATIC (type, bool, has_signaling_NaN,        false);            \
N    _RWSTD_STATIC (type, float_denorm_style, has_denorm, denorm_absent);    \
N    _RWSTD_STATIC (type, bool, has_denorm_loss,          false);            \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, infinity,      0)                              \
N    _RWSTD_STATIC_FUN (type, quiet_NaN,     0)                              \
N    _RWSTD_STATIC_FUN (type, signaling_NaN, 0)                              \
N    _RWSTD_STATIC_FUN (type, denorm_min,    0)                              \
N                                                                            \
N    _RWSTD_STATIC (type, bool, is_iec559,  false);                          \
N    _RWSTD_STATIC (type, bool, is_bounded, true);                           \
N    _RWSTD_STATIC (type, bool, is_modulo,  1 != cpfx##_MAX);                \
N                                                                            \
N    _RWSTD_STATIC (type, bool, traps,           false);                     \
N    _RWSTD_STATIC (type, bool, tinyness_before, false);                     \
N    _RWSTD_STATIC (type, float_round_style, round_style, round_toward_zero);\
N                                                                            \
N    /* extension: type converts to without loss of data */                  \
N    _RWSTD_TYPEDEF (conv_type _C_convertible)
X#define _RWSTD_LIMITS_BODY(type, conv_type, cpfx)                               _RWSTD_STATIC (type, bool, is_specialized, true);                                                                                                       _RWSTD_STATIC_FUN (type, min, cpfx##_MIN)                                   _RWSTD_STATIC_FUN (type, max, cpfx##_MAX)                                                                                                               _RWSTD_STATIC (type, bool, is_signed,  cpfx##_MIN != 0);                    _RWSTD_STATIC (type, bool, is_integer, true);                               _RWSTD_STATIC (type, bool, is_exact,   true);                                                                                                           _RWSTD_STATIC (type, int, digits,                                                          _RWSTD_DIGITS (type, cpfx##_MIN, cpfx##_MAX));                                                                                                                   _RWSTD_STATIC (type, int, digits10,                                                        _RWSTD_DIGITS10 (_RWSTD_DIGITS (type, cpfx##_MIN,                                                                 cpfx##_MAX)));                                                                                     _RWSTD_STATIC (type, int, radix, 2);                                                                                                         _RWSTD_STATIC_FUN (type, epsilon,     0)                                    _RWSTD_STATIC_FUN (type, round_error, 0)                                                                                                                _RWSTD_STATIC (type, int, min_exponent,   0);                               _RWSTD_STATIC (type, int, min_exponent10, 0);                               _RWSTD_STATIC (type, int, max_exponent,   0);                               _RWSTD_STATIC (type, int, max_exponent10, 0);                                                                                                           _RWSTD_STATIC (type, bool, has_infinity,             false);                _RWSTD_STATIC (type, bool, has_quiet_NaN,            false);                _RWSTD_STATIC (type, bool, has_signaling_NaN,        false);                _RWSTD_STATIC (type, float_denorm_style, has_denorm, denorm_absent);        _RWSTD_STATIC (type, bool, has_denorm_loss,          false);                                                                                            _RWSTD_STATIC_FUN (type, infinity,      0)                                  _RWSTD_STATIC_FUN (type, quiet_NaN,     0)                                  _RWSTD_STATIC_FUN (type, signaling_NaN, 0)                                  _RWSTD_STATIC_FUN (type, denorm_min,    0)                                                                                                              _RWSTD_STATIC (type, bool, is_iec559,  false);                              _RWSTD_STATIC (type, bool, is_bounded, true);                               _RWSTD_STATIC (type, bool, is_modulo,  1 != cpfx##_MAX);                                                                                                _RWSTD_STATIC (type, bool, traps,           false);                         _RWSTD_STATIC (type, bool, tinyness_before, false);                         _RWSTD_STATIC (type, float_round_style, round_style, round_toward_zero);                                                                                                       _RWSTD_TYPEDEF (conv_type _C_convertible)
N
N
N#undef _RWSTD_SPECIALIZE_LIMITS
N
N#define _RWSTD_SPECIALIZE_LIMITS(type, conv_type, cpfx)      \
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS                 \
N                    class _RWSTD_EXPORT numeric_limits<type>) \
N    _RWSTD_LIMITS_BODY (type, conv_type, cpfx)               \
N_RWSTD_CLASS_END
X#define _RWSTD_SPECIALIZE_LIMITS(type, conv_type, cpfx)      _RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS                                     class _RWSTD_EXPORT numeric_limits<type>)     _RWSTD_LIMITS_BODY (type, conv_type, cpfx)               _RWSTD_CLASS_END
N
N
N#ifndef _RWSTD_LIMITS_TEMPLATE_DEFINED
N#define _RWSTD_LIMITS_TEMPLATE_DEFINED
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Nenum float_round_style
N{
N    round_indeterminate       = -1,
N    round_toward_zero         =  0,
N    round_to_nearest          =  1,
N    round_toward_infinity     =  2,
N    round_toward_neg_infinity =  3
N};
N
Nenum float_denorm_style
N{
N    denorm_indeterminate = -1,
N    denorm_absent        =  0,
N    denorm_present       =  1
N};
N
Ntemplate <class _TypeT>
Nclass numeric_limits
N{
Npublic:
N    // static consts below must be initialized in class so that
N    // they can be used where const expressions are required (such
N    // as in template parameters)
N
N    _RWSTD_STATIC_CONST (bool, is_specialized = false);
X    static const bool is_specialized = false;
N
N    static _TypeT min () _THROWS (()) { return 0; }
X    static _TypeT min ()  { return 0; }
N    static _TypeT max () _THROWS (()) { return 0; }
X    static _TypeT max ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (int, digits   = 0);
X    static const int digits = 0;
N    _RWSTD_STATIC_CONST (int, digits10 = 0);
X    static const int digits10 = 0;
N
N    _RWSTD_STATIC_CONST (bool, is_signed  = false);
X    static const bool is_signed = false;
N    _RWSTD_STATIC_CONST (bool, is_integer = false);
X    static const bool is_integer = false;
N    _RWSTD_STATIC_CONST (bool, is_exact   = false);
X    static const bool is_exact = false;
N
N    _RWSTD_STATIC_CONST (int, radix = 0);
X    static const int radix = 0;
N
N    static _TypeT epsilon () _THROWS (()) { return 0; }
X    static _TypeT epsilon ()  { return 0; }
N    static _TypeT round_error () _THROWS (()) { return 0; }
X    static _TypeT round_error ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (int, min_exponent   = 0);
X    static const int min_exponent = 0;
N    _RWSTD_STATIC_CONST (int, min_exponent10 = 0);
X    static const int min_exponent10 = 0;
N    _RWSTD_STATIC_CONST (int, max_exponent   = 0);
X    static const int max_exponent = 0;
N    _RWSTD_STATIC_CONST (int, max_exponent10 = 0);
X    static const int max_exponent10 = 0;
N
N    _RWSTD_STATIC_CONST (bool, has_infinity             = false);
X    static const bool has_infinity = false;
N    _RWSTD_STATIC_CONST (bool, has_quiet_NaN            = false);
X    static const bool has_quiet_NaN = false;
N    _RWSTD_STATIC_CONST (bool, has_signaling_NaN        = false);
X    static const bool has_signaling_NaN = false;
N    _RWSTD_STATIC_CONST (float_denorm_style, has_denorm = denorm_absent);
X    static const float_denorm_style has_denorm = denorm_absent;
N    _RWSTD_STATIC_CONST (bool, has_denorm_loss          = false);
X    static const bool has_denorm_loss = false;
N
N    static _TypeT infinity () _THROWS (()) { return 0; }
X    static _TypeT infinity ()  { return 0; }
N    static _TypeT quiet_NaN () _THROWS (()) { return 0; }
X    static _TypeT quiet_NaN ()  { return 0; }
N    static _TypeT signaling_NaN () _THROWS (()) { return 0; }
X    static _TypeT signaling_NaN ()  { return 0; }
N    static _TypeT denorm_min () _THROWS (()) { return 0; }
X    static _TypeT denorm_min ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (bool, is_iec559        = false);
X    static const bool is_iec559 = false;
N    _RWSTD_STATIC_CONST (bool, is_bounded       = false);
X    static const bool is_bounded = false;
N    _RWSTD_STATIC_CONST (bool, is_modulo        = false);
X    static const bool is_modulo = false;
N    _RWSTD_STATIC_CONST (bool, traps            = false);
X    static const bool traps = false;
N    _RWSTD_STATIC_CONST (bool, tinyness_before  = false);
X    static const bool tinyness_before = false;
N    _RWSTD_STATIC_CONST (float_round_style, round_style = round_toward_zero);
X    static const float_round_style round_style = round_toward_zero;
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_LIMITS_TEMPLATE_DEFINED
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<float>)
Xtemplate< > class numeric_limits<float> { public:
N
N    _RWSTD_STATIC (float, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (float, min, FLT_MIN)
X    static float min ()  { return 1.175494351e-38F; }
N    _RWSTD_STATIC_FUN (float, max, FLT_MAX)
X    static float max ()  { return 3.40282347e+38F; }
N
N    _RWSTD_STATIC (float, int, digits,   FLT_MANT_DIG);
X    static const int digits = (24);
N    _RWSTD_STATIC (float, int, digits10, FLT_DIG);
X    static const int digits10 = (6);
N
N    _RWSTD_STATIC (float, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (float, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (float, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (float, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (float, epsilon,     FLT_EPSILON)
X    static float epsilon ()  { return 1.19209290e-7F; }
N    _RWSTD_STATIC_FUN (float, round_error, _RWSTD_FLT_ROUND_ERROR)
X    static float round_error ()  { return 0.5F; }
N
N    _RWSTD_STATIC (float, int, min_exponent,   FLT_MIN_EXP);
X    static const int min_exponent = ((-125));
N    _RWSTD_STATIC (float, int, min_exponent10, FLT_MIN_10_EXP);
X    static const int min_exponent10 = ((-37));
N    _RWSTD_STATIC (float, int, max_exponent,   FLT_MAX_EXP);
X    static const int max_exponent = (128);
N    _RWSTD_STATIC (float, int, max_exponent10, FLT_MAX_10_EXP);
X    static const int max_exponent10 = (38);
N
N    _RWSTD_STATIC (float, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (float, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (float, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (float, float_denorm_style, has_denorm,
N                   _RWSTD_HAS_DENORM);
X    static const float_denorm_style has_denorm = (denorm_absent);
N    _RWSTD_STATIC (float, bool, has_denorm_loss, _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#ifndef __has_builtin
S  #define __has_builtin(x) 0
N#endif
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (float, infinity,      __builtin_inff()) // VENDOR
S    _RWSTD_STATIC_FUN (float, quiet_NaN,     __builtin_nanf("")) // VENDOR
S    _RWSTD_STATIC_FUN (float, signaling_NaN, __builtin_nansf("")) // VENDOR
N#else
N    _RWSTD_STATIC_FUN (float, infinity,      __ESCAPE__(0f_7F800000)) // VENDOR
X    static float infinity ()  { return __ESCAPE__(0f_7F800000); } 
N    _RWSTD_STATIC_FUN (float, quiet_NaN,     __ESCAPE__(0f_7FC00000)) // VENDOR
X    static float quiet_NaN ()  { return __ESCAPE__(0f_7FC00000); } 
N    _RWSTD_STATIC_FUN (float, signaling_NaN, __ESCAPE__(0f_7F800001)) // VENDOR
X    static float signaling_NaN ()  { return __ESCAPE__(0f_7F800001); } 
N#endif
N    _RWSTD_STATIC_FUN (float, denorm_min,    _RWSTD_FLT_DENORM_MIN) // VENDOR
X    static float denorm_min ()  { return 1.175494351e-38F; } 
N
N    _RWSTD_STATIC (float, bool, is_iec559,  _RWSTD_IS_IEC559);    // VENDOR
X    static const bool is_iec559 = (false);    
N    _RWSTD_STATIC (float, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (float, bool, is_modulo,  false);               // VENDOR
X    static const bool is_modulo = (false);               
N
N    _RWSTD_STATIC (float, bool, traps, true);                    // VENDOR
X    static const bool traps = (true);                    
N    _RWSTD_STATIC (float, bool, tinyness_before, false);          // VENDOR
X    static const bool tinyness_before = (false);          
N
N    _RWSTD_STATIC_ROUNDS (float, float_round_style, round_style, FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (double _C_convertible)
X    typedef double _C_convertible;
N
N_RWSTD_CLASS_END   // numeric_limits<float>
X};   
N
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<double>)
Xtemplate< > class numeric_limits<double> { public:
N
N    _RWSTD_STATIC (double, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (double, min, DBL_MIN)
X    static double min ()  { return 2.22507385850720138e-308; }
N    _RWSTD_STATIC_FUN (double, max, DBL_MAX)
X    static double max ()  { return 1.79769313486231571e+308; }
N
N    _RWSTD_STATIC (double, int, digits,   DBL_MANT_DIG);
X    static const int digits = (53);
N    _RWSTD_STATIC (double, int, digits10, DBL_DIG);
X    static const int digits10 = (15);
N
N    _RWSTD_STATIC (double, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (double, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (double, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (double, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (double, epsilon,     DBL_EPSILON)
X    static double epsilon ()  { return 2.2204460492503131e-16; }
N    _RWSTD_STATIC_FUN (double, round_error, _RWSTD_DBL_ROUND_ERROR)
X    static double round_error ()  { return 0.5; }
N
N    _RWSTD_STATIC (double, int, min_exponent,   DBL_MIN_EXP);
X    static const int min_exponent = ((-1021));
N    _RWSTD_STATIC (double, int, min_exponent10, DBL_MIN_10_EXP);
X    static const int min_exponent10 = ((-307));
N    _RWSTD_STATIC (double, int, max_exponent,   DBL_MAX_EXP);
X    static const int max_exponent = (1024);
N    _RWSTD_STATIC (double, int, max_exponent10, DBL_MAX_10_EXP);
X    static const int max_exponent10 = (308);
N
N    _RWSTD_STATIC (double, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (double, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (double, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (double, float_denorm_style, has_denorm,
N                   _RWSTD_HAS_DENORM);
X    static const float_denorm_style has_denorm = (denorm_absent);
N    _RWSTD_STATIC (double, bool, has_denorm_loss,   _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (double, infinity,      __builtin_inf())   // VENDOR
S    _RWSTD_STATIC_FUN (double, quiet_NaN,     __builtin_nan(""))   // VENDOR
S    _RWSTD_STATIC_FUN (double, signaling_NaN, __builtin_nans(""))   // VENDOR
N#else
N    _RWSTD_STATIC_FUN (double, infinity,      __ESCAPE__(0d_7FF0000000000000))   // VENDOR
X    static double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
N    _RWSTD_STATIC_FUN (double, quiet_NaN,     __ESCAPE__(0d_7FF8000000000000))   // VENDOR
X    static double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
N    _RWSTD_STATIC_FUN (double, signaling_NaN, __ESCAPE__(0d_7FF0000000000001))   // VENDOR
X    static double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   
N#endif
N    _RWSTD_STATIC_FUN (double, denorm_min,    _RWSTD_DBL_DENORM_MIN)
X    static double denorm_min ()  { return 2.22507385850720138e-308; }
N
N    _RWSTD_STATIC (double, bool, is_iec559,  _RWSTD_IS_IEC559);
X    static const bool is_iec559 = (false);
N    _RWSTD_STATIC (double, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (double, bool, is_modulo,  false);              // VENDOR
X    static const bool is_modulo = (false);              
N
N    _RWSTD_STATIC (double, bool, traps, true);                   // VENDOR
X    static const bool traps = (true);                   
N    _RWSTD_STATIC (double, bool, tinyness_before, false);         // VENDOR
X    static const bool tinyness_before = (false);         
N
N    _RWSTD_STATIC_ROUNDS (double, float_round_style, round_style, FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (long double _C_convertible)
X    typedef long double _C_convertible;
N
N_RWSTD_CLASS_END   // numeric_limits<double>
X};   
N
N
N#ifndef _RWSTD_NO_LONG_DOUBLE
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<long double>)
Xtemplate< > class numeric_limits<long double> { public:
N
N    _RWSTD_STATIC (long double, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (long double, min, LDBL_MIN) 
X    static long double min ()  { return 2.22507385850720138e-308L; } 
N    _RWSTD_STATIC_FUN (long double, max, LDBL_MAX) 
X    static long double max ()  { return 1.79769313486231571e+308L; } 
N
N    _RWSTD_STATIC (long double, int, digits,   LDBL_MANT_DIG);
X    static const int digits = (53);
N    _RWSTD_STATIC (long double, int, digits10, LDBL_DIG);
X    static const int digits10 = (15);
N
N    _RWSTD_STATIC (long double, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (long double, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (long double, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (long double, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (long double, epsilon,     LDBL_EPSILON) 
X    static long double epsilon ()  { return 2.2204460492503131e-16L; } 
N    _RWSTD_STATIC_FUN (long double, round_error, _RWSTD_LDBL_ROUND_ERROR)
X    static long double round_error ()  { return 0.5L; }
N
N    _RWSTD_STATIC (long double, int, min_exponent,   LDBL_MIN_EXP);
X    static const int min_exponent = ((-1021));
N    _RWSTD_STATIC (long double, int, min_exponent10, LDBL_MIN_10_EXP);
X    static const int min_exponent10 = ((-307));
N    _RWSTD_STATIC (long double, int, max_exponent,   LDBL_MAX_EXP);
X    static const int max_exponent = (1024);
N    _RWSTD_STATIC (long double, int, max_exponent10, LDBL_MAX_10_EXP);
X    static const int max_exponent10 = (308);
N
N    _RWSTD_STATIC (long double, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (long double, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (long double, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (long double, float_denorm_style, has_denorm,
N                   denorm_indeterminate);
X    static const float_denorm_style has_denorm = (denorm_indeterminate);
N    _RWSTD_STATIC (long double, bool, has_denorm_loss, _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (long double, infinity,      __builtin_inf())   // VENDOR
S    _RWSTD_STATIC_FUN (long double, quiet_NaN,     __builtin_nan(""))   // VENDOR
S    _RWSTD_STATIC_FUN (long double, signaling_NaN, __builtin_nans(""))   // VENDOR
N#else
N    _RWSTD_STATIC_FUN (long double, infinity,      __ESCAPE__(0d_7FF0000000000000))   // VENDOR
X    static long double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
N    _RWSTD_STATIC_FUN (long double, quiet_NaN,     __ESCAPE__(0d_7FF8000000000000))   // VENDOR
X    static long double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
N    _RWSTD_STATIC_FUN (long double, signaling_NaN, __ESCAPE__(0d_7FF0000000000001))   // VENDOR
X    static long double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   
N#endif
N    _RWSTD_STATIC_FUN (long double, denorm_min,    _RWSTD_LDBL_DENORM_MIN)
X    static long double denorm_min ()  { return 2.22507385850720138e-308L; }
N
N    _RWSTD_STATIC (long double, bool, is_iec559,  _RWSTD_IS_IEC559);
X    static const bool is_iec559 = (false);
N    _RWSTD_STATIC (long double, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (long double, bool, is_modulo,  false);         // VENDOR
X    static const bool is_modulo = (false);         
N
N    _RWSTD_STATIC (long double, bool, traps, true);              // VENDOR
X    static const bool traps = (true);              
N    _RWSTD_STATIC (long double, bool, tinyness_before, false);    // VENDOR
X    static const bool tinyness_before = (false);    
N
N    _RWSTD_STATIC_ROUNDS (long double, float_round_style, round_style,
N                          FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (long double _C_convertible)
X    typedef long double _C_convertible;
N
N_RWSTD_CLASS_END    // numeric_limits<long double>
X};    
N
N#endif   // _RWSTD_NO_LONG_DOUBLE
N
N
N#define _RWSTD_UCHAR_MIN 0
N#define _RWSTD_USHRT_MIN 0
N#define _RWSTD_UINT_MIN  0
N#define _RWSTD_ULONG_MIN 0
N
N#define _RWSTD_UCHAR_MAX UCHAR_MAX
N#define _RWSTD_USHRT_MAX USHRT_MAX
N#define _RWSTD_UINT_MAX  UINT_MAX
N#define _RWSTD_ULONG_MAX ULONG_MAX
N
N
N// types each integral type converts to with no loss of precision (if possible)
N#ifdef _RWSTD_LONG_LONG
N#  if UINT_MAX < ULONG_MAX
X#  if 0xffffffffU < 0xffffffffUL
S#    define _RWSTD_INT_CONVERTIBLE long
N#  else
N#    define _RWSTD_INT_CONVERTIBLE _RWSTD_LONG_LONG
N#  endif
N#  define _RWSTD_LONG_CONVERTIBLE  _RWSTD_LONG_LONG
N#else   // if !defined (_RWSTD_LONG_LONG)
S#  define _RWSTD_INT_CONVERTIBLE  long
S#  define _RWSTD_LONG_CONVERTIBLE long
N#endif   // _RWSTD_LONG_LONG
N
N
N#if UCHAR_MAX < UINT_MAX
X#if 255 < 0xffffffffU
N#  define _RWSTD_CHAR_CONVERTIBLE int
N#else
S#  define _RWSTD_CHAR_CONVERTIBLE _RWSTD_INT_CONVERTIBLE
N#endif   // UCHAR_MAX < UINT_MAX
N
N
N#if USHRT_MAX < UINT_MAX
X#if 65535 < 0xffffffffU
N#  define _RWSTD_SHORT_CONVERTIBLE int
N#else
S#  define _RWSTD_SHORT_CONVERTIBLE _RWSTD_INT_CONVERTIBLE
N#endif   // USHRT_MAX < UINT_MAX
N
N
N// define numeric_limits<> integral specializations
N_RWSTD_SPECIALIZE_LIMITS (char, _RWSTD_CHAR_CONVERTIBLE, CHAR)
Xtemplate< > class numeric_limits<char> { public: static const bool is_specialized = (true); static char min ()  { return 0; } static char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static char epsilon ()  { return 0; } static char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static char infinity ()  { return 0; } static char quiet_NaN ()  { return 0; } static char signaling_NaN ()  { return 0; } static char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned char,
N                          unsigned _RWSTD_CHAR_CONVERTIBLE, _RWSTD_UCHAR)
Xtemplate< > class numeric_limits<unsigned char> { public: static const bool is_specialized = (true); static unsigned char min ()  { return 0; } static unsigned char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned char epsilon ()  { return 0; } static unsigned char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned char infinity ()  { return 0; } static unsigned char quiet_NaN ()  { return 0; } static unsigned char signaling_NaN ()  { return 0; } static unsigned char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (signed char, _RWSTD_CHAR_CONVERTIBLE, SCHAR)
Xtemplate< > class numeric_limits<signed char> { public: static const bool is_specialized = (true); static signed char min ()  { return (-128); } static signed char max ()  { return 127; } static const bool is_signed = ((-128) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))); static const int digits10 = (((((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))) * 301) / 1000)); static const int radix = (2); static signed char epsilon ()  { return 0; } static signed char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static signed char infinity ()  { return 0; } static signed char quiet_NaN ()  { return 0; } static signed char signaling_NaN ()  { return 0; } static signed char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 127); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (short int, _RWSTD_SHORT_CONVERTIBLE, SHRT)
Xtemplate< > class numeric_limits<short int> { public: static const bool is_specialized = (true); static short int min ()  { return (-0x8000); } static short int max ()  { return 0x7fff; } static const bool is_signed = ((-0x8000) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))); static const int digits10 = (((((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))) * 301) / 1000)); static const int radix = (2); static short int epsilon ()  { return 0; } static short int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static short int infinity ()  { return 0; } static short int quiet_NaN ()  { return 0; } static short int signaling_NaN ()  { return 0; } static short int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned short,
N                          unsigned _RWSTD_SHORT_CONVERTIBLE, _RWSTD_USHRT)
Xtemplate< > class numeric_limits<unsigned short> { public: static const bool is_specialized = (true); static unsigned short min ()  { return 0; } static unsigned short max ()  { return 65535; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))); static const int digits10 = (((((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned short epsilon ()  { return 0; } static unsigned short round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned short infinity ()  { return 0; } static unsigned short quiet_NaN ()  { return 0; } static unsigned short signaling_NaN ()  { return 0; } static unsigned short denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 65535); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (int, _RWSTD_INT_CONVERTIBLE, INT)
Xtemplate< > class numeric_limits<int> { public: static const bool is_specialized = (true); static int min ()  { return (~0x7fffffff); } static int max ()  { return 0x7fffffff; } static const bool is_signed = ((~0x7fffffff) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))); static const int digits10 = (((((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))) * 301) / 1000)); static const int radix = (2); static int epsilon ()  { return 0; } static int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static int infinity ()  { return 0; } static int quiet_NaN ()  { return 0; } static int signaling_NaN ()  { return 0; } static int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned int,
N                          unsigned _RWSTD_INT_CONVERTIBLE, _RWSTD_UINT)
Xtemplate< > class numeric_limits<unsigned int> { public: static const bool is_specialized = (true); static unsigned int min ()  { return 0; } static unsigned int max ()  { return 0xffffffffU; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned int epsilon ()  { return 0; } static unsigned int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned int infinity ()  { return 0; } static unsigned int quiet_NaN ()  { return 0; } static unsigned int signaling_NaN ()  { return 0; } static unsigned int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffU); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (long int, _RWSTD_LONG_CONVERTIBLE, LONG)
Xtemplate< > class numeric_limits<long int> { public: static const bool is_specialized = (true); static long int min ()  { return (~0x7fffffffL); } static long int max ()  { return 0x7fffffffL; } static const bool is_signed = ((~0x7fffffffL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))) * 301) / 1000)); static const int radix = (2); static long int epsilon ()  { return 0; } static long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static long int infinity ()  { return 0; } static long int quiet_NaN ()  { return 0; } static long int signaling_NaN ()  { return 0; } static long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned long int,
N                          unsigned _RWSTD_LONG_CONVERTIBLE, _RWSTD_ULONG)
Xtemplate< > class numeric_limits<unsigned long int> { public: static const bool is_specialized = (true); static unsigned long int min ()  { return 0; } static unsigned long int max ()  { return 0xffffffffUL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned long int epsilon ()  { return 0; } static unsigned long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned long int infinity ()  { return 0; } static unsigned long int quiet_NaN ()  { return 0; } static unsigned long int signaling_NaN ()  { return 0; } static unsigned long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffUL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N
N#undef _RWSTD_UCHAR_MIN
N#undef _RWSTD_USHRT_MIN
N#undef _RWSTD_UINT_MIN
N#undef _RWSTD_ULONG_MIN
N
N#undef _RWSTD_UCHAR_MAX
N#undef _RWSTD_USHRT_MAX
N#undef _RWSTD_UINT_MAX
N#undef _RWSTD_ULONG_MAX
N
N#ifndef _RWSTD_NO_NATIVE_WCHAR_T
N
N#  define _RWSTD_WCHAR_MIN                                   \
N          (  wchar_t (-1) > 0 ? 0                            \
N           : sizeof (wchar_t) == sizeof (short) ? SHRT_MIN   \
N           : sizeof (wchar_t) == sizeof (int)   ? INT_MIN    \
N           : sizeof (wchar_t) == sizeof (long)  ? LONG_MIN   \
N           : SCHAR_MIN)
X#  define _RWSTD_WCHAR_MIN                                             (  wchar_t (-1) > 0 ? 0                                       : sizeof (wchar_t) == sizeof (short) ? SHRT_MIN              : sizeof (wchar_t) == sizeof (int)   ? INT_MIN               : sizeof (wchar_t) == sizeof (long)  ? LONG_MIN              : SCHAR_MIN)
N                        
N#  define _RWSTD_WCHAR_MAX                                       \
N          (  wchar_t (-1) > 0 ?                                  \
N             (  sizeof (wchar_t) == sizeof (short) ? USHRT_MAX   \
N              : sizeof (wchar_t) == sizeof (int)   ? UINT_MAX    \
N              : sizeof (wchar_t) == sizeof (long)  ? ULONG_MAX   \
N              : SCHAR_MAX)                                       \
N           : (  sizeof (wchar_t) == sizeof (short) ? SHRT_MAX    \
N              : sizeof (wchar_t) == sizeof (int)   ? INT_MAX     \
N              : sizeof (wchar_t) == sizeof (long)  ? LONG_MAX    \
N              : UCHAR_MAX))
X#  define _RWSTD_WCHAR_MAX                                                 (  wchar_t (-1) > 0 ?                                               (  sizeof (wchar_t) == sizeof (short) ? USHRT_MAX                 : sizeof (wchar_t) == sizeof (int)   ? UINT_MAX                  : sizeof (wchar_t) == sizeof (long)  ? ULONG_MAX                 : SCHAR_MAX)                                                  : (  sizeof (wchar_t) == sizeof (short) ? SHRT_MAX                  : sizeof (wchar_t) == sizeof (int)   ? INT_MAX                   : sizeof (wchar_t) == sizeof (long)  ? LONG_MAX                  : UCHAR_MAX))
N
N
N_RWSTD_SPECIALIZE_LIMITS (wchar_t, _RWSTD_INT_CONVERTIBLE, _RWSTD_WCHAR)
Xtemplate< > class numeric_limits<wchar_t> { public: static const bool is_specialized = (true); static wchar_t min ()  { return ( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)); } static wchar_t max ()  { return ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255)); } static const bool is_signed = (( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))); static const int digits10 = (((((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))) * 301) / 1000)); static const int radix = (2); static wchar_t epsilon ()  { return 0; } static wchar_t round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static wchar_t infinity ()  { return 0; } static wchar_t quiet_NaN ()  { return 0; } static wchar_t signaling_NaN ()  { return 0; } static wchar_t denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N#  undef _RWSTD_WCHAR_MIN
N#  undef _RWSTD_WCHAR_MAX
N
N#endif   // _RWSTD_NO_NATIVE_WCHAR_T
N
N
N#ifndef _RWSTD_NO_BOOL
N
N#  define _RWSTD_BOOL_MIN   false
N#  define _RWSTD_BOOL_MAX   true
N
N_RWSTD_SPECIALIZE_LIMITS (bool, int, _RWSTD_BOOL)
Xtemplate< > class numeric_limits<bool> { public: static const bool is_specialized = (true); static bool min ()  { return false; } static bool max ()  { return true; } static const bool is_signed = (false != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))); static const int digits10 = (((((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))) * 301) / 1000)); static const int radix = (2); static bool epsilon ()  { return 0; } static bool round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static bool infinity ()  { return 0; } static bool quiet_NaN ()  { return 0; } static bool signaling_NaN ()  { return 0; } static bool denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != true); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N#  undef _RWSTD_BOOL_MIN
N#  undef _RWSTD_BOOL_MAX
N
N#endif   // _RWSTD_NO_BOOL
N
N
N#ifdef _RWSTD_LONG_LONG                                             // VENDOR
N
N#  if defined (_WIN32) && defined (_MSC_VER)
X#  if 0L && 0L
S#    define LONG_LONG_MIN   _I64_MIN
S#    define LONG_LONG_MAX   _I64_MAX
S#    define ULONG_LONG_MAX  _UI64_MAX
N#  else   // if !(defined (_WIN32) && defined (_MSC_VER))
N
N#  ifndef LONG_LONG_MIN
N#    ifndef LLONG_MIN
S       // assuming modulo 2 representation and a working shift
S#      define LONG_LONG_MIN \
S          (((_RWSTD_LONG_LONG)1) << (sizeof (_RWSTD_LONG_LONG) * CHAR_BIT - 1))
X#      define LONG_LONG_MIN           (((_RWSTD_LONG_LONG)1) << (sizeof (_RWSTD_LONG_LONG) * CHAR_BIT - 1))
S#      define LONG_LONG_MAX   (~LONG_LONG_MIN)
S#      define ULONG_LONG_MAX  (~(unsigned _RWSTD_LONG_LONG)0)
N#    else   // if defined (LLONG_MIN)
N       // e.g., Sun libc 
N#      define LONG_LONG_MIN   LLONG_MIN
N#      define LONG_LONG_MAX   LLONG_MAX
N#      define ULONG_LONG_MAX  ULLONG_MAX
N#    endif   // LLONG_MIN
N#  endif   // LONG_LONG_MIN
N
N#endif   // _WIN32 && _MSC_VER
N
N#  define ULONG_LONG_MIN   0
N
N_RWSTD_SPECIALIZE_LIMITS (_RWSTD_LONG_LONG, _RWSTD_LONG_LONG, LONG_LONG)
Xtemplate< > class numeric_limits<__int64> { public: static const bool is_specialized = (true); static __int64 min ()  { return (~0x7fffffffffffffffLL); } static __int64 max ()  { return 0x7fffffffffffffffLL; } static const bool is_signed = ((~0x7fffffffffffffffLL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))) * 301) / 1000)); static const int radix = (2); static __int64 epsilon ()  { return 0; } static __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static __int64 infinity ()  { return 0; } static __int64 quiet_NaN ()  { return 0; } static __int64 signaling_NaN ()  { return 0; } static __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffffffffffLL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned _RWSTD_LONG_LONG,
N                          unsigned _RWSTD_LONG_LONG, ULONG_LONG)
Xtemplate< > class numeric_limits<unsigned __int64> { public: static const bool is_specialized = (true); static unsigned __int64 min ()  { return 0; } static unsigned __int64 max ()  { return 0xffffffffffffffffULL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned __int64 epsilon ()  { return 0; } static unsigned __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned __int64 infinity ()  { return 0; } static unsigned __int64 quiet_NaN ()  { return 0; } static unsigned __int64 signaling_NaN ()  { return 0; } static unsigned __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffffffffffULL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N#  undef ULONG_LONG_MIN 
N
N#endif   // _RWSTD_LONG_LONG
N
N
N#undef _RWSTD_CHAR_CONVERTIBLE
N#undef _RWSTD_SHORT_CONVERTIBLE
N#undef _RWSTD_INT_CONVERTIBLE
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <limits.cc>
N#endif
N
N#endif   // _RWSTD_LIMITS_INCLUDED
N
L 37 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N
N#include <rw/_algobase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_algobase.h" 1
N/***************************************************************************
N *
N * _algobase.h - Declarations and inline definitions of frequently used
N *               C++ Standard Library algorithms
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ALGOBASE_H_INCLUDED
N#define _RWSTD_ALGOBASE_H_INCLUDED
N
N#include <utility>   // for pair
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\utility" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * utility - Declarations for the Standard Library utility classes
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_UTILITY_INCLUDED
N#define _RWSTD_UTILITY_INCLUDED
N
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
N// rel_ops contents not available if namespaces are disabled
N// to avoid ambiguities with other overloaded operators
N
N_RWSTD_NAMESPACE_BEGIN (rel_ops)
Xnamespace rel_ops {
N
N
Ntemplate <class _TypeT>
Ninline bool operator!= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator> (const _TypeT& __x, const _TypeT& __y)
N{
N    return __y < __x;
N}
N
Ntemplate <class _TypeT>
Ninline bool operator<= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__y < __x);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator>= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x < __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // rel_ops
X}   
N
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.2.2
Ntemplate <class _TypeT, class _TypeU>
Nstruct pair
N{
N    typedef _TypeT first_type;
N    typedef _TypeU second_type;
N
N    first_type  first;
N    second_type second;
N
N    pair (const first_type &__x, const second_type &__y)
N        : first (__x), second (__y) { }
N
N    pair ()
N#ifndef _RWSTD_NO_EMPTY_MEM_INITIALIZER
N        : first (/* lwg issue 265 */), second () { }
N#else
S        : first (first_type ()), second (second_type ()) { }
N#endif   // _RWSTD_NO_EMPTY_MEM_INITIALIZER
N
N    pair (const pair &__rhs): first (__rhs.first), second (__rhs.second) { }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeX, class _TypeY>
N    pair (const pair <_TypeX, _TypeY> &__rhs) 
N        : first (__rhs.first), second (__rhs.second) { }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N};
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __x.first == __y.first && __x.second == __y.second; 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x == __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator< (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return    __x.first < __y.first
N           || (!(__y.first < __x.first) && __x.second < __y.second); 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator> (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __y < __x;
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator>= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x < __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator<= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__y < __x);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline pair<_TypeT, _TypeU>
Nmake_pair (const _TypeT &__x, const _TypeU &__y)
N{
N    return pair<_TypeT, _TypeU>(__x, __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_UTILITY_INCLUDED
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_algobase.h" 2
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  include <rw/_iterbase.h>
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#undef max
N#undef min
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.3.7, p1
Ntemplate <class _TypeT>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b)
N{
N    return __b < __a ? __b : __a;
N}
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__b, __a) ? __b : __a;
N}
N
N
N// 25.3.7, p3
Ntemplate <class _TypeT>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b)
N{
N    return  __a < __b ? __b : __a;
N}
N
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__a, __b) ? __b : __a;
N}
N
N
N// 25.2.1, p1
Ntemplate <class _InputIter, class _OutputIter>
Ninline _OutputIter
Ncopy (_InputIter __first, _InputIter __last, _OutputIter __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__first,++__res)
N        *__res = *__first;
N    return __res;
N}
N
N
N// 25.2.1, p5
Ntemplate <class _BidirIter1, class _BidirIter2>
Ninline _BidirIter2
Ncopy_backward (_BidirIter1 __first, _BidirIter1 __last, _BidirIter2 __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    while (__first != __last)
N        *--__res = *--__last;
N    return __res;
N}
N
N
N// 25.2.5
Ntemplate <class _FwdIter, class _TypeT>
Ninline void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last; ++__first)
N        *__first = __value;
N}
N
N
Ntemplate <class _OutputIter, class _Size, class _TypeT>
Ninline void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value)
N{
N    for (;__n > 0;--__n, ++__first)
N        *__first = __value;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// `less than' qusi-function object - used by algorithms for code reuse
Ntemplate <class _TypeT>
Nstruct __rw_lt
N{
N    bool operator() (const _TypeT &__lhs, const _TypeT &__rhs) const {
N        return __lhs < __rhs;
N    }
N};
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_LESS(iterT) \
N     _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
X#  define _RWSTD_LESS(iterT)      _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
N
N#else   // if defined (_RWSTD_NO_PARTIAL_CLASS_SPEC)
S
S#  define _RWSTD_LESS(iterT) \
S     _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
X#  define _RWSTD_LESS(iterT)      _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
S
Stemplate <class _TypeT>
S__rw_lt<_TypeT> __rw_make_lt (const _TypeT*)
S{
S    return __rw_lt<_TypeT>();
S}
S
N#endif   // _RWSTD_NO_PARTIAL_CLASS_SPEC
N
N
N// swaps values of 2 (possibly distinct) types
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_swap (_TypeT& __a, _TypeU& __b)
N{
N    // _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.2.2, p1
Ntemplate <class _TypeT>
Ninline void swap (_TypeT& __a, _TypeT& __b)
N{
N    // LWG issue 227 - _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N// 25.2.2, p7
Ntemplate <class _FwdIter1, class _FwdIter2>
Ninline void iter_swap (_FwdIter1 __a, _FwdIter2 __b)
N{
N    // std::iterator_traits<_FwdIter[12]>::value_type must satisfy
N    // both Assignable and CopyConstructible
N    _RW::__rw_swap (*__a, *__b);
X    __rw::__rw_swap (*__a, *__b);
N}
N
N
N// 25.1.7 - Mismatch
Ntemplate <class _InputIter1, class _InputIter2>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && *__first1 == *__first2) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1,
N          _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && __pred (*__first1, *__first2)) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
N// 25.1.8 - Equal
Ntemplate <class _InputIter1, class _InputIter2>
Ninline bool
Nequal (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    return __last1 == _STD::mismatch (__first1, __last1, __first2).first;
X    return __last1 == std::mismatch (__first1, __last1, __first2).first;
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline bool equal (_InputIter1 __first1, _InputIter1 __last1,
N                   _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    return __last1 == _STD::mismatch (__first1, __last1,
X    return __last1 == std::mismatch (__first1, __last1,
N                                      __first2, __pred).first;
N}
N
N
N// 25.3.8 - Lexicographical Comparison
Ntemplate <class _InputIter1, class _InputIter2>
Nbool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
N                              _InputIter2 __first2, _InputIter2 __last2);
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _Compare>
Nbool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
N                             _InputIter2 __first2, _InputIter2 __last2,
N                             _Compare __comp);
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <rw/_algobase.cc>
N#endif
N
N
N#endif   // _RWSTD_ALGOBASE_H_INCLUDED
N
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N#include <rw/_iterator.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterator.h" 1
N/***************************************************************************
N *
N * _iterator.h - Iterator declarations for the Standard Library
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ITERATOR_H_INCLUDED
N#define _RWSTD_ITERATOR_H_INCLUDED
N
N#include <rw/_iterbase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterbase.h" 1
N/***************************************************************************
N *
N * _iterbase.h - Definitions of iterator primitives
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ITERBASE_H_INCLUDED
N#define _RWSTD_ITERBASE_H_INCLUDED
N
N#include <rw/_defs.h>
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 24.3.1 - Iterator traits
Ntemplate <class _Iterator>
Nstruct iterator_traits
N{
N    typedef _TYPENAME _Iterator::value_type        value_type;
X    typedef typename _Iterator::value_type        value_type;
N    typedef _TYPENAME _Iterator::difference_type   difference_type;
X    typedef typename _Iterator::difference_type   difference_type;
N    typedef _TYPENAME _Iterator::pointer           pointer;
X    typedef typename _Iterator::pointer           pointer;
N    typedef _TYPENAME _Iterator::reference         reference;
X    typedef typename _Iterator::reference         reference;
N    typedef _TYPENAME _Iterator::iterator_category iterator_category;
X    typedef typename _Iterator::iterator_category iterator_category;
N};
N
N
N// 24.3.3 - Standard iterator tags
Nstruct input_iterator_tag { };
Nstruct output_iterator_tag { };
Nstruct forward_iterator_tag : public input_iterator_tag { };
Nstruct bidirectional_iterator_tag : public forward_iterator_tag { };
Nstruct random_access_iterator_tag : public bidirectional_iterator_tag { };
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<_TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef value_type*                pointer;
N    typedef value_type&                reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<const _TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef const value_type*          pointer;
N    typedef const value_type&          reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.2 - Basic iterator
Ntemplate <class _Category, class _TypeT,  
N          class _Distance _RWSTD_SIMPLE_DEFAULT (ptrdiff_t), 
X          class _Distance = ptrdiff_t, 
N          class _Pointer _RWSTD_SIMPLE_DEFAULT (_TypeT*), 
X          class _Pointer = _TypeT*, 
N          class _Reference _RWSTD_SIMPLE_DEFAULT (_TypeT&)>
X          class _Reference = _TypeT& >
Nstruct iterator
N{
N    typedef _TypeT     value_type;
N    typedef _Distance  difference_type;
N    typedef _Pointer   pointer;
N    typedef _Reference reference;
N    typedef _Category  iterator_category;
N};
N
N
N// returns the category of an iterator
Ntemplate <class _TypeT>
Ninline random_access_iterator_tag __iterator_category (const _TypeT*)
N{
N    return random_access_iterator_tag ();
N}
N
N
Ntemplate <class _Category, class _TypeT, class _Distance, 
N          class _Pointer, class _Reference> 
Ninline _Category
N__iterator_category (const iterator<_Category, _TypeT,
N                                    _Distance, _Pointer, _Reference>&)
N{
N    typedef _TYPENAME iterator<_Category, _TypeT, _Distance, _TypeT*,
X    typedef typename iterator<_Category, _TypeT, _Distance, _TypeT*,
N                               _TypeT&>::iterator_category _IterCategory;
N
N    return _IterCategory ();
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_input_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_bidirectional_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_random_access_iterator (_Tag)
N{
N    return false;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_input_iterator (input_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (bidirectional_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_random_access_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::value_type*
Xinline typename iterator_traits<_Iterator>::value_type*
N__value_type (const _Iterator*)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _TypeT*
S__value_type (const iterator<_Category, _TypeT, _Distance,
S                             _Pointer, _Reference>*)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline _TypeT* __value_type (const _TypeT* const*)
S{
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::difference_type*
Xinline typename iterator_traits<_Iterator>::difference_type*
N__distance_type (_Iterator)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _Distance* 
S__distance_type (iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline ptrdiff_t* __distance_type (const _TypeT*)
S{ 
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.4 - Iterator operations
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __advance (_InputIterator &__it, _Distance __n, input_iterator_tag)
N{
N    _RWSTD_ASSERT (__n == 0 || __n > 0);
X    ((void)0);
N
N    while (__n > 0) {
N        --__n;
N        ++__it;
N    }
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __advance (_ForwardIterator &__it, _Distance __n,
N                       forward_iterator_tag)
N{
N    __advance (__it, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __advance (_BidirectionalIterator &__it, _Distance __n, 
N                       bidirectional_iterator_tag)
N{
N    if (__n > 0)
N        __advance (__it, __n, input_iterator_tag ());
N    else
N        while (__n) {
N            ++__n;
N            --__it;
N        }
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __advance (_RandomAccessIterator& __it, _Distance __n, 
N                       random_access_iterator_tag)
N{
N    __it += __n;
N}
N
N
N// 24.3.4, p2
Ntemplate <class _InputIterator, class _Distance>
Ninline void advance (_InputIterator& __it, _Distance __n)
N{
N    __advance (__it, __n, _RWSTD_ITERATOR_CATEGORY (_InputIterator, __it));
X    __advance (__it, __n, typename std::iterator_traits< _InputIterator > ::iterator_category ());
N}
N
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __distance (const _InputIterator &__first,
N                        const _InputIterator &__last,
N                        _Distance            &__n,
N                        input_iterator_tag)
N{
N    for (_InputIterator __it = __first; __it != __last; ++__it)
N        ++__n;
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __distance (const _ForwardIterator &__first,
N                        const _ForwardIterator &__last,
N                        _Distance              &__n,
N                        forward_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __distance (const _BidirectionalIterator &__first,
N                        const _BidirectionalIterator &__last, 
N                        _Distance                    &__n,
N                        bidirectional_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __distance (const _RandomAccessIterator &__first,
N                        const _RandomAccessIterator &__last, 
N                        _Distance                   &__n,
N                        random_access_iterator_tag)
N{
N    __n = __last - __first;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// 24.3.4, p4
Ntemplate <class _ForwardIterator>
Ninline _TYPENAME iterator_traits<_ForwardIterator>::difference_type
Xinline typename iterator_traits<_ForwardIterator>::difference_type
Ndistance (const _ForwardIterator &__first, const _ForwardIterator &__last)
N{
N    _TYPENAME iterator_traits<_ForwardIterator>::difference_type __n = 0;
X    typename iterator_traits<_ForwardIterator>::difference_type __n = 0;
N
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N
N    return __n;
N}
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_EXT_VOID_DISTANCE
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void distance (const _ForwardIterator &__first,
N                      const _ForwardIterator &__last,
N                      _Distance              &__n)
N{
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N}
N
N#endif   // _RWSTD_NO_EXT_VOID_DISTANCE
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_distance: Same purpose as 3-parameter distance function, but
N// with return value.
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline _Distance
N__rw_distance (const _ForwardIterator &__first,
N               const _ForwardIterator &__last,
N               _Distance               __n)
N{
N    _STD::__distance (__first, __last, __n,
X    std::__distance (__first, __last, __n,
N                      _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                      typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N    return __n;
N}
N
N
N_RWSTD_NAMESPACE_END // __rw
X} 
N
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// __rw_debug_iter - iterator adapter with debugging support
S// _Iterator is either iterator or const_iterator; if the latter,
S// _MutableIterator should be iterator to allow for implicit
S// conversions from non-const (mutable) to const_iterator objects
S
S
Stemplate <class _Container, class _Iterator, class _MutableIterator>
Sclass __rw_debug_iter
S{
S    typedef _Container                                container_type;
S    typedef _Iterator                                 iterator_type;
S    typedef _STD::iterator_traits<iterator_type>      traits_type;
S
Spublic:
S
S    typedef _TYPENAME traits_type::value_type         value_type;
S    typedef _TYPENAME traits_type::difference_type    difference_type;
S    typedef _TYPENAME traits_type::reference          reference;
S    typedef _TYPENAME traits_type::pointer            pointer;
S    typedef _TYPENAME traits_type::iterator_category  iterator_category;
S
S    typedef __rw_debug_iter <container_type, _MutableIterator,
S                             _MutableIterator>        _C_mutable_iterator;
S
S    __rw_debug_iter (): _C_cont (0) { }
S
S    __rw_debug_iter (const container_type &__cont, const iterator_type &__it)
S        : _C_iter (__it), _C_cont (&__cont) { }
S
S    // no copy ctor other than the one below is defined
S    // will use a compiler generated one if _Iterator != _MutableIterator
S    __rw_debug_iter (const _C_mutable_iterator &__rhs)
S        : _C_iter (__rhs._C_iter), _C_cont (__rhs._C_cont) { }
S
S    __rw_debug_iter& operator= (const __rw_debug_iter &__rhs) {
S        if (this != &__rhs) {
S            _C_iter = __rhs._C_iter;
S            _C_cont = __rhs._C_cont;
S        }
S        return *this;
S    }
S
S    reference operator* () const {
S        _RWSTD_ASSERT (_C_is_dereferenceable ());
S        return *_C_iter;
S    }
S
S    reference operator[] (difference_type __n) const {
S        _RWSTD_ASSERT ((*this + __n)._C_is_dereferenceable ());
S        return _C_iter [__n];
S    }
S
S    _RWSTD_OPERATOR_ARROW (pointer operator-> () const);
S
S    __rw_debug_iter& operator++ () {
S        _RWSTD_ASSERT (!_C_is_end ());
S        return ++_C_iter, *this;
S    }
S
S    __rw_debug_iter& operator-- () {
S        _RWSTD_ASSERT (!_C_is_begin ());
S        return --_C_iter, *this;
S    }
S
S    __rw_debug_iter operator++ (int) {
S        __rw_debug_iter __tmp = *this;
S        return ++*this, __tmp;
S    }
S
S    __rw_debug_iter operator-- (int) {
S        __rw_debug_iter __tmp = *this;
S        return --*this, __tmp;
S    }
S
S    __rw_debug_iter& operator+= (difference_type __n) {
S        _C_iter += __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter& operator-= (difference_type __n) {
S        _C_iter -= __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter operator+ (difference_type __n) const {
S        return __rw_debug_iter (*this) += __n;
S    }
S
S    __rw_debug_iter operator- (difference_type __n) const {
S        return __rw_debug_iter (*this) -= __n;
S    }
S
S    bool _C_is_begin () const {
S        return _C_cont && _C_cont->begin () == *this;
S    }
S
S    bool _C_is_end () const {
S        return _C_cont && _C_cont->end () == *this;
S    }
S
S    bool _C_is_dereferenceable () const {
S        return !_C_is_end ();
S    }
S
S    bool _C_valid_range (const __rw_debug_iter &__it) const {
S        return _C_cont && _C_cont == __it._C_cont;
S    }
S
S    const iterator_type& base () const {
S        return _C_iter;
S    }
S
S    iterator_type& base () {
S        return _C_iter;
S    }
S
S#ifndef _RWSTD_NO_MEMBER_TEMPLATES
S
S    // operators are templatized to assure const/non-const symmetry
S
S    template <class _Iter>
S    difference_type
S    operator- (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        _RWSTD_ASSERT (_C_cont && _C_cont == __rhs._C_cont);
S        return _C_iter - __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator== (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter == __rhs._C_iter;
S    }
S    
S    template <class _Iter>
S    bool
S    operator< (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter < __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator!= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter != __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator<= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter <= __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator> (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter > __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator>= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter >= __rhs._C_iter;
S    }
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S    iterator_type         _C_iter;   // wrapped iterator
S    const container_type *_C_cont;   // associated container
S};
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
S
S#ifndef _RWSTD_NO_NONDEDUCED_CONTEXT
S# define _RWSTD_CONT_DIFF_TYPE _TYPENAME _Cont::difference_type 
S#else
S# define _RWSTD_CONT_DIFF_TYPE ptrdiff_t 
S#endif
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> 
Soperator+ (_RWSTD_CONT_DIFF_TYPE                               __n,
S           const _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> &__x)
S{
S    return __x + __n;
S}
S
S#undef _RWSTD_CONT_DIFF_TYPE 
S
S
S#ifdef _RWSTD_NO_MEMBER_TEMPLATES
S
S// with no support for member templates namespace-scope (non-member)
S// operators must be used - these will cause ambiguities with those
S// in std::rel_ops if the latter are found during lookup
S
S
S
S// _Iter1 may differ from _Iter2 if the function operands are const
S// and non-const iterators, respectively (allows symmetry)
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline _TYPENAME _Cont::difference_type
Soperator- (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter - __y._C_iter;
S}
S    
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator== (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __x._C_iter == __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator< (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter < __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator!= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x == __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator<= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__y < __x);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator>= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x < __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator> (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __y < __x;
S}
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S_RWSTD_NAMESPACE_END   // std
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S
S#define _RWSTD_DEBUG_ITER(cont, it, mutit) __rw_debug_iter< cont, it, mutit >
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_valid_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S                  const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return __first._C_cont && __first._C_cont == __last._C_cont;
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_valid_range (const _Iterator &, const _Iterator &)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_in_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return    __rw_valid_range (__first, __it)
S           && __rw_valid_range (__it, __last);
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_in_range (const _Iterator&, const _Iterator&, const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_dereferenceable (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it)
S{
S    return __it._C_is_dereferenceable ();
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_dereferenceable (const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _TypeT>
Sinline bool
S__rw_dereferenceable (const _TypeT *__ptr)
S{
S    return 0 != __ptr;
S}
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#undef _RWSTD_DEBUG_ITER
S
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#endif   // _RWSTD_ITERBASE_H_INCLUDED
N
L 51 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterator.h" 2
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// Reverse iterator.     
N
N//
N//  Macros for reverse iterators to accomodate non-standard compilers
N//
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N#  define _RWSTD_ITER_TEMPLATE template <class _Iterator>
N#  define _RWSTD_ITER_ID(i)    i <_Iterator>
N#  define _RWSTD_ITER_DIFF_TYPE(i, ignore)                             \
N          _TYPENAME iterator_traits<_Iterator>::difference_type
X#  define _RWSTD_ITER_DIFF_TYPE(i, ignore)                                       _TYPENAME iterator_traits<_Iterator>::difference_type
N#else
S#  define _RWSTD_ITER_TEMPLATE                                         \
S          template <class _Iterator, class _Category, class _TypeT,    \
S                    class _Reference, class _Pointer, class _Distance>
X#  define _RWSTD_ITER_TEMPLATE                                                   template <class _Iterator, class _Category, class _TypeT,                        class _Reference, class _Pointer, class _Distance>
S#  define _RWSTD_ITER_ID(i)                                            \
S          i <_Iterator, _Category, _TypeT, _Reference, _Pointer, _Distance>
X#  define _RWSTD_ITER_ID(i)                                                      i <_Iterator, _Category, _TypeT, _Reference, _Pointer, _Distance>
S#  define _RWSTD_ITER_DIFF_TYPE(ignore, distance) distance          
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
Ntemplate <class _Iterator>
Nclass reverse_iterator
N    : public iterator<_TYPENAME iterator_traits<_Iterator>::iterator_category, 
X    : public iterator<typename iterator_traits<_Iterator>::iterator_category, 
N                      _TYPENAME iterator_traits<_Iterator>::value_type, 
X                      typename iterator_traits<_Iterator>::value_type, 
N                      _TYPENAME iterator_traits<_Iterator>::difference_type,
X                      typename iterator_traits<_Iterator>::difference_type,
N                      _TYPENAME iterator_traits<_Iterator>::pointer, 
X                      typename iterator_traits<_Iterator>::pointer, 
N                      _TYPENAME iterator_traits<_Iterator>::reference>
X                      typename iterator_traits<_Iterator>::reference>
N{
N    typedef iterator_traits<_Iterator>  traits_type;
Npublic:
N    typedef _TYPENAME traits_type::difference_type difference_type;
X    typedef typename traits_type::difference_type difference_type;
N    typedef _TYPENAME traits_type::value_type value_type;
X    typedef typename traits_type::value_type value_type;
N    typedef _TYPENAME traits_type::pointer pointer;
X    typedef typename traits_type::pointer pointer;
N    typedef _TYPENAME traits_type::reference reference;
X    typedef typename traits_type::reference reference;
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Iterator, class _Category, class _TypeT,
S          class _Reference _RWSTD_COMPLEX_DEFAULT (_TypeT&), 
S          class _Pointer _RWSTD_COMPLEX_DEFAULT (_TypeT*), 
S          class _Distance _RWSTD_COMPLEX_DEFAULT (ptrdiff_t)>
Sclass reverse_iterator
S    : public iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>
S
S{
Spublic:
S    typedef _Distance  difference_type;
S    typedef _TypeT     value_type;
S    typedef _Reference reference;
S    typedef _Pointer   pointer;
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N    typedef _Iterator iterator_type;
N
N    reverse_iterator () { }
N
N    _EXPLICIT reverse_iterator (iterator_type __rhs) : current (__rhs) { }
X    explicit reverse_iterator (iterator_type __rhs) : current (__rhs) { }
N 
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N#  ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N      template <class _TypeU>
N      reverse_iterator (const reverse_iterator<_TypeU>& __rhs)
N          : current (__rhs.base ()) { }
N
N#  else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S      template <class _Iterator2, class _Category2, class _TypeU,
S                class _Reference2, class _Pointer2, class _Distance2>
S      reverse_iterator (const reverse_iterator<_Iterator2, _Category2, _TypeU,
S                        _Reference2, _Pointer2, _Distance2>& __rhs)
S          : current (__rhs.base ()) { }
S
N#  endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC 
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    iterator_type base () const {
N        return current;
N    }
N
N    reference operator* () const {
N        iterator_type __tmp = base ();
N        return *--__tmp;
N    }
N
N    _RWSTD_OPERATOR_ARROW (pointer operator->() const);
X    pointer operator->() const { return & * *this; };
N
N    reverse_iterator& operator++ () {
N        return --current, *this;
N    }
N
N    reverse_iterator operator++ (int) {
N        reverse_iterator __tmp = *this;
N        ++*this;
N        return __tmp;
N    }
N
N    reverse_iterator& operator-- () {
N        return ++current, *this;
N    }
N
N    reverse_iterator operator-- (int) {
N        reverse_iterator __tmp = *this;
N        --*this;
N        return __tmp;
N    }
N
N    reverse_iterator& operator+= (difference_type __n) {
N        return current -= __n, *this;
N    }
N
N    reverse_iterator& operator-= (difference_type __n) {
N        return *this += -__n;
N    }
N
N    reverse_iterator operator+ (difference_type __n) const {
N        return reverse_iterator (*this) += __n;
N    }
N
N    reverse_iterator operator- (difference_type __n) const {
N        return reverse_iterator (*this) -= __n;
N    }
N
N    reference operator[] (difference_type __n) const {
N        return *(*this + __n);
N    }
N
Nprotected:
N
N    iterator_type current;
N};
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator== (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator== (const reverse_iterator <_Iterator> & __x,
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return __x.base () == __y.base ();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator< (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator< (const reverse_iterator <_Iterator> & __x,
N                       const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                       const reverse_iterator <_Iterator> & __y)
N{
N    return __y.base() < __x.base();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator!= (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator!= (const reverse_iterator <_Iterator> & __x, 
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__x == __y);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator> (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator> (const reverse_iterator <_Iterator> & __x, 
N                       const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                       const reverse_iterator <_Iterator> & __y)
N{
N    return __y < __x;
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator<= (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator<= (const reverse_iterator <_Iterator> & __x,
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__y < __x);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator>= (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator>= (const reverse_iterator <_Iterator> & __x, 
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__x < __y);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline _RWSTD_ITER_DIFF_TYPE (_Iterator, _Distance)
Xinline typename iterator_traits<_Iterator> ::difference_type
Noperator- (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xoperator- (const reverse_iterator <_Iterator> & __x, 
N           const _RWSTD_ITER_ID (reverse_iterator)& __y)
X           const reverse_iterator <_Iterator> & __y)
N{
N    return __y.base () - __x.base ();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline _RWSTD_ITER_ID (reverse_iterator)
Xinline reverse_iterator <_Iterator>
Noperator+ (_RWSTD_ITER_DIFF_TYPE (_Iterator, _Distance) __n, 
Xoperator+ (typename iterator_traits<_Iterator> ::difference_type __n, 
N           const _RWSTD_ITER_ID (reverse_iterator)&     __x)
X           const reverse_iterator <_Iterator> &     __x)
N{
N    return __x + __n;
N}
N
N#undef _RWSTD_ITER_DIFF_TYPE
N
N#ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC
S
S_RWSTD_NAMESPACE_END   // std
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// Reverse bidirectional iterator.       
S// This is needed to get around non-standard compilers that insist
S// on instantiating all members of a class whether they're used 
S// or not.
S
Stemplate <class _Iterator, class _Category, class _TypeT, 
S          class _Reference _RWSTD_COMPLEX_DEFAULT (_TypeT&), 
S          class _Pointer _RWSTD_COMPLEX_DEFAULT (_TypeT*), 
S          class _Distance _RWSTD_COMPLEX_DEFAULT (ptrdiff_t) >
Sclass __reverse_bi_iterator
S    : public _STD::iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>
S{
Spublic:
S    typedef _Distance  difference_type;
S    typedef _TypeT     value_type;
S    typedef _Reference reference;
S    typedef _Pointer   pointer;
S    typedef _Iterator  iterator_type;
S
S    __reverse_bi_iterator () { }
S
S    _EXPLICIT __reverse_bi_iterator (const iterator_type &__rhs) 
S        : current (__rhs) { }
S
S
S#ifndef _RWSTD_NO_MEMBER_TEMPLATES
S#  ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
S
S      template <class _TypeU>
S      __reverse_bi_iterator (const __reverse_bi_iterator<_TypeU>& __rhs)
S          : current (__rhs.base ()) { }
S
S#  else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC )
S
S      template <class _Iterator2, class _Category2, class _TypeU,
S                class _Reference2, class _Pointer2, class _Distance2>
S      __reverse_bi_iterator (const __reverse_bi_iterator<_Iterator2,
S                                                         _Category2,
S                                                         _TypeU,
S                                                         _Reference2,
S                                                         _Pointer2,
S                                                         _Distance2>& __rhs)
S          : current (__rhs.base ()) { }
S#  endif
S#endif // _RWSTD_NO_MEMBER_TEMPLATES
S
S
S    iterator_type base () const {
S        return current;
S    }
S
S    reference operator* () const {
S        iterator_type __tmp = base ();
S        return *--__tmp;
S    }
S
S    _RWSTD_OPERATOR_ARROW (pointer operator->() const);
S
S    __reverse_bi_iterator& operator++ () {
S        return --current, *this;
S    }
S
S    __reverse_bi_iterator  operator++ (int) {
S        __reverse_bi_iterator __tmp (*this);
S        ++*this;
S        return __tmp;
S    }
S
S    __reverse_bi_iterator& operator-- () {
S        return ++current, *this;
S    }
S
S    __reverse_bi_iterator operator-- (int) {
S        __reverse_bi_iterator __tmp (*this);
S        --*this;
S        return __tmp;
S    }
S
Sprotected:
S
S    iterator_type current;
S};
S
S
S_RWSTD_ITER_TEMPLATE
Sinline bool operator== (const _RWSTD_ITER_ID (__reverse_bi_iterator)& __x, 
S                        const _RWSTD_ITER_ID (__reverse_bi_iterator)& __y)
S{
S    return __x.base () == __y.base ();
S}
S
S
S_RWSTD_ITER_TEMPLATE
Sinline bool operator!= (const _RWSTD_ITER_ID (__reverse_bi_iterator)& __x,
S                        const _RWSTD_ITER_ID (__reverse_bi_iterator)& __y)
S{
S    return !(__x == __y);
S}
S
S#undef _RWSTD_ITER_TEMPLATE
S#undef _RWSTD_ITER_ID
S
S_RWSTD_NAMESPACE_END   // __rw
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N#  define _RWSTD_INSERT_ITERATOR_BASE(ignore)       \
N          iterator<output_iterator_tag, void, void, void, void>
X#  define _RWSTD_INSERT_ITERATOR_BASE(ignore)                 iterator<output_iterator_tag, void, void, void, void>
N#else
S   // necessary to allow __iterator_category, __value_type, etc. to work
S#  define _RWSTD_INSERT_ITERATOR_BASE(cont)         \
S          iterator<output_iterator_tag,             \
S                   _TYPENAME cont::value_type,      \
S                   _TYPENAME cont::difference_type, \
S                   _TYPENAME cont::pointer,         \
S                   _TYPENAME cont::reference>
X#  define _RWSTD_INSERT_ITERATOR_BASE(cont)                   iterator<output_iterator_tag,                                _TYPENAME cont::value_type,                         _TYPENAME cont::difference_type,                    _TYPENAME cont::pointer,                            _TYPENAME cont::reference>
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
Ntemplate <class _Container>
Nclass back_insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass back_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    _EXPLICIT back_insert_iterator (container_type& __rhs)
X    explicit back_insert_iterator (container_type& __rhs)
N        : container (&__rhs) { }
N
N    back_insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) {
X    operator= (typename container_type::const_reference __x) {
N        return container->push_back (__x), *this;
N    }
N
N    back_insert_iterator& operator*  () {
N        return *this;
N    }
N
N    back_insert_iterator& operator++ () {
N        return *this;
N    }
N
N    back_insert_iterator operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    container_type* container;
N};
N
N
Ntemplate <class _Container>
Ninline back_insert_iterator<_Container> back_inserter (_Container& __x)
N{
N    return back_insert_iterator<_Container>(__x);
N}
N
N
Ntemplate <class _Container>
Nclass front_insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass front_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    _EXPLICIT front_insert_iterator (container_type& __rhs)
X    explicit front_insert_iterator (container_type& __rhs)
N        : container (&__rhs) { }
N
N    front_insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) { 
X    operator= (typename container_type::const_reference __x) { 
N        return container->push_front (__x), *this;
N    }
N
N    front_insert_iterator& operator* () {
N        return *this;
N    }
N
N    front_insert_iterator& operator++ () {
N        return *this;
N    }
N
N    front_insert_iterator operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    container_type* container;
N};
N
N
Ntemplate <class _Container>
Ninline front_insert_iterator<_Container> front_inserter (_Container& __x)
N{
N    return front_insert_iterator<_Container>(__x);
N}
N
N
Ntemplate <class _Container>
Nclass insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    insert_iterator (container_type                    &__x,
N                     _TYPENAME container_type::iterator __it)
X                     typename container_type::iterator __it)
N      : iter (__it), container (&__x) { }
N
N    insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) { 
X    operator= (typename container_type::const_reference __x) { 
N        iter = container->insert (iter, __x);
N        return ++iter, *this;
N    }
N
N    insert_iterator& operator* () {
N        return *this;
N    }
N
N    insert_iterator& operator++ () {
N        return *this;
N    }
N
N    insert_iterator& operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    _TYPENAME container_type::iterator iter;
X    typename container_type::iterator iter;
N    container_type*                    container;
N};
N
N
Ntemplate <class _Container, class _Iterator>
Ninline insert_iterator<_Container> inserter (_Container& __x, _Iterator __it)
N{
N    typedef _TYPENAME _Container::iterator _Iter;
X    typedef typename _Container::iterator _Iter;
N
N    return insert_iterator<_Container> (__x, _Iter (__it));
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#endif   // _RWSTD_ITERATOR_H_INCLUDED
N
L 40 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N#include <rw/_strref.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_strref.h" 1
N/***************************************************************************
N *
N * _strref.h - Declarations for the Standard Library string_ref classes
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_STRREF_H_INCLUDED
N#define _RWSTD_STRREF_H_INCLUDED
N
N#include <memory>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * memory - declarations for the Standard Library memory implementation
N *
N * $Id$ 
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/ 
N
N#ifndef _RWSTD_MEMORY_INCLUDED
N#define _RWSTD_MEMORY_INCLUDED
N
N#include <new>
N#include <utility>
N
N#include <rw/_iterbase.h>
N#include <rw/_mutex.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_mutex.h" 1
N/***************************************************************************
N *
N * _mutex.h - Definitions of classes and inline functions providing MT safety
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************
N *
N * There are two mutex classes:
N *
N * __rw::__rw_mutex_base - a POD-type class with no ctor or dtor (POSIX
N * and Solaris threads only) suitable for mutex objects with static storage
N * duration. On POSIX threads, these objects are fully constructed at static
N * initialization time and initialized via assignment by 
N * PTHREAD_MUTEX_INITIALIZER, while on Solaris threads they do not need to be
N * initialized at all. On platforms such as Win32/64 that do not support static
N * initialization this class does define a ctor that initializes the object
N * by the appropriate thread library call.
N *
N * __rw::__rw_mutex - a non-POD-type class derived from __rw::__rw_mutex_base
N * with explicitly defined ctor and dtor suitable for mutex member variables.
N * On platforms such as Win32/64 that do not support static initialization this
N * class does not define its own ctor and dtor and simply defers the
N * initialization and destruction to its base.
N *
N * __rw::__rw_static_mutex<> - a POD-type class template, defined on
N * platforms such as POSIX or Solaris threads that support static
N * initialization of mutexes, containing a single public static data member
N * of the __rw::__rw_mutex_base class. The static member object is returned
N * from the factory function template __rw::__rw_get_static_mutex<>().
N *
N * On platforms such as Win32/64 that do not support static initialization
N * of mutex objects the factory template function
N * __rw::__rw_get_static_mutex<>() defines and dynamically initializes
N * a static local reference to an object of the __rw::__rw_mutex_base class.
N * The dynamic initialization is done in an MT-safe way (i.e., such that
N * exactly one initialization of the mutex object is guaranteed). On Win32/64
N * this is accomplished by making use of the InterlockedIncrement() API call,
N * everywhere else there exists a small potential for a race condition and
N * the risk of the object being initialized multiple times. The reference is
N * initialized to refer to a properly aligned static data buffer to prevent
N * the destruction of the actual object at program termination, and the object
N * itself is constructed in this buffer space via a call to placement new.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_MUTEX_H_INCLUDED
N#define _RWSTD_MUTEX_H_INCLUDED
N
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTRING
X#include <cstring>
N
N#ifdef _RWSTD_MULTI_THREAD
S
S
S#include <rw/_exception.h>
S
S
S#if defined (_RWSTD_SOLARIS_THREADS)  // assuming Solaris 2.1 or greater
S
S// SunOS 5.7 Threads Library:
S//   "A statically  allocated  mutex does  not  need to be explicitly
S//   initialized; by default, a statically allocated mutex is initialized
S//   with  all  zeros and its scope is set to be within the calling
S//   process."
S
S#  include <synch.h>
S#  include <thread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      mutex_init (&mutex, USYNC_THREAD, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                mutex_t
S
S#elif defined (_RWSTD_POSIX_D10_THREADS)
S
S// LinuxThreads man page:
S//   "Variables of type pthread_mutex_t can also be initialized
S//    statically, using the constants  PTHREAD_MUTEX_INITIALIZER
S//    (for fast mutexes), PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
S//    (for recursive mutexes), and PTHREAD_ERRORCHECK_MUTEX_INI-
S//    TIALIZER_NP (for error checking mutexes)."
S//    ...
S//    "Attempting to initialize an already initialized mutex results
S//    in undefined behavior."
S
S#  include <pthread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      pthread_mutex_init (&mutex, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S#elif defined (_RWSTD_DCE_THREADS)
S
S#  if defined (_RWSTD_NO_DCE_PTHREAD_H)
S#    include <pthread.h>
S#  else
S#    include <dce/pthread.h>
S#  endif
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          pthread_mutex_init (&mutex, pthread_mutexattr_default)
X#  define _RWSTD_MUTEX_INIT(mutex)           pthread_mutex_init (&mutex, pthread_mutexattr_default)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S// DCE doesn't seem to support static mutex initialization
S#  include <new>
S
S#elif defined (_WIN32) || defined (_WIN64)
S
S#  ifdef _RWSTD_NO_FWD_DECLARATIONS
S
S#    include <windows.h>
S#    define _RWSTD_MUTEX_T _RTL_CRITICAL_SECTION
S
S#  else   // if defined (_RWSTD_NO_FWD_DECLARATIONS)
S
S   // avoid #including this header...
S   // #  include <windows.h>
S
Sextern "C" {
S
S// but rather declare these globals here
Sstruct _RTL_CRITICAL_SECTION;
S
S__declspec (dllimport) void __stdcall
SInitializeCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SEnterCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SLeaveCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SDeleteCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) long __stdcall
SInterlockedIncrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedDecrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedExchange (long*, long);
S
S}   // extern "C"
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// fake critical section type
Sunion __rw_critical_section {
S    long _C_pad;   // force alignment
S    char _C_buf [24 /* == sizeof (_RTL_CRITICAL_SECTION) */];
S};
S
S#    define _RWSTD_MUTEX_T _RW::__rw_critical_section
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S#  endif   // _RWSTD_NO_FWD_DECLARATIONS
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// Win32/64 throws non-C++ exceptions rather than returning error status
S// from some system calls like most other operating systems do
S
Sinline int __rw_mutex_init (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        InitializeCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_destroy (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        DeleteCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_lock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        EnterCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_unlock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        LeaveCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
S#  define _RWSTD_MUTEX_INIT(mutex)      \
S   __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_INIT(mutex)         __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_DESTROY(mutex)   \
S   __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_DESTROY(mutex)      __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_LOCK(mutex)      \
S   __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_LOCK(mutex)         __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    \
S   __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_UNLOCK(mutex)       __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#elif defined (__OS2__)
S
S#  define INCL_DOSSEMAPHORES
S
S#  include <os2.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
X#  define _RWSTD_MUTEX_INIT(mutex)           DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   DosCloseMutexSem (mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex) \
S          DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
X#  define _RWSTD_MUTEX_LOCK(mutex)           DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    DosReleaseMutexSem (mutex)
S#  define _RWSTD_MUTEX_T                HMTX
S
S#else
S#  error unknown thread environment
S#endif
S
S
S#if defined (__DECCXX)
S   // get declarations of __ATOMIC_XXX intrinsics
S
S#  include <machine/builtins.h>
S
S#endif   // __DECXX
S
S
S#if defined (__GNUG__) && defined (__osf__)
S   // prevent g++ warnings about missing initializers
S   // see <pthread.h> for explanation of _PTHREAD_NOMETER_STATIC
S#  ifndef _PTHREAD_NOMETER_STATIC
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER \
S            { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA, \
S              0, 0, 0, 0, 0, 0 }
X#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER             { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA,               0, 0, 0, 0, 0, 0 }
S#  else   // if defined (_PTHREAD_NOMETER_STATIC)
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER
S            { 0, _PTHREAD_MVALID | _PTHREAD_MVF_STA, 0, 0, 0, 0, 0, 0 }
S#  endif   // _PTHREAD_NOMETER_STATIC
S#elif defined (__GNUG__) && defined (__sgi__)
S   // prevent g++ warnings about a partly bracketed initializer
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER }
S#else
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
S#endif
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// a using declaration (rather than a directive)
S// used to work around yet another MSVC 6.0 bug
S_USING (std::exception);
S
Sclass __rw_thread_error : public exception
S{
Spublic:
S    __rw_thread_error () _THROWS (())
S    : exception () { }
S
S    virtual const char* what () const _THROWS (()) {
S        return "thread synchronization error";
S    }
S};                            
S
S
S// POD type with no user-defined ctor or dtor facilitates static
S// initialization of mutex objects with static storage duration
S// (important during library initialziation time)
Sclass _RWSTD_EXPORT __rw_mutex_base
S{
Spublic:
S
S    void _C_acquire () {
S#if !defined (__HP_aCC) || __HP_aCC > 32700
S        if (0 != _RWSTD_MUTEX_LOCK (_C_mutex))
S            _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR,
S                             "synchronization error");
S#else
S        // working around an HP aCC 3.27 bug JAGac88738
S        _RWSTD_MUTEX_LOCK (_C_mutex);
S#endif   // !defined (__HP_aCC) || __HP_aCC > 32700
S    }
S
S    void _C_release ();
S
S#ifdef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    // static initialization not an option, define ctor and dtor
S    // and make member mutex private
S
S    __rw_mutex_base ();
S
S    ~__rw_mutex_base ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex_base (const __rw_mutex_base&);
S    __rw_mutex_base& operator= (const __rw_mutex_base&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S    _RWSTD_MUTEX_T _C_mutex;   // the real thing
S};
S
S
Sinline void __rw_mutex_base::_C_release ()
S{
S    // we should NOT throw from here as _C_release will typically be called
S    // during the destruction of local objects such as __rw_guard (perhaps
S    // due to another exception)
S    _RWSTD_MUTEX_UNLOCK (_C_mutex);
S}
S
S
S// non-POD type, always initializes mutex data member via a function call
Sclass  _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
S{
Spublic:
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    __rw_mutex ();
S
S    ~__rw_mutex ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex (const __rw_mutex&);
S    __rw_mutex& operator= (const __rw_mutex&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S};
S
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S// helper factory class - static member is guranteed to be constructed
S// during static initialization; objects of this POD class are not
S// destroyed during program termination (important to allow them
S// to be used in dtors of other objects with static storage duration)
Stemplate <class _TypeT>
Sstruct __rw_static_mutex
S{
S    static __rw_mutex_base _C_mutex;
S};
S
S
Stemplate <class _TypeT>
S__rw_mutex_base __rw_static_mutex<_TypeT>::_C_mutex
S
S#ifdef _RWSTD_POSIX_D10_THREADS
S
S    = { _RWSTD_PTHREAD_MUTEX_INITIALIZER }
S
S#endif   // _RWSTD_POSIX_D10_THREADS
S        ;
S
S// explicitly instantiated to work around a g++ 2.95.2 bug on COFF systems
S// (such as IBM AIX or DEC OSF1) where it "forgets" to do so implicitly for
S// explicitly initialized static data members
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<int>);
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<size_t>);
S
S
Sinline __rw_mutex::__rw_mutex ()
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::__rw_mutex_base ()
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{ 
S    if (0 != _RWSTD_MUTEX_INIT (_C_mutex))
S        _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR, "synchronization error");
S}
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Sinline __rw_mutex::~__rw_mutex () 
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::~__rw_mutex_base () 
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{
S    _RWSTD_MUTEX_DESTROY (_C_mutex);
S}
S
S
S// mutex factory function avoids problematic initialization dependencies
S// introduced by definitions of mutexes with static storage duration
S// instead of defining a static mutex member that may not be initialized
S// before first use, a non-local class may either declare a unique type
S// (enum or class) or use itself as this type, and call this template
S// function with a ptr to that type to obtain an initialized mutex object
S// that is the same for each unique type passed to the function
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Stemplate <class _TypeT>
Sinline
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S{
S    // POD mutex already initialized during static initialization
S    return __rw_static_mutex<_TypeT>::_C_mutex;
S}
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
S#ifdef _INLINE_WITH_STATICS
S
Stemplate <class _TypeT>
S_INLINE_WITH_STATICS
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#else    // if !defined (_INLINE_WITH_STATICS)
S
Stemplate <class _TypeT>
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#endif   // _INLINE_WITH_STATICS
S
S{
S    // allocate properly aligned memory for static mutex (necessary
S    // to prevent static local mutex from being destroyed during
S    // program termination)
S    union __mutex_buf_t {
S        long double __pad;   // force alignment (must be first)
S        char        __buf [sizeof (__rw_mutex_base)];
S    };
S
S    // using a named union to work around a bug in HP aCC 3.14.10 (JAGad03246)
S    static __mutex_buf_t __mutex_buf;
S
S    // initialize mutex reference to refer to the static buffer space
S    __rw_mutex_base &__mutex =
S        _RWSTD_REINTERPRET_CAST (__rw_mutex_base&, __mutex_buf);
S
S    // keep track of number of mutex initialization attempts
S    // although `init' may reach a value greater than 1, `mutex'
S    // will (should) never be multiply initialized
S
S    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
S    // sorry: semantics of inline function static data are wrong (you'll wind
S    // up with multiple copies)
S    static volatile long __cntr /* = 0 */;   // initialization counter
S
S#if defined (_WIN32) || defined (_WIN64)
S    // MT safe
S    if (0 == __cntr && 1 == InterlockedIncrement ((long*)&__cntr))
S#else
S    // not so safe (volatile should help)
S    if (0 == __cntr && 1 == ++__cntr)
S#endif   // _WIN32
S
S    {
S        // manually initialize `mutex' via a call to placement new
S        new (&__mutex) __rw_mutex_base ();
S
S        // indicate that `mutex' has been fully initialized
S        // (unlikely that we'll have more than 1000 threads)
S        __cntr += 1000;
S    }
S    else
S        // busywait until `mutex' has been completely initialized
S        while (__cntr < 1000);
S
S    return __mutex;
S}
S
S#endif   //_RWSTD_NO_STATIC_MUTEX_INIT
S
S
S// clean up
S#undef _RWSTD_MUTEX_LOCK
S#undef _RWSTD_MUTEX_UNLOCK
S#undef _RWSTD_MUTEX_T
S
S
S// allows safe use of a mutex in the presence of exceptions
Sclass __rw_guard
S{
S    __rw_mutex_base *_C_mutex;
S
S    // undefined
S    __rw_guard& operator= (const __rw_guard&);
S    
Spublic:
S
S    __rw_guard (__rw_guard &__rhs)
S        : _C_mutex (__rhs._C_mutex) {
S        __rhs._C_mutex = 0;
S    }
S
S    __rw_guard (__rw_mutex_base &__mutex): _C_mutex (&__mutex) {
S        _C_mutex->_C_acquire ();
S    }
S
S    __rw_guard (__rw_mutex_base *__mutex): _C_mutex (__mutex) {
S        if (_C_mutex)
S            _C_mutex->_C_acquire ();
S    }
S
S    ~__rw_guard () {
S        if (_C_mutex)
S            _C_mutex->_C_release ();
S    }
S
S    __rw_mutex_base* _C_set (__rw_mutex_base *__mutex) {
S        __rw_mutex_base *__tmp = _C_mutex;
S        return _C_mutex = __mutex, __tmp;
S    }
S};
S
S
S// base class for obects required to guarantee some degree of MT safety
Sstruct _RWSTD_EXPORT __rw_synchronized
S{
S    __rw_mutex _C_mutex;
S
S    void _C_lock () {
S        _C_mutex._C_acquire ();
S    }
S
S    void _C_unlock () {
S        _C_mutex._C_release ();
S    }
S
S    __rw_guard _C_guard () {
S        __rw_guard __guard (_C_mutex);
S        return __guard;
S    }
S};
S
S
S// helper functions for atomic value [in|de]crement and exchange
S// the functions are atomic with respect to each other as long as
S// they are passed the same mutex by the callers
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return ++__t;
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return --__t;
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u,
S                             __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    _TypeT __tmp = __t;
S    __t = __u;
S    return __tmp;
S}
S
S
S// for use on class statics or on namespace-scope variables
S// the unused argument is only here so that all functions can be
S// called from the same set of macros
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_preincrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_predecrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
S{
S    return __rw_atomic_exchange (__t, __u,
S                                 __rw_get_static_mutex ((_TypeT*)0));
S}
S
S/********************** DEC CXX **************************************/
S
S#if defined (__DECCXX) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// __ATOMIC_[DE|IN]CREMENT_[LONG|QUAD] and __ATOMIC_EXCH_[LONG|QUAD] are
S// intrinsic functions declared in <machine/builtins.h> that atomically
S// modify their argument and return its original value (__ATOMIC_XXX_LONG
S// is misnamed -- it actually operates on an int, not a long)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_LONG (&__x);
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_QUAD (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    return __ATOMIC_DECREMENT_LONG (&__x) - 1;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return __ATOMIC_DECREMENT_QUAD (&__x) - 1;
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    return __ATOMIC_EXCH_LONG (&__x, __y);
S}
S
S
Sinline
Sunsigned __rw_atomic_exchange (unsigned &__x, unsigned __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned&, __x),
S                                 _RWSTD_STATIC_CAST (int, __y), false);
S}
S
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return __ATOMIC_EXCH_QUAD (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S/********************** gcc/i86 **************************************/
S
S#elif defined (__i386__) && defined (__GNUG__)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; addl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; subl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S/********************** WIN 32/64 ************************************/
S
S#elif defined (_WIN32) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// Interlocked[In|De]crement functions atomically modify their argument
S// and return the new value
S
S// InterlockedExchange atomically sets the value pointed to by the first
S// argument to that of the second argument and returns the original value
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return InterlockedIncrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return InterlockedDecrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return InterlockedExchange (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S#endif   // _WIN64
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_preincrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_predecrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y,
S                                   __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y,
S                              __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   __mutex));
S}
S
S#endif   // _WIN64
S
S#endif   // _WIN32
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
N#else   // if !defined (_RWSTD_MULTI_THREAD)
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// atomic in a single-threaded environment
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N
N// dummy classes used as a base class in single-threaded environments
N
Nstruct __rw_mutex_base
N{
N    void _C_acquire () { }
N
N    void _C_release () { }
N};
N
N
Nstruct _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
Xstruct  __rw_mutex: public __rw_mutex_base
N{
N};
N
N
Nstruct __rw_guard
N{
N    __rw_guard (__rw_mutex_base&) { }
N
N    __rw_guard (__rw_mutex_base*) { }
N
N    __rw_mutex_base* _C_set (__rw_mutex_base*) {
N        return 0;
N    }
N};
N
N
Nstruct __rw_synchronized
N{
N    // static so that it takes up no room
N    static __rw_mutex _C_mutex;
N
N    void _C_lock () { }
N
N    void _C_unlock () { }
N
N    __rw_guard _C_guard () {
N        return __rw_guard (_C_mutex);
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// available in all environments (ST and MT), used along with
N// __rw_atomic_exchange<>() from conditional expressions in iostreams
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_ordinary_exchange (_TypeT &__t, const _TypeU &__u)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MUTEX_H_INCLUDED
N
L 53 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// [de]allocate storage (in bytes)
N_RWSTD_EXPORT void* __rw_allocate (_RWSTD_C::size_t, int = 0);
X void* __rw_allocate (std::size_t, int = 0);
N_RWSTD_EXPORT void  __rw_deallocate (void*, _RWSTD_C::size_t, int = 0);
X void  __rw_deallocate (void*, std::size_t, int = 0);
N
N// this function returns a suggested new capacity for a container needing
N// more room; see stddefs.h for an explanation of these macro parameters;
N// the _Container template parameter allows more specialized overloads
N// for customization
Ntemplate <class _Container>
Ninline _RWSTD_C::size_t __rw_new_capacity (_RWSTD_C::size_t __size, const _Container*)
Xinline std::size_t __rw_new_capacity (std::size_t __size, const _Container*)
N{
N    _RWSTD_C::size_t __cap = _RWSTD_STATIC_CAST (_RWSTD_C::size_t,
N                                       _RWSTD_INCREASE_CAPACITY(__size)
N                                       /*__size * _RWSTD_NEW_CAPACITY_RATIO*/);
X    std::size_t __cap = static_cast< std::size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));
N    return (__size += _RWSTD_MINIMUM_NEW_CAPACITY) > __cap ? __size : __cap;
X    return (__size += std::size_t (32)) > __cap ? __size : __cap;
N}
N
N
Ntemplate <class _TypeT>
Ninline void __rw_destroy (_TypeT &__ref)
N{
N    __ref.~_TypeT ();
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_construct (_TypeT* __p, const _TypeU& __val)
N{
N    new (__p) _TypeT (__val);
N}
N
N
Ntemplate <class _ForwardIterator> 
Nvoid __rw_destroy (_ForwardIterator __first, _ForwardIterator __last)
N{
N    for (; __first != __last; ++__first)
N        __rw_destroy (*__first);
N}
N
N
N#ifndef _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N// for compilers that don't optimize "empty" loops
Ntemplate <class _TypeT> 
Ninline void __rw_destroy (_TypeT**, _TypeT**)
N{ }
N
N#endif   // _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _TypeT> class
Nallocator;
N
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nclass allocator<void>
N{
Npublic:
N    typedef void*       pointer;
N    typedef const void* const_pointer;
N    typedef void        value_type;
N   
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N#endif /* _RWSTD_ALLOCATOR */
N    
N};
N
N
Ntemplate <class _TypeT>
Nclass allocator
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef _TypeT              value_type;
N    typedef value_type*         pointer;
N    typedef const value_type*   const_pointer;
N    typedef value_type&         reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator&
N    operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N    pointer address (reference __x) const { 
N        return &__x; 
N    }
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    pointer allocate (size_type __n, allocator<void>::const_pointer = 0) {
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (pointer __p, size_type __n)
N#else
S    void deallocate (void* __p, size_type __n)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (__p, __n);
X        __rw::__rw_deallocate (__p, __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return size_type (~0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (pointer __p, const_reference __val) {
N        _RW::__rw_construct (__p, __val);
X        __rw::__rw_construct (__p, __val);
N    }
N    
N    void destroy (pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (*__p);
X        __rw::__rw_destroy (*__p);
N    }
N};
N
N
N#if    !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_EXT_CONST_ALLOCATOR)
X#if    !0L     && !0L
N
N// extension: allocates/constructs/destroys const elements
N
Ntemplate <class _TypeT>
Nclass allocator<const _TypeT>
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef const _TypeT        value_type;
N    typedef const value_type*   pointer;
N    typedef const value_type*   const_pointer;
N    typedef const value_type&   reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator& operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    allocator& operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    const_pointer
N    allocate (size_type __n, allocator<void>::const_pointer = 0) { 
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (const_pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< const_pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (const_pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (const_pointer __p, size_type __n /* elements */)
N#else
S    void deallocate (const void* __p, size_type __n /* bytes */)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (_RWSTD_CONST_CAST (_TypeT*, __p), __n);
X        __rw::__rw_deallocate (const_cast< _TypeT* >(__p), __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return ~size_type (0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (const_pointer __p, const_reference __val) {
N        _RW::__rw_construct (_RWSTD_CONST_CAST (_TypeT*, __p), __val);
X        __rw::__rw_construct (const_cast< _TypeT* >(__p), __val);
N    }
N    
N    void destroy (const_pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (_RWSTD_CONST_CAST (_TypeT&, *__p));
X        __rw::__rw_destroy (const_cast< _TypeT& >(*__p));
N    }
N};
N
N#endif   // !_RWSTD_NO_CLASS_PARTIAL_SPEC && !_RWSTD_NO_EXT_CONST_ALLOCATOR)
N
N
N// allocator_interface provides all types and typed functions.  Memory
N// allocated as raw bytes using the class provided by the Allocator
N// template parameter.  allocator_interface casts appropriately.
N//
N// Multiple allocator_interface objects can attach to a single 
N// allocator, thus allowing one allocator to allocate all storage
N// for a container, regardless of how many types are involved.
N//
N// The only real restriction is that pointer and reference are
N// hard coded as _TypeT* and _TypeT&.  Partial specialization would 
N// get around this.
N//
N#ifndef _RWSTD_ALLOCATOR
S
Stemplate <class _Allocator, class _TypeT>
Sclass allocator_interface 
S{
Spublic:
S    typedef _Allocator                                allocator_type;
S    typedef _TypeT                                    value_type;
S    typedef value_type*                               pointer;
S    typedef const value_type*                         const_pointer;
S    typedef value_type&                               reference;
S    typedef const value_type&                         const_reference;
S    typedef _TYPENAME allocator_type::size_type       size_type;
S    typedef _TYPENAME allocator_type::difference_type difference_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface()  _THROWS (())  { }
S
S    allocator_interface (const allocator_type &__alloc)  _THROWS (())
S    : _C_alloc (__alloc) { }
S
S    operator allocator_type& () {
S        return _C_alloc;
S    }
S
S    pointer address (reference __x) { 
S        return &__x;
S    }
S  
S    size_type max_size () const { 
S        return _C_alloc.max_size () / sizeof (value_type);
S    }
S
S    pointer allocate (size_type __n, const void* __p = 0) {
S        //using c-style cast to perform reinterpret-cast & const-cast in 1 step
S        return (pointer)_C_alloc.allocate (__n * sizeof (value_type),
S                                           (pointer) __p );
S    }
S
S    void deallocate (pointer __p, size_type __n) {
S        _C_alloc.deallocate (__p, __n);
S    }
S
S    void construct (pointer __p, const_reference __val) const {
S        _RW::__rw_construct(__p, __val);
S    }
S
S    void destroy (pointer __p) const {
S        _RWSTD_ASSERT (0 != __p);
S        _RW::__rw_destroy (*__p);
S    }
S};
S
S
S_RWSTD_SPECIALIZED_CLASS
Sclass allocator_interface<allocator<void>, void> 
S{
Spublic:
S    typedef allocator<void> allocator_type;
S    typedef void*           pointer;
S    typedef const void*     const_pointer;      
S    typedef void            value_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface () _THROWS (()) { }
S
S    allocator_interface (const allocator<void>& __rhs) _THROWS (())
S    : _C_alloc (__rhs) { }
S
S};
S
S
Stemplate <class _TypeT, class _TypeU, class _TypeV, class _TypeW>
Sinline bool
Soperator== (const allocator_interface<_TypeT, _TypeU>&, 
S            const allocator_interface<_TypeV, _TypeW>&) _THROWS (())
S{
S    return true;
S}
S
N#endif  // _RWSTD_ALLOCATOR
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  _THROWS (())
Xoperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const allocator<_TypeT>& __x,
N            const allocator<_TypeU>& __y)  _THROWS (())
X            const allocator<_TypeU>& __y)  
N{
N    return !(__x == __y);
N}
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.4.2
Ntemplate <class _OutputIterator, class _TypeT>
Nclass raw_storage_iterator
N    : public iterator<output_iterator_tag, void, void, void, void>
N{
N    _OutputIterator _C_iter;
Npublic:
N
N    // for completeness and genericity
N    typedef _OutputIterator iterator_type;
N
N    // 20.4.2, p2
N    _EXPLICIT raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
X    explicit raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
N
N    // 20.4.2, p3
N    raw_storage_iterator& operator* () {
N        return *this;
N    }
N
N    // 20.4.2, p4
N    raw_storage_iterator& operator= (const _TypeT& __rhs) {
N        ::new (&(*_C_iter)) _TypeT (__rhs);
N        return *this;
N    }
N
N    // 20.4.2, p6
N    raw_storage_iterator& operator++ () {
N        ++_C_iter;
N        return *this;
N    }
N
N    // 20.4.2, p7
N    raw_storage_iterator operator++ (int) {
N        raw_storage_iterator __tmp = *this;
N        ++*this;
N        return __tmp;
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_indestructible specializations should be objects with static
N// storage duration that must "survive" all other static objects and that
N// do not need to be destroyed; this is a POD
Ntemplate <class _TypeT>
Nclass __rw_indestructible
N{
N    union _C_data_t {
N        char        _C_data;      // data to back _TypeT up with 
N        long double _C_padding;   // make sure data is suitably aligned
N    };
N
N    enum { _C_n = 1 + sizeof (_TypeT) / sizeof (_C_data_t) };
N
N    _C_data_t _C_data [_C_n];     // raw storage for an object of _TypeT
N
Npublic:
N    typedef _TypeT            value_type;
N    typedef value_type&       reference;
N    typedef const value_type& const_reference;
N    typedef value_type*       pointer;
N    typedef const value_type* const_pointer;
N
N    // no ctor to allow static POD initialization (3.6.2, p1)
N
N    // allow this to be used as a an obejct of another type
N    operator reference () {
N        return _RWSTD_REINTERPRET_CAST (reference, *_C_data);
X        return reinterpret_cast< reference >(*_C_data);
N    }
N
N    operator const_reference () const {
N        return _RWSTD_REINTERPRET_CAST (const_reference, *_C_data);
X        return reinterpret_cast< const_reference >(*_C_data);
N    }
N
N    // calls a conversion operator above
N    pointer operator& () {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (reference, *this);
N
N        return &(reference)*this;
N    }
N    
N    // calls a conversion operator above
N    const_pointer operator& () const {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (const_reference, *this);
N
N        return &(const_reference)*this;
N    }
N};
N
N
N#ifdef _INLINE_WITH_STATICS
N
N_INLINE_WITH_STATICS _RWSTD_EXPORT char* __rw_get_static_buf ()
Xinline  char* __rw_get_static_buf ()
N{
N    typedef char _CharBuf [_RWSTD_TMPBUF_SIZE + 1];
X    typedef char _CharBuf [4096 + 1];
N
N    // use `indestructible' to guarantee proper buffer alignment
N    static __rw_indestructible<_CharBuf> __buffer;
N
N    return _RWSTD_STATIC_CAST (char*, __buffer);
X    return static_cast< char* >(__buffer);
N}
N
N
N// [de]allocates a previously allocated temporary buffer
N// the constant _RWSTD_TMPBUF_SIZE controls the size of a static buffer
N// if request for area larger than _RWSTD_TMPBUF_SIZE comes in,
N// space is allocated dynamically, otherwise the static buffer is used
N// return value meaningful only if __n != 0
N_INLINE_WITH_STATICS _RWSTD_EXPORT _STD::pair<void*, _RWSTD_C::size_t>
Xinline  std::pair<void*, std::size_t>
N__rw_reallocate_temp_buffer (void *__p, _RWSTD_C::size_t __size)
X__rw_reallocate_temp_buffer (void *__p, std::size_t __size)
N{
N    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
N    // sorry: semantics of inline function static data are wrong (you'll wind
N    // up with multiple copies)
N
N    static unsigned long __busy /* = 0 */;   // > 0 when buffer in use
N
N    unsigned long __cntr = _RWSTD_ATOMIC_PREINCREMENT (__busy, false);
X    unsigned long __cntr = ++(__busy);
N
N    static char *__buffer = __rw_get_static_buf ();
N
N    if (__p == (void*)__buffer) {
N        __p    = 0;
N        __size = 0;
N
N        // returning buffer, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else
N        ::operator delete (__p);
N
N    if (__size == 0) {
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else if (__size > _RWSTD_TMPBUF_SIZE || __cntr > 1) {
X    else if (__size > 4096 || __cntr > 1) {
N        _TRY {
X         {
N            __p = ::operator new (__size);
N        }
N        _CATCH (...) {
X        while (0) {
N            __p    = 0;
N            __size = 0;
N        }
N
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else {
N        __p = __buffer;
N
N        // buffer used, usage counter stays non-zero
N    }
N
N    return _STD::pair<void*, _RWSTD_C::size_t>(__p, __size);
X    return std::pair<void*, std::size_t>(__p, __size);
N}
N
N#else   // if !defined (_INLINE_WITH_STATICS)
S
S_STD::pair<void*, _RWSTD_C::size_t> _RWSTD_EXPORT
S__rw_reallocate_temp_buffer (void*, _RWSTD_C::size_t);
S
N#endif   // _INLINE_WITH_STATICS
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 20.4.3 only specifies a get_temporary_buffer<>() that takes a ptrdiff_t.
N// We overload on all types so that signed integral types other than ptrdiff_t
N// can be used. This is important in getting algorithms to compile with
N// user-defined iterators (not derived from iterator<...>) whose difference
N// type is something other than ptrdiff_t.
N
N// having this overload is important in some cases for compilers that
N// do not support partial class specialization (and where as a consequence
N// iterator_traits<> isn't available)
Ntemplate <class _TypeT, class _Distance>
Ninline pair<_TypeT*, _Distance> get_temporary_buffer (_Distance __n, _TypeT*)
N{
N    pair<void*, size_t> __pair =
N        _RW::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
X        __rw::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
N
N    return make_pair (_RWSTD_STATIC_CAST (_TypeT*, __pair.first),
X    return make_pair (static_cast< _TypeT* >(__pair . first),
N                      _Distance (__pair.second / sizeof (_TypeT)));
N}
N
N
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N// 20.4.3, p1
Ntemplate <class _TypeT>
Ninline pair<_TypeT*, ptrdiff_t> get_temporary_buffer (ptrdiff_t __n)
N{
N    return get_temporary_buffer (__n, (_TypeT*)0);
N}
N
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N// 20.4.3, p3
Ntemplate <class _TypeT>
Ninline void return_temporary_buffer (_TypeT *__p)
N{
N    _RW::__rw_reallocate_temp_buffer (__p, 0);
X    __rw::__rw_reallocate_temp_buffer (__p, 0);
N}
N
N
N// 20.4.4.1
Ntemplate <class _InputIterator, class _ForwardIterator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            _RW::__rw_construct (&*__res, *__first);
X            __rw::__rw_construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __res);
X        __rw::__rw_destroy (__start, __res);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _InputIterator, class _ForwardIterator, class _Allocator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res,
N                                     _Allocator&      __alloc)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            __alloc.construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __res; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.4.2
Ntemplate <class _ForwardIterator, class _TypeT>
Ninline
Nvoid uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last,
N                         const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N// 20.4.4.3
Ntemplate <class _ForwardIterator, class _Size, class _TypeT>
Ninline
Nvoid uninitialized_fill_n (_ForwardIterator __first, _Size __n,
N                           const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _ForwardIter, class _Size, class _TypeT, class _Allocator>
Ninline
Nvoid uninitialized_fill_n (_ForwardIter __first, _Size __n,
N                           const _TypeT& __x, _Allocator& __alloc)
N{
N    _ForwardIter __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            __alloc.construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __first; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N#else   // if !defined (_RWSTD_ALLOCATOR)
S
S// Specializations for non-standard allocators.  When vector calls
S// uninitialized_{copy,fill_n} with non-standard allocator, a temporary
S// instance of allocator_interface is passed to these functions.  Since
S// C++ forbids temporaries to be passed as non-const references, we
S// use these specializations to pass a const reference (and we can force
S// allocator_interface members construct & destroy to be const).
S
Stemplate <class _InputIterator, class _ForwardIterator,
S          class _Allocator, class _TypeT>
Sinline _ForwardIterator
Suninitialized_copy (_InputIterator   __first,
S                    _InputIterator   __last,
S                    _ForwardIterator __res,
S                    const allocator_interface<_Allocator, _TypeT>& __alloc)
S{
S    _ForwardIterator __start = __res;
S
S    _TRY {
S        for (; __first != __last; ++__first, ++__res)
S            __alloc.construct (&*__res, *__first);
S    }
S    _CATCH (...) {
S        for (; __start != __res; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S
S    return __res;
S}
S
Stemplate <class _ForwardIter, class _Size,
S          class _TypeT, class _Allocator, class _TypeU>
Sinline void
Suninitialized_fill_n (_ForwardIter __first, _Size __n,
S                      const _TypeT& __x,
S                      const allocator_interface<_Allocator, _TypeU>& __alloc)
S{
S    _ForwardIter __start = __first;
S
S    _TRY {
S        for (; __n; --__n, ++__first)
S            __alloc.construct (&*__first, __x);
S    }
S    _CATCH (...) {
S        for (; __start != __first; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S}
S
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.5 - Template class auto_ptr
N
Ntemplate<class _TypeT>
Nclass auto_ptr;
N
N
N// 20.4.5, p2 (defined outside of auto_ptr<> according to the proposed
N// resolution of lwg issue 127)
Ntemplate <class _TypeT>
Nclass auto_ptr_ref 
N{
Npublic:
N    auto_ptr<_TypeT>& _C_ptr;
N
N    auto_ptr_ref (auto_ptr<_TypeT>& __rhs) : _C_ptr (__rhs) { }
N};
N
N
Ntemplate<class _TypeT>
Nclass auto_ptr
N{
Npublic:
N    typedef _TypeT element_type;
N
N    _EXPLICIT auto_ptr (element_type* __p = 0) _THROWS (())
X    explicit auto_ptr (element_type* __p = 0) 
N     : _C_ptr (__p) { }
N
N    auto_ptr (auto_ptr& __rhs) _THROWS (())
X    auto_ptr (auto_ptr& __rhs) 
N     : _C_ptr (__rhs.release ()) { }
N
N    auto_ptr& operator= (auto_ptr& __rhs) _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr& __rhs)  { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N    // follows lwg issue 127
N    auto_ptr&
N    operator= (auto_ptr_ref<element_type> __rhs) _THROWS (()) {
X    operator= (auto_ptr_ref<element_type> __rhs)  {
N        reset (__rhs._C_ptr.release ());
N        return *this;
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeU>
N    operator auto_ptr_ref<_TypeU>() _THROWS (()) {
X    operator auto_ptr_ref<_TypeU>()  {
N        return auto_ptr_ref<_TypeU>(*this);
N    }
N
N    template <class _TypeU> 
N    operator auto_ptr<_TypeU>() _THROWS (()) {
X    operator auto_ptr<_TypeU>()  {
N        return auto_ptr<_TypeU>(release ());
N    }
N
N    template <class _TypeU>
N    auto_ptr (auto_ptr<_TypeU>& __rhs) _THROWS (())
X    auto_ptr (auto_ptr<_TypeU>& __rhs) 
N    : _C_ptr (__rhs.release ()) { }
N
N    template <class _TypeU>
N    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)  _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)   { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    ~auto_ptr () _THROWS (()) {
X    ~auto_ptr ()  {
N        delete _C_ptr;
N    }
N
N    element_type* get () const _THROWS (()) {
X    element_type* get () const  {
N        return _C_ptr;
N    }
N
N    element_type& operator* () const _THROWS (()) {
X    element_type& operator* () const  {
N        _RWSTD_ASSERT (0 != get ());
X        ((void)0);
N        return *get (); 
N    }
N
N    _RWSTD_OPERATOR_ARROW (
N        element_type* operator-> () const _THROWS (()))
X    element_type* operator-> () const { return & * *this; }
N
N    element_type* release () _THROWS (()) { 
X    element_type* release ()  { 
N        element_type* __tmp = _C_ptr;
N        _C_ptr = 0;
N        return __tmp; 
N    }
N
N    void reset (element_type* __p = 0) _THROWS (()) { 
X    void reset (element_type* __p = 0)  { 
N        if (_C_ptr != __p) {
N            delete _C_ptr;
N            _C_ptr = __p;
N        }
N    }
N
N    auto_ptr (auto_ptr_ref<element_type> __r) _THROWS (())
X    auto_ptr (auto_ptr_ref<element_type> __r) 
N    : _C_ptr (__r._C_ptr.release ()) { }
N
Nprivate:
N    element_type* _C_ptr;
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_MEMORY_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_strref.h" 2
N#include <rw/_mutex.h>
N#include <rw/_traits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_traits.h" 1
N/***************************************************************************
N *
N * _traits.h - Declarations for char_traits 
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_TRAITS_H_INCLUDED
N#define _RWSTD_TRAITS_H_INCLUDED
N
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N#include _RWSTD_CSTDIO
X#include <cstdio>
N#include _RWSTD_CSTRING
X#include <cstring>
N#include _RWSTD_CWCHAR
X#include <cwchar>
N
N#ifdef  _WIN64
S#   include _RWSTD_SYS_TYPES_H
N#endif
N
N#if defined (_RWSTD_STRICT_ANSI)
X#if 0L
S_RWSTD_USING_SNI (uid_t);
N#endif
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N
N// 27.4.1, p2
Ntypedef _RWSTD_SSIZE_T streamsize;
Xtypedef long streamsize;
Ntypedef _RWSTD_SSIZE_T streamoff;
Xtypedef long streamoff;
N
N
N/* fpos<> maintains all the information necessary to restore an arbitrary
N * sequence, controlled by the Standard C++ library, to a previous stream
N * position and conversion state.
N */
N
Ntemplate <class _StateT>
Nclass fpos
N{
Npublic:
N
N    typedef _StateT  state_type;
N
N    fpos (streamoff __off = 0) // allowing a default is an extension to the standard
N        : _C_pos (__off),
N          _C_state ()
N        {
N    }
N
N    fpos (streamoff __off, state_type __state) // allowing two arguments is an extension to the standard
N        : _C_pos (__off),
N          _C_state (__state)
N        { }
N
N    operator streamoff () const {
N        return _C_pos;
N    }
N
N    fpos (const fpos&);
N
N    fpos& operator= (const fpos&);
N
N    state_type state () const {
N        return _C_state;
N    }
N
N    void state (state_type __state) {
N        _C_state = __state;
N    }
N
N    // arithmetic operators
N    fpos operator- (const fpos &__off) const {
N        return fpos (*this) -= __off;
N    }
N
N    fpos operator+ (const fpos &__off) const {
N        return fpos (*this) += __off;
N    }
N
N    fpos& operator-= (const fpos &__off) {
N        return _C_pos -= __off._C_pos, *this;
N    }
N
N    fpos& operator+= (const fpos &__off) {
N        return _C_pos += __off._C_pos, *this;
N    }
N
N    fpos operator- (streamoff __off) const {
N        return fpos (*this) -= __off;
N    }
N
N    fpos operator+ (streamoff __off) const {
N        return fpos (*this) += __off;
N    }
N
N    fpos& operator-= (streamoff __off) {
N        return _C_pos -= __off, *this;
N    }
N
N    fpos& operator+= (streamoff __off) {
N        return _C_pos += __off, *this;
N    }
N
N    // relational operators
N    bool operator== (const fpos& __rhs) const; 
N
N    bool operator< (const fpos& __rhs) const {
N        return _C_pos < __rhs._C_pos;
N    }
N
N    bool operator<= (const fpos& __rhs) const {
N        return !(__rhs < *this);
N    }
N
N    bool operator>= (const fpos& __rhs) const {
N        return !(*this < __rhs);
N    }
N
N    bool operator!= (const fpos& __rhs) const {
N        return !(*this == __rhs);
N    }
N
N    bool operator> (const fpos& __rhs) const {
N        return __rhs < *this;
N    }
N
N    bool operator== (streamoff __rhs) const {
N        return _C_pos == __rhs;
N    }
N
N    bool operator< (streamoff __rhs) const {
N        return _C_pos < __rhs;
N    }
N
N    bool operator<= (streamoff __rhs) const {
N        return _C_pos <= __rhs;
N    }
N
N    bool operator>= (streamoff __rhs) const {
N        return _C_pos >= __rhs;
N    }
N
N    bool operator> (streamoff __rhs) const {
N        return _C_pos > __rhs;
N    }
N
N    bool operator!= (streamoff __rhs) const {
N        return !(_C_pos == __rhs);
N    }
N
Nprivate:
N
N    streamoff   _C_pos;     // signed displacement
N    state_type  _C_state;   // conversion state
N};
N
N
Ntemplate <class _StateT> 
Ninline
Nfpos<_StateT>::fpos(const fpos<_StateT>& __rhs)
N{
N    _C_pos    = __rhs._C_pos;
N    _C_state  = __rhs._C_state;
N}
N
N
Ntemplate <class _StateT>
Ninline fpos<_StateT>& 
Nfpos<_StateT>::operator= (const fpos<_StateT>& __rhs)
N{
N    if (&__rhs != this) {
N        _C_pos    = __rhs._C_pos;
N        _C_state  = __rhs._C_state;
N    }
N    return *this;
N}
N
N
Ntemplate <class _StateT>
Ninline bool 
Nfpos<_StateT>::operator== (const fpos<_StateT>& __rhs) const
N{ 
N    return    _C_pos == __rhs._C_pos
N#ifndef  _RWSTD_NO_MBSTATE_COMPARE
S           && _C_state == __rhs._C_state
N#endif
N    ;
N}
N
N
Ntemplate <class  _CharT> 
Nstruct char_traits 
N{
N    typedef _CharT                   char_type;
N    typedef int                      int_type;
N    typedef streamoff                off_type;
N    typedef mbstate_t                state_type;
N    typedef fpos<state_type>         pos_type;
N
N    static int_type eof () {
N        return EOF;
X        return (-1);
N    }
N
N    static void assign (char_type& __c1, const char_type& __c2) {
N        __c1 = __c2;
N    }
N
N    static bool eq (const char_type& __c1, const char_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static bool lt (const char_type& __c1, const char_type& __c2) {
N        return __c1 < __c2;
N    }
N
N    static int compare (const char_type* __s1, const char_type* __s2,
N                        _RWSTD_C::size_t __n) {
X                        std::size_t __n) {
N        _RWSTD_C::size_t __i = 0;
X        std::size_t __i = 0;
N        while (__i < __n) { 
N            if (!eq (__s1[__i], __s2[__i])) {
N                return lt (__s1[__i], __s2[__i]) ? -1 : 1;
N            }
N            ++__i;
N        }
N        return 0;
N    }
N        
N    static _RWSTD_C::size_t length (const char_type *__s) {
X    static std::size_t length (const char_type *__s) {
N        _RWSTD_C::size_t __len = 0;
X        std::size_t __len = 0;
N        while (!eq (*__s++, char_type ()))
N            ++__len;
N        return __len;
N    }
N 
N    static const char_type* 
N    find (const char_type* __s, _RWSTD_C::size_t __n, const char_type& __a) {
X    find (const char_type* __s, std::size_t __n, const char_type& __a) {
N        while (__n-- > 0 && !eq (*__s, __a) )
N            ++__s;
N        return  eq (*__s, __a) ? __s : 0;
N    }
N
N    static char_type* move (char_type* __s1, const char_type* __s2,
N                            _RWSTD_C::size_t __n) {
X                            std::size_t __n) {
N        if (__s1 < __s2)
N            copy (__s1, __s2, __n);
N        else if (__s1 > __s2) {
N            __s1 += __n;
N            __s2 += __n;
N            for (_RWSTD_C::size_t __i = 0; __i < __n; ++__i) 
X            for (std::size_t __i = 0; __i < __n; ++__i) 
N                assign (*--__s1, *--__s2);
N        }
N        return __s1;
N    }
N
N    static char_type* copy (char_type *__dst, const char_type *__src,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N        memcpy (__dst, __src, __n * sizeof (char_type));
N        return __dst;
N    }
N
N    static char_type*  assign (char_type* __s, _RWSTD_C::size_t __n, char_type __a) {
X    static char_type*  assign (char_type* __s, std::size_t __n, char_type __a) {
N        char_type* __tmp = __s;
N        while (__n-- > 0) 
N            assign (*__tmp++, __a);
N        return __s;
N    }
N
N    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static int_type not_eof (const int_type& __c) {
N        return eq_int_type (eof (), __c) ? 0 : __c;
N    }
N
N    static char_type to_char_type (const int_type& __c) {
N        return __c;
N    }
N      
N    static int_type to_int_type (const char_type& __c) {
N        return __c;
N    }
N};
N
N
N// 21.1.3.1
N_RWSTD_SPECIALIZED_CLASS  
Xtemplate< >  
Nstruct char_traits<char> 
N{
N    typedef char                      char_type;
N    typedef _RWSTD_INT_T              int_type;
X    typedef int              int_type;
N    typedef streamoff                 off_type; 
N    typedef mbstate_t                 state_type;
N    typedef fpos<state_type>          pos_type;
N
N    static int_type eof () {
N        return EOF;
X        return (-1);
N    }
N
N    static void assign (char_type& __c1, const char_type& __c2){
N        __c1 = __c2;
N    }
N
N    static bool eq (const char_type& __c1, const char_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static bool lt (const char_type& __c1, const char_type& __c2) {
N        return __c1 < __c2;
N    }
N
N    static int compare (const char_type* __s1, const char_type* __s2,
N                        _RWSTD_C::size_t __n) {
X                        std::size_t __n) {
N        return memcmp (__s1, __s2, __n);
N    }
N
N    static const char_type* find (const char_type* __s, 
N                                  _RWSTD_C::size_t __n, const char_type& __a) {
X                                  std::size_t __n, const char_type& __a) {
N        return (char_type*) memchr (__s, __a, __n);
N    }
N
N    static _RWSTD_C::size_t length (const char_type *__s) {
X    static std::size_t length (const char_type *__s) {
N        return strlen (__s);
N    }
N
N    static char_type * move (char_type* __s1, const char_type* __s2,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N#ifndef _RWSTD_NO_MEMMOVE
N        memmove (__s1, __s2, __n);
N#else
S        if (__s1 < __s2)
S            copy (__s1, __s2, __n);
S        else if (__s1 > __s2) {
S            __s1 += __n;
S            __s2 += __n;
S            for (_RWSTD_C::size_t __i = 0; __i < __n; ++__i)
S                assign (*--__s1, *--__s2);
S        }
N#endif
N        return __s1;
N    }
N
N    static char_type *copy (char_type *__dst, const char_type *__src,
N                             _RWSTD_C::size_t __n){
X                             std::size_t __n){
N        memcpy (__dst, __src, __n); 
N        return __dst;
N    }
N
N    static char_type* assign (char_type* __s, _RWSTD_C::size_t __n, char_type __a) {
X    static char_type* assign (char_type* __s, std::size_t __n, char_type __a) {
N        memset (__s, __a, __n);
N        return __s;
N    }
N
N    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static int_type not_eof (const int_type& __c) {
N        return eq_int_type (eof (), __c) ? 0 : __c;
N    }
N                        
N    static char_type to_char_type (const int_type& __c) {
N        return _RWSTD_STATIC_CAST (char_type, __c);
X        return static_cast< char_type >(__c);
N    }
N      
N    static int_type to_int_type (const char_type& __c) {
N        // make sure (signed char)'\xff' converts to 255 and not -1
N        return _RWSTD_STATIC_CAST (unsigned char, __c);
X        return static_cast< unsigned char >(__c);
N    }
N};
N
N
N#ifndef _RWSTD_NO_WCHAR_T
N
N// 21.1.3.2
N_RWSTD_SPECIALIZED_CLASS  
Xtemplate< >  
Nstruct char_traits<wchar_t> 
N{
N    typedef wchar_t                   char_type;
N    typedef _RWSTD_WINT_T             int_type;
X    typedef int             int_type;
N    typedef streamoff                 off_type;
N    typedef mbstate_t                 state_type;
N    typedef fpos<state_type>          pos_type;
N
N#ifndef WEOF
S#  define WEOF (-1)
N#endif
N
N    static int_type eof () {
N        return int_type (WEOF);
X        return int_type (((std:: wint_t)-1));
N    }
N
N    static void assign (char_type& __c1, const char_type& __c2) {
N        __c1 = __c2;
N    }
N
N    static bool eq (const char_type& __c1, const char_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static bool lt (const char_type& __c1, const char_type& __c2) {
N        return __c1 < __c2;
N    }
N
N    static int compare (const char_type* __s1, const char_type* __s2,
N                        _RWSTD_C::size_t __n) {
X                        std::size_t __n) {
N#ifndef _RWSTD_NO_WMEMCMP
N        return wmemcmp (__s1, __s2, __n);
N#else
S        _RWSTD_C::size_t __i=0;
S        while (__i < __n) { 
S            if (!eq (__s1[__i], __s2[__i])) {
S                return lt (__s1[__i], __s2[__i]) ? -1 : 1;
S            }
S            ++__i;
S        }
S      return 0;
N#endif
N    }
N
N    static _RWSTD_C::size_t length (const char_type *__s) {
X    static std::size_t length (const char_type *__s) {
N#ifndef _RWSTD_NO_WCSLEN
N        // [harmless] cast necessary on CygWin
N        return wcslen (_RWSTD_CONST_CAST (char_type*, __s));
X        return wcslen (const_cast< char_type* >(__s));
N#else
S        _RWSTD_C::size_t __len = 0;
S        while (!eq (*__s++, char_type ()))
S            ++__len;
S        return __len;
N#endif
N    }
N      
N    static const char_type* find (const char_type* __s, _RWSTD_C::size_t __n, 
X    static const char_type* find (const char_type* __s, std::size_t __n, 
N                                  const char_type& __a)           {
N#ifndef _RWSTD_NO_WMEMCHR
N        return _RWSTD_STATIC_CAST (const char_type*, wmemchr (__s, __a, __n));
X        return static_cast< const char_type* >(wmemchr (__s, __a, __n));
N#else
S        while (__n-- > 0 && !eq (*__s, __a))
S            ++__s;
S        return  eq (*__s, __a) ? __s : 0;
N#endif   // _RWSTD_NO_WMEMCHR
N    }
N
N    static char_type * copy (char_type *__dst, const char_type *__src,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N        memcpy (__dst, __src, __n * sizeof (char_type));
N        return __dst;
N    }
N      
N    static char_type * move (char_type* __s1, const char_type* __s2,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N#ifndef _RWSTD_NO_WMEMMOVE
N        wmemmove (__s1, __s2, __n);
N#else
S        if (__s1 < __s2)
S            copy (__s1, __s2, __n);
S        else if (__s1 > __s2) {
S            __s1 += __n;
S            __s2 += __n;
S            for (_RWSTD_C::size_t __i = 0; __i < __n; ++__i)
S                assign (*--__s1, *--__s2);
S        }
N#endif   // _RWSTD_NO_WMEMMOVE
N        return __s1;
N    }
N
N    static char_type* assign (char_type* __s, _RWSTD_C::size_t __n, char_type __a){
X    static char_type* assign (char_type* __s, std::size_t __n, char_type __a){
N#ifndef _RWSTD_NO_WMEMSET
N        wmemset (__s, __a, __n);
N#else
S        char_type* __tmp = __s;
S        while (__n-- > 0) 
S            assign (*__tmp++, __a);
N#endif   // _RWSTD_NO_WMEMSET
N        return __s;
N    }
N
N    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static int_type not_eof (const int_type& __c) {
N        return eq_int_type (eof (), __c) ? 0 : __c;
N    }
N
N    static char_type to_char_type (const int_type& __c) {
N        return __c;
N    }
N      
N    static int_type to_int_type (const char_type& __c) {
N        return __c;
N    }
N};
N
N#endif
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// Implementation _Traits class, rw_traits, provides specialized
N// algorithms to speed up find operations on char and wchar_t strings
N
Ntemplate <class _CharT, class _Traits> 
Nstruct rw_traits
N{
N    static const _CharT* find (const _CharT* __s, const _CharT* __v) { 
N        _RWSTD_C::size_t __slen = _Traits::length (__s);
X        std::size_t __slen = _Traits::length (__s);
N        _RWSTD_C::size_t __vlen = _Traits::length (__v);
X        std::size_t __vlen = _Traits::length (__v);
N        for (_RWSTD_C::size_t __j = 0; (__j + __vlen) <= __slen ; ++__j) {
X        for (std::size_t __j = 0; (__j + __vlen) <= __slen ; ++__j) {
N            bool __found = true;
N            for (_RWSTD_C::size_t __i = 0; __i < __vlen ; ++__i) {
X            for (std::size_t __i = 0; __i < __vlen ; ++__i) {
N                if (!_Traits::eq (__s[__j + __i], __v[__i])) {
N                    __found = false;
N                    break;
N                }
N            }
N            if (__found)
N                return &__s[__j];
N        }
N        return 0;
N    }
N
N    static const _CharT* rfind (const _CharT* __s, _CharT __v, _RWSTD_C::size_t __pos) {
X    static const _CharT* rfind (const _CharT* __s, _CharT __v, std::size_t __pos) {
N        for  (const _CharT* __p = __s + __pos; __p >= __s; --__p) {
N            if (_Traits::eq (*__p, __v))
N                return __p;
N        }
N        return 0;       
N    }
N
N    static _RWSTD_C::size_t find_first_of (const _CharT* __s, const _CharT* __v) {
X    static std::size_t find_first_of (const _CharT* __s, const _CharT* __v) {
N        const _CharT* __p = __s;
N        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
N            for (const _CharT* __q = __v; !_Traits::eq (*__q, _CharT ()); ++__q)
N                if (_Traits::eq (*__p, *__q))
N                    return __p - __s;
N        }
N        return  __p - __s;
N    }
N
N    static _RWSTD_C::size_t find_first_not_of (const _CharT* __s, const _CharT* __v) {
X    static std::size_t find_first_not_of (const _CharT* __s, const _CharT* __v) {
N        bool __found;
N        const _CharT* __p = __s;
N        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
N            __found = false;
N            for (const _CharT* __q = __v;
N                 !_Traits::eq (*__q, _CharT ()); ++__q){
N                if (_Traits::eq (*__p, *__q)){
N                    __found = true; 
N                    break;
N                }  
N            }
N            if (!__found)      
N                return __p - __s;
N        }
N        return  __p-__s;
N    }
N};
N
N
N_RWSTD_SPECIALIZED_CLASS 
Xtemplate< > 
Nstruct rw_traits<char, _STD::char_traits<char> >
Xstruct rw_traits<char, std::char_traits<char> >
N{
N    static const char* find (const char* __s, const char* __v) {
N        return _RWSTD_C::strstr (__s, __v);
X        return std::strstr (__s, __v);
N    }
N
N    static const char* rfind (const char* __s, char __v, _RWSTD_C::size_t __pos) { 
X    static const char* rfind (const char* __s, char __v, std::size_t __pos) { 
N        const char* __p = __s + __pos;
N        while (__p >= __s)
N        {
N            if (_STD::char_traits<char>::eq (*__p, __v))
X            if (std::char_traits<char>::eq (*__p, __v))
N                return __p;
N            __p--; 
N        }
N        return 0;       
N    }
N
N    static _RWSTD_C::size_t find_first_of (const char* __s, const char* __v) {
X    static std::size_t find_first_of (const char* __s, const char* __v) {
N        return _RWSTD_C::strcspn (__s, __v);
X        return std::strcspn (__s, __v);
N    }
N
N    static _RWSTD_C::size_t find_first_not_of (const char* __s, const char* __v) {
X    static std::size_t find_first_not_of (const char* __s, const char* __v) {
N        return _RWSTD_C::strspn (__s, __v);
X        return std::strspn (__s, __v);
N    }
N
N};
N
N#if !defined(_RWSTD_NO_WCSCHR)  && !defined(_RWSTD_NO_WCSSPN) && !defined(_RWSTD_NO_WCSSPN) && !defined(_RWSTD_NO_WCHAR_T)
X#if !0L  && !0L && !0L && !0L
N_RWSTD_SPECIALIZED_CLASS 
Xtemplate< > 
Nstruct rw_traits<wchar_t, _STD::char_traits<wchar_t> >
Xstruct rw_traits<wchar_t, std::char_traits<wchar_t> >
N{
N    static const wchar_t* find (const wchar_t* __s, const wchar_t* __v) {
N#ifndef _RWSTD_NO_WCSSTR
N        return _RWSTD_C::wcsstr (__s, __v);
X        return std::wcsstr (__s, __v);
N#elif defined (__hpux)
X#elif 0L
S        return wcswcs (__s, __v);
S#else
S        _RWSTD_C::size_t __len1 = _STD::char_traits<wchar_t>::length (__s);
S        _RWSTD_C::size_t __len2 = _STD::char_traits<wchar_t>::length (__v);
S
S        for (const wchar_t *__p = __s; (__p = _RWSTD_C::wcschr (__p, *__v));) {
S            _RWSTD_C::size_t __off = __p - __s;
S            if (__len1 - __off < __len2)
S                break;
S            if (0 == _RWSTD_C::memcmp (__p, __v, sizeof *__v * __len2))
S                return __p;
S            ++__p;
S        }
S        return 0;
S
N#endif   // _RWSTD_NO_WCSSTR
N    }
N
N    static const wchar_t* rfind (const wchar_t* __s, wchar_t __v, 
N                                _RWSTD_C::size_t __pos) { 
X                                std::size_t __pos) { 
N        const wchar_t* __p = __s + __pos;
N        while (__p >= __s) {
N            if (_STD::char_traits<wchar_t>::eq (*__p, __v))
X            if (std::char_traits<wchar_t>::eq (*__p, __v))
N                return __p;
N            __p--;
N        }
N        return 0;       
N    }
N
N    static _RWSTD_C::size_t find_first_of (const wchar_t* __s, const wchar_t* __v) {
X    static std::size_t find_first_of (const wchar_t* __s, const wchar_t* __v) {
N        return _RWSTD_C::wcscspn (__s, __v);
X        return std::wcscspn (__s, __v);
N    }
N
N    static _RWSTD_C::size_t find_first_not_of (const wchar_t* __s, const wchar_t* __v) {
X    static std::size_t find_first_not_of (const wchar_t* __s, const wchar_t* __v) {
N        return _RWSTD_C::wcsspn (__s, __v);
X        return std::wcsspn (__s, __v);
N    }
N
N};
N#endif /* !defined(_RWSTD_NO_WCSCHR)  && !defined(_RWSTD_NO_WCSSPN) && !defined(_RWSTD_NO_WCSSPN) */
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_TRAITS_H_INCLUDED
N
L 40 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_strref.h" 2
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// chooses either a single global mutex or a mutex per string object
N// or no mutex at all when atomic test-and-set instruction is available
N#if !defined (_RWSTD_MULTI_THREAD) || !defined (_RWSTD_NO_TEST_AND_SET)
X#if !0L || !1L
N#  define _RWSTD_STRING_MUTEX(ignore)   false
N#elif defined (_RWSTD_ONE_STRING_MUTEX)
X#elif 0L
S#  define _RWSTD_STRING_MUTEX(ignore)   __rw_string_mutex
S#else
S#  define _RWSTD_STRING_MUTEX(pstr)     pstr->_C_mutex
N#endif
N
N
Ntemplate< class _CharT,
N          class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>), 
X          class _Traits = char_traits<_CharT>, 
N          class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>) >
X          class _Allocator = allocator<_CharT> >
Nclass basic_string;
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N
N#ifdef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
S
Sextern unsigned long _RWSTD_EXPORT __nullref [];
S#define _NULLREF _RW::__nullref
S
N#else
N
N#define _NULLREF string_type::__nullref
N
N#endif   // _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N
N#if    defined (_RWSTD_MULTI_THREAD)    \
N    && defined (_RWSTD_ONE_STRING_MUTEX) \
N    && defined (_RWSTD_NO_TEST_AND_SET)
X#if    0L        && 0L     && 1L
S
Sextern  __rw_mutex _RWSTD_EXPORT __rw_string_mutex;
S
N#endif   // _MULTI_THREAD && _ONE_STRING_MUTEX && _NO_TEST_AND_SET
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Nstruct __string_ref
N{
N    typedef _CharT                                            char_type;
N    typedef _Allocator                                        allocator_type;
N    typedef _TYPENAME allocator_type::size_type               size_type;
X    typedef typename allocator_type::size_type               size_type;
N    typedef _STD::basic_string<_CharT, _Traits, _Allocator>   string_type;
X    typedef std::basic_string<_CharT, _Traits, _Allocator>   string_type;
N
N#if     defined (_RWSTD_MULTI_THREAD)          \
N    && !defined (_RWSTD_ONE_STRING_MUTEX)      \
N    &&  defined (_RWSTD_NO_TEST_AND_SET)       \
N    && !defined (_RWSTD_NO_STATIC_MUTEX_INIT)
X#if     0L              && !0L          &&  1L           && !0L
S
S    void _C_init (size_type __ref, size_type __cap, size_type __size) {
S
S        _C_cap  = __cap;
S        _C_size = __size;
S
S#  ifndef _RWSTD_NO_STRING_REF_COUNT
S
S        _C_refs = __ref - 1;
S
S        if (0 != _RWSTD_MUTEX_INIT (this->_C_mutex._C_mutex))
S            _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR,
S                             "synchronization error");
S#  else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S        _RWSTD_UNUSED (__ref);
S#  endif   // _RWSTD_NO_STRING_REF_COUNT
S
S    }
S
S    void _C_destroy () {
S#  ifndef _RWSTD_NO_STRING_REF_COUNT
S
S        _RWSTD_MUTEX_DESTROY (this->_C_mutex._C_mutex);
S
S#  endif   // _RWSTD_NO_STRING_REF_COUNT
S    }
S
N#else
N
N    void _C_init (size_type __ref, size_type __cap, size_type __size) {
N
N#  ifndef _RWSTD_NO_STRING_REF_COUNT
N        _C_refs = __ref - 1;
N#  else
S        _RWSTD_UNUSED (__ref);
N#  endif   // _RWSTD_NO_STRING_REF_COUNT
N
N        _C_cap  = __cap;
N        _C_size = __size;
N    }
N
N    void _C_destroy () { }
N
N#endif   // _MULTI_THREAD && !_ONE_STRING_MUTEX && _NO_TEST_AND_SET && ...
N
N    size_type _C_ref_count () const {
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N        return this->_C_refs + 1;
N#else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S        return 0;
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N    }
N
N    void _C_set_ref_count (size_type __ref) { 
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N        if (this != (void*)&_NULLREF)
X        if (this != (void*)&string_type::__nullref)
N            _RWSTD_ATOMIC_SWAP (this->_C_refs, __ref - 1,
N                                _RWSTD_STRING_MUTEX (this));
X            __rw::__rw_atomic_exchange ((this->_C_refs), (__ref - 1), false);
N#else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S        _RWSTD_UNUSED (__ref);
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    }
N
N    void _C_inc_ref () { 
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N        if (this != (void*)&_NULLREF)
X        if (this != (void*)&string_type::__nullref)
N            _RWSTD_ATOMIC_PREINCREMENT (this->_C_refs,
N                                        _RWSTD_STRING_MUTEX (this));
X            ++(this->_C_refs);
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    }
N
N    size_type _C_dec_ref () {
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N        if (this != (void*)&_NULLREF)
X        if (this != (void*)&string_type::__nullref)
N            return 1 + _RWSTD_ATOMIC_PREDECREMENT (this->_C_refs,
N                                                   _RWSTD_STRING_MUTEX (this));
X            return 1 + --(this->_C_refs);
N        return 1;
N#else
S        return 0;
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    }
N
N    size_type size () const {
N        return this->_C_size;
N    }
N
N    size_type capacity () const {
N        return this->_C_cap;
N    }
N
N    char_type* data () {
N        return _RWSTD_REINTERPRET_CAST (char_type*, this + 1);
X        return reinterpret_cast< char_type* >(this + 1);
N    }
N
N    const char_type* data () const {
N        return _RWSTD_REINTERPRET_CAST (const char_type*, this + 1);
X        return reinterpret_cast< const char_type* >(this + 1);
N    }
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N#  if     defined (_RWSTD_MULTI_THREAD)     \
N      && !defined (_RWSTD_ONE_STRING_MUTEX) \
N      &&  defined (_RWSTD_NO_TEST_AND_SET)
X#  if     0L           && !0L       &&  1L
S
S    __rw_mutex_base _C_mutex;
S
N#  endif   // _MULTI_THREAD && !_ONE_STRING_MUTEX && _NO_TEST_AND_SET
N
N    long      _C_refs;      // (1 less than) number of references
N                            // (-1 if reference counting is disabled)
N
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    size_type _C_cap;       // Size of allocated memory
N
N    union {
N        size_type _C_size;  // number of actual data values stored
N        _CharT    _C_dummy; // force the alignment of the first char
N    };
N};
N
N
N// representation of the null string; will be a POD wherever possible
N// (will not be POD if the reference contains a mutex with a UD-ctor)
Ntemplate <class _CharT, class _Traits , class _Allocator>
Nstruct __null_ref
N    : __string_ref<_CharT, _Traits , _Allocator>
N{
N    // string reference immediately followed by a single terminating null
N    _CharT _C_eos;
N};
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_STRREF_H_INCLUDED
N
L 41 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N#include <rw/_defs.h>
N#include <rw/_error.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_error.h" 1
N/**************************************************************************
N *
N * Definition of class except_msg_string
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_ERROR_H_INCLUDED
N#define _RWSTD_ERROR_H_INCLUDED
N
N#ifndef _RWSTD_NO_INCLUDES
N   // prevent inclusion if compiling a .rc file with MSVC
N#  include <rw/_defs.h>
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// throws an exception identified by first argument, optional arguments
N// (if any) used to format the exception object's what() string
Nvoid _RWSTD_EXPORT __rw_throw (int, ...);
Xvoid  __rw_throw (int, ...);
N
Nextern "C" {
N
N// throws an exception identified by first argument with the second
N// argument containing the exception object's what() string, which
N// if non-zero and the first argument <= _RWSTD_ERROR_BAD_CAST, is
N// dynamically allocated and must be delete[]'d unless the function
N// returns or calls the original throw_proc
N// may be assigned to a user-defined handler (e.g., to prevent
N// the library from throwing exceptions or to implement logging)
Nextern void _RWSTD_EXPORT (*__rw_throw_proc)(int, char*);
Xextern void  (*__rw_throw_proc)(int, char*);
N
N}   // extern "C"
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N#endif   // _RWSTD_NO_INCLUDES
N
N
N#ifndef _RWSTD_ERROR_CATALOG
N   // name of catalog optionally followed by a colon and a set number
N   // catalog looked up according to rules of catopen(3)
N   // may be customized at lib build time (pathname okay)
N#  define _RWSTD_ERROR_CATALOG "rwstderr:1"
N#endif   // _RWSTD_ERROR_CATALOG
N
N#ifndef _RWSTD_ERROR_ENVVAR
N   // environment variable name - overrides _RWSTD_ERROR_CATALOG
N   // may be customized at lib build time
N#  define _RWSTD_ERROR_ENVVAR "RWSTDERR"
N#endif   // _RWSTD_ERROR_ENVVAR
N
N#ifndef _RWSTD_ERROR_FIRST
N   // id of first message - 1, may be customized at lib build time
N#  define _RWSTD_ERROR_FIRST 0
N#endif   // _RWSTD_ERROR_FIRST
N
N
N// these must be macros to accomodate MSVC's resource compiler, with values
N// expected to be consecutive starting with _RWSTD_ERROR_FIRST + 1
N
N// #  define _RWSTD_ERROR_EXCEPTION                   (_RWSTD_ERROR_FIRST +  1)
N// #  define _RWSTD_ERROR_BAD_EXCEPTION               (_RWSTD_ERROR_FIRST +  2)
N// #  define _RWSTD_ERROR_BAD_ALLOC                   (_RWSTD_ERROR_FIRST +  3)
N#  define _RWSTD_ERROR_BAD_CAST                    (_RWSTD_ERROR_FIRST +  4)
N#  define _RWSTD_ERROR_LOGIC_ERROR                 (_RWSTD_ERROR_FIRST +  5)
N#  define _RWSTD_ERROR_DOMAIN_ERROR                (_RWSTD_ERROR_FIRST +  6)
N#  define _RWSTD_ERROR_INVALID_ARGUMENT            (_RWSTD_ERROR_FIRST +  7)
N#  define _RWSTD_ERROR_LENGTH_ERROR                (_RWSTD_ERROR_FIRST +  8)
N#  define _RWSTD_ERROR_OUT_OF_RANGE                (_RWSTD_ERROR_FIRST +  9)
N#  define _RWSTD_ERROR_RUNTIME_ERROR               (_RWSTD_ERROR_FIRST + 10)
N#  define _RWSTD_ERROR_RANGE_ERROR                 (_RWSTD_ERROR_FIRST + 11)
N#  define _RWSTD_ERROR_OVERFLOW_ERROR              (_RWSTD_ERROR_FIRST + 12)
N#  define _RWSTD_ERROR_UNDERFLOW_ERROR             (_RWSTD_ERROR_FIRST + 13)
N
N#  define _RWSTD_ERROR_FAILBIT_SET                 (_RWSTD_ERROR_FIRST + 14)
N#  define _RWSTD_ERROR_BADBIT_SET                  (_RWSTD_ERROR_FIRST + 15)
N#  define _RWSTD_ERROR_EOFBIT_SET                  (_RWSTD_ERROR_FIRST + 16)
N#  define _RWSTD_ERROR_IOSTATE_BIT_SET             (_RWSTD_ERROR_FIRST + 17)
N
N#  define _RWSTD_ERROR_FACET_NOT_FOUND             (_RWSTD_ERROR_FIRST + 18)
N#  define _RWSTD_ERROR_LOCALE_BAD_NAME             (_RWSTD_ERROR_FIRST + 20)
N#  define _RWSTD_ERROR_LOCALE_ERROR_NAME           (_RWSTD_ERROR_FIRST + 21)
N#  define _RWSTD_ERROR_CODECVT                     (_RWSTD_ERROR_FIRST + 22)
N
N#  define _RWSTD_ERROR_BAD_POINTER                 (_RWSTD_ERROR_FIRST + 23)
N
N#  define _RWSTD_ERROR_STRINGS                          \
N          "%s: unspecified error",                      \
N          "%s: exception",                              \
N          "%s: unexpected exception",                   \
N          "%s: bad_alloc: out of memory",               \
N          "%s: bad cast",                               \
N          "%s: logic error",                            \
N          "%s: out of memory",                          \
N          "%s: bad cast",                               \
N          "%s: length error: %u > %u",                  \
N          "%s: argument value %u out of range [0, %u)", \
N          "%s: runtime error",                          \
N          "%s: range error: invalid range [%d, %d)",    \
N          "%s: overflow error",                         \
N          "%s: underflow error",                        \
N          "%s: stream object has set ios::failbit",     \
N          "%s: stream object has set ios::badbit",      \
N          "%s: stream object has set ios::eofbit",      \
N          "%s: stream object has set %s",               \
N          "%s: facet %u not found in \"%s\" locale",    \
N          "%s: bad locale name: \"%s\"",                \
N          "%s: failed to construct locale name",        \
N          "%s: conversion failed",                      \
N          "%s: invalid pointer %p"
X#  define _RWSTD_ERROR_STRINGS                                    "%s: unspecified error",                                "%s: exception",                                        "%s: unexpected exception",                             "%s: bad_alloc: out of memory",                         "%s: bad cast",                                         "%s: logic error",                                      "%s: out of memory",                                    "%s: bad cast",                                         "%s: length error: %u > %u",                            "%s: argument value %u out of range [0, %u)",           "%s: runtime error",                                    "%s: range error: invalid range [%d, %d)",              "%s: overflow error",                                   "%s: underflow error",                                  "%s: stream object has set ios::failbit",               "%s: stream object has set ios::badbit",                "%s: stream object has set ios::eofbit",                "%s: stream object has set %s",                         "%s: facet %u not found in \"%s\" locale",              "%s: bad locale name: \"%s\"",                          "%s: failed to construct locale name",                  "%s: conversion failed",                                "%s: invalid pointer %p"
N
N#define _RWSTD_ERROR_EXCEPTION     "exception"
N#define _RWSTD_ERROR_BAD_EXCEPTION "unexpected exception"
N#define _RWSTD_ERROR_BAD_ALLOC     "bad_alloc: out of memory"
N
N
N#endif   // _RWSTD_ERROR_H_INCLUDED
N
L 43 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nclass basic_string: private _Allocator
N{
Npublic:
N
N    typedef _Traits                               traits_type;
N    typedef _TYPENAME traits_type::char_type      value_type;
X    typedef typename traits_type::char_type      value_type;
N    typedef _Allocator                            allocator_type;
N
Nprivate:
N
N    typedef _RW::__string_ref<value_type, traits_type, allocator_type>
X    typedef __rw::__string_ref<value_type, traits_type, allocator_type>
N     _C_string_ref_type;
N
N    typedef  _RWSTD_ALLOC_TYPE(allocator_type, value_type)          
X    typedef  allocator_type          
N        _C_value_alloc_type;
N    typedef  _RWSTD_REBIND(allocator_type, _C_string_ref_type)  
X    typedef  typename allocator_type::template rebind < _C_string_ref_type > ::other  
N        _C_ref_alloc_type;
N      
Npublic:
N
N    typedef _TYPENAME allocator_type::size_type       size_type;
X    typedef typename allocator_type::size_type       size_type;
N    typedef _TYPENAME allocator_type::difference_type difference_type;
X    typedef typename allocator_type::difference_type difference_type;
N    typedef _TYPENAME allocator_type::reference       reference;
X    typedef typename allocator_type::reference       reference;
N    typedef _TYPENAME allocator_type::const_reference const_reference;
X    typedef typename allocator_type::const_reference const_reference;
N    typedef _TYPENAME allocator_type::pointer         pointer;
X    typedef typename allocator_type::pointer         pointer;
N    typedef _TYPENAME allocator_type::const_pointer   const_pointer;
X    typedef typename allocator_type::const_pointer   const_pointer;
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S
S    typedef _RW::__rw_debug_iter <basic_string, pointer, pointer>
S        iterator;
S    
S    typedef _RW::__rw_debug_iter <basic_string, const_pointer, pointer>
S        const_iterator;
S
S    iterator _C_make_iter (const pointer& __ptr) {
S        return iterator (*this, __ptr);
S    }
S
S    const_iterator _C_make_iter (const const_pointer& __ptr) const {
S        return const_iterator (*this, __ptr);
S    }
S
N#else   // if defined (_RWSTD_NO_DEBUG_ITER)
N
N    typedef pointer                        iterator;
N    typedef const_pointer                  const_iterator;
N
N    iterator _C_make_iter (pointer __ptr) {
N        return __ptr;
N    }
N
N    const_iterator _C_make_iter (const_pointer __ptr) const {
N        return __ptr;
N    }
N
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N    typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;
X    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
N    typedef _STD::reverse_iterator<iterator>       reverse_iterator;
X    typedef std::reverse_iterator<iterator>       reverse_iterator;
N#else
S    typedef _STD::reverse_iterator<const_iterator, 
S      random_access_iterator_tag, value_type, 
S      const_reference, const_pointer, difference_type>
S      const_reverse_iterator;
S    typedef _STD::reverse_iterator<iterator, 
S      random_access_iterator_tag, value_type, 
S      reference, pointer, difference_type>
S      reverse_iterator;
N#endif
N
N#if defined(_RWSTD_LLP64_ARCHITECTURE) && defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if 0L && 0L
S    static const size_type npos;
N#else
N    _RWSTD_STATIC_CONST (size_type, npos = size_type(-1));
X    static const size_type npos = size_type(-1);
N#endif    
N
N    _EXPLICIT
X    explicit
N    basic_string (const allocator_type &__alloc = allocator_type ())
N        : allocator_type (__alloc), _C_data (_C_null ()) { }
N
N    // LWG Issue #42.
N    basic_string (const basic_string&);
N
N    basic_string (const basic_string&, size_type, size_type = npos, 
N                  const allocator_type& = allocator_type ());
N
N    basic_string (const_pointer, size_type, 
N                  const allocator_type& = allocator_type ());
N
N    basic_string (const_pointer, const allocator_type& = allocator_type ());
N
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    // pointers to the incomplete types declared below are used
N    // to disambiguate calls to template member functions
N    // requires: member function and class templates
N    //           and partial specialization
N
N    template <class _InputIterator>
N    basic_string (_InputIterator, _InputIterator, 
N                  const allocator_type& = allocator_type ());
N
N    basic_string (int __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned int __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N      : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (long __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned long __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (short __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned short __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (char __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned char __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {  
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);  
X        _C_initn (static_cast< size_type >(__n), __c);  
N    }
N
N
N#ifndef _RWSTD_NO_NATIVE_WCHAR_T
N
N    basic_string (wchar_t __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N#endif   // _RWSTD_NO_NATIVE_WCHAR_T
N
N
N#ifndef _RWSTD_NO_BOOL
N
N    basic_string (bool __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N#endif   // _RWSTD_NO_BOOL
N
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string (size_type __n, value_type __c, 
S                  const allocator_type& __alloc = allocator_type ())
S      : allocator_type (__alloc) {
S        _C_initn (__n, __c);
S    }
S
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    basic_string (const_pointer, const_pointer, 
N                  const allocator_type& = allocator_type ());
N
N    ~basic_string () {
N        _C_unlink();
N    }
N
N    basic_string& operator= (const basic_string&);
N    basic_string& operator= (const_pointer __s);
N
N    basic_string& operator= (value_type __c) {
N        return replace (0, size(), 1, __c);
N    }
N
N    iterator begin () {
N        _C_cow ();
N        _C_pref ()->_C_set_ref_count (0);   // disable ref counting
N        return _C_make_iter (_C_data);
N    }
N
N    const_iterator begin () const {
N        return _C_make_iter (_C_data);
N    }
N
N    iterator end () {
N        // disable reference counting
N        return begin () + size ();
N    }
N
N    const_iterator end () const {
N        return _C_make_iter (_C_data + size ());
N    }
N
N    reverse_iterator rbegin () {
N        return reverse_iterator (end ());
N    }
N
N    const_reverse_iterator rbegin () const {
N        return const_reverse_iterator (end ());
N    }
N
N    reverse_iterator rend () {
N        return reverse_iterator (begin ());
N    }
N
N    const_reverse_iterator rend () const {
N        return const_reverse_iterator (begin ());
N    }
N
N    size_type size () const {
N        return _C_pref()->_C_size;
N    }
N
N    size_type length () const {
N        return size ();
N    }
N
N    size_type max_size () const {
N        return size_type (npos) - sizeof (_C_string_ref_type) - 2U;
N    }
N
N    void resize (size_type, value_type);
N
N    void resize (size_type __n) {
N        resize (__n, value_type ()); 
N    }
N
N    size_type capacity () const {
N        return _C_pref ()->capacity ();
N    }
N
N    void reserve (size_type = 0);
N
N    void clear () {
N        erase ();
N    }
N
N    bool empty () const  {
N        return size () == 0;
N    }
N
N    const_reference operator[] (size_type) const;
N    reference       operator[] (size_type);
N
N    const_reference at (size_type) const;
N    reference       at (size_type);
N
N    basic_string& operator+= (const basic_string &__s) {
N        return append (__s);
N    }
N
N    basic_string& operator+= (const_pointer __s) {
N        return append (__s);
N    }
N
N    basic_string& operator+= (value_type __c) {
N        return append (size_type (1), __c);
N    }
N
N    basic_string& append (const basic_string&, size_type, size_type);
N
N    basic_string& append (const basic_string &__str);
N
N    basic_string& append (const_pointer __s, size_type __n) {
N        return replace (size (), 0, __s, __n, 0, __n), *this;
N    }
N
N    basic_string& append (const_pointer __s) {
N        return replace (size (), 0, __s);
N    }
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    basic_string& append (_InputIterator __first, _InputIterator __last) {
N        // resolves to append (size_type, value_type) if _InputIterator
N        // is any integral type (even not an exact match, such as char)
N        // the cast to int is necessary to prevent an exact match
N        return append (__first, __last, _RWSTD_DISPATCH (_InputIterator));
X        return append (__first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N    template<class _InputIterator>
N    basic_string& append (_InputIterator __first, _InputIterator __last,
N                          _RWSTD_DISPATCH_INT (false)) {
X                          const __rw::__rw_select < false > *) {
N        return replace (_C_make_iter (_C_data + size ()),
N                        _C_make_iter (_C_data + size ()),
N                        __first, __last), *this;
N    }
N
N    basic_string& append (size_type __n, value_type __c,
N                          _RWSTD_DISPATCH_INT (true)) {
X                          const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        return replace (size (), 0, __n, __c);
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string& append (const_pointer __first, const_pointer __last) {
S        replace (size (), 0, __first, __last - __first, 0, __last - __first);
S        return *this;
S    }
S
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N    basic_string& append (size_type __n, value_type __c) {
N        return replace (size (), 0, __n, __c);
N    }
N
N    void push_back (value_type __c) {
N        append (size_type (1), __c);
N    }
N
N    basic_string& assign (const basic_string &__str) {
N        return *this = __str;
N    }
N
N    basic_string& assign (const basic_string&, size_type, size_type);
N
N    basic_string& assign (const_pointer __s, size_type __n) {
N        return replace (0, size (), __s, __n, 0, __n), *this;
N    }
N
N    basic_string& assign (const_pointer __s) {
N        return *this = __s;
N    }
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    basic_string& assign (_InputIterator __first, _InputIterator __last) {
N        // resolves to assign (size_type, value_type) if _InputIterator
N        // is any integral type (even not an exact match, such as char)
N        // the cast to int is necessary to prevent an exact match
N        return assign (__first, __last, _RWSTD_DISPATCH (_InputIterator));
X        return assign (__first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N    template<class _InputIterator>
N    basic_string& assign (_InputIterator __first, _InputIterator __last,
N                          _RWSTD_DISPATCH_INT (false)) {
X                          const __rw::__rw_select < false > *) {
N        // unnamed arg is used for overload resolution
N        // _RWSTD_COMPILE_ASSERT (sizeof (*__first));
N        return replace (_C_make_iter (_C_data),
N                        _C_make_iter (_C_data + size ()), __first, __last);
N    }
N
N    basic_string& assign (size_type __n, value_type __c,
N                          _RWSTD_DISPATCH_INT (true)) {
X                          const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        return replace (0, size (), __n, __c);
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string& assign (const_pointer __first, const_pointer __last) {
S        replace (size_type (), size (), __first,
S                 __last - __first, size_type (), __last - __first);
S        return *this;
S    }
S
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N
N    basic_string& assign (size_type __n, value_type __c) {
N        return replace (0, size (), __n, __c);
N    }
N
N    basic_string& insert (size_type, const basic_string&);
N    basic_string& insert (size_type, const basic_string&,
N                          size_type, size_type);
N
N    basic_string& insert (size_type __pos, const_pointer __s, size_type __n) {
N        return replace (__pos, 0, __s, __n, 0, __n), *this;
N    }
N
N    basic_string& insert (size_type __pos, const_pointer __s) {
N        return insert (__pos, __s, traits_type::length (__s));
N    }
N
N    // 21.3.5.4, p10
N    iterator insert (iterator __pos, value_type __c) {
N        _RWSTD_ASSERT_RANGE (_C_make_iter (_C_data), __pos);
X        ((void)0);
N        size_type __inx = __pos - _C_make_iter (_C_data);
N        return insert (__inx, &__c, 1), begin () + __inx;
N    }
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    void insert (iterator __p,
N                 _InputIterator __first, _InputIterator __last) {
N        // resolves to insert (iterator, size_type, value_type)
N        // if _InputIterator is any integral type (even not an exact match,
N        // such as char)
N        // the cast to int is necessary to avoid an exact match
N        insert (__p, __first, __last, _RWSTD_DISPATCH (_InputIterator));
X        insert (__p, __first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N    void insert (iterator __p, const_iterator __first, const_iterator __last) {
N        iterator __begin = _C_make_iter (_C_data);
N        iterator __end   = _C_make_iter (_C_data + size ());
N        _RWSTD_ASSERT_RANGE (__begin, __p);
X        ((void)0);
N        if (__first >= __begin && __first <= __end)
N            insert (__p - __begin, basic_string (__first, __last));
N        else
N            replace (__p, __p, __first, __last);
N    }
N
N    void insert (iterator __p, iterator __first, iterator __last) {
N        insert (__p, const_iterator (__first), const_iterator (__last));
N    }
N
N    template <class _InputIterator>
N    void insert (iterator __p, _InputIterator __first, _InputIterator __last,
N                 _RWSTD_DISPATCH_INT (false)) {
X                 const __rw::__rw_select < false > *) {
N        // unnamed arg is used for overload resolution
N        // _RWSTD_COMPILE_ASSERT (sizeof (*__first));
N        replace (__p, __p, __first, __last);
N    }
N
N    void insert (iterator __p, size_type __n, value_type __c,
N                 _RWSTD_DISPATCH_INT (true)) {
X                 const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        replace (__p - _C_make_iter (_C_data), 0, __n, __c);
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    void insert (iterator __p, const_pointer __first, const_pointer __last) {
S        replace (__p - _C_make_iter (_C_data), 0, __first,
S                 __last - __first, 0, __last - __first);
S    }
S
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N    
N
N    void insert (iterator __p, size_type __n, value_type __c) {
N        replace (__p - _C_make_iter (_C_data), 0, __n, __c);
N    }
N
N    basic_string& insert (size_type __pos, size_type __n, value_type __c) {
N        return replace (__pos, 0, __n, __c);
N    }
N
N    basic_string& erase (size_type = 0, size_type = npos);
N
N    iterator erase (iterator __it) { 
N        return replace (__it - _C_make_iter (_C_data), 1,
N                        const_pointer (0), 0, 0, 0);
N    }
N
N    iterator erase (iterator __first, iterator __last) {  
N        return replace (__first - _C_make_iter (_C_data), __last - __first,
N                        const_pointer (0), 0, 0, 0);
N    }
N
Nprivate:  
N
N    iterator replace (size_type, size_type, const_pointer,
N                      size_type, size_type, size_type);
N
N    iterator __replace_aux (size_type pos1, size_type __n1,
N                            const basic_string &__str,
N                            size_type pos2 = 0,
N                            size_type __n2   = npos) {
N        return replace (pos1, __n1, __str.c_str(), __str.size(), pos2, __n2);
N    }
N
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template<class _InputIterator>
N    basic_string& __replace_aux (iterator       first1,
N                                 iterator       last1, 
N                                 _InputIterator first2,
N                                 _InputIterator last2);
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N  public:
N
N    basic_string& replace (size_type pos1, size_type __n1,
N                           const basic_string &__s,
N                           size_type pos2, size_type __n2) {
N        replace (pos1, __n1, __s.c_str (), __s.size (), pos2, __n2);
N        return *this;
N    }
N
N    basic_string& replace (size_type __pos, size_type __n,
N                           const basic_string &__s) {
N        return replace (__pos, __n, __s, 0, __s.size ());
N    }
N
N
N    basic_string& replace (size_type __pos, size_type __n1, const_pointer __s,
N                           size_type __n2) {
N        return replace (__pos, __n1, __s, __n2, 0, __n2), *this;
N    }
N
N    basic_string& replace (size_type __pos, size_type __n, const_pointer __s) {
N        return replace (__pos, __n, __s, traits_type::length (__s));
N    }
N
N    basic_string& replace (size_type, size_type, size_type, value_type);
N
N    basic_string& replace (iterator __first, iterator __last,
N                           const basic_string &__str) {
N        return replace (__first - _C_make_iter (_C_data),
N                        __last - __first, __str);
N    }
N
N    basic_string& replace (iterator __first, iterator __last,
N                           const_pointer __s, size_type __n) {
N        replace (__first - _C_make_iter (_C_data), __last - __first,
N                 __s, __n, 0, __n);
N        return *this;;
N    }
N
N    basic_string&
N    replace (iterator __first, iterator __last, const_pointer __s) {
N        return replace (__first, __last, __s, traits_type::length(__s));
N    }
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    basic_string& replace (iterator, iterator,
N                           _InputIterator, _InputIterator,
N                           _RWSTD_DISPATCH_INT (false));
X                           const __rw::__rw_select < false > *);
N
N
N    basic_string& replace (iterator __first, iterator __last,
N                           size_type __n, value_type __c,
N                           _RWSTD_DISPATCH_INT (true)) {
X                           const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        return replace (__first - _C_make_iter (_C_data), __last - __first,
N                        __n, __c);
N    }
N
N    template<class _InputIterator>
N    basic_string& replace (iterator __first1, iterator __last1,
N                           _InputIterator __first2, _InputIterator __last2) {
N        // resolves to replace (iterator, iterator, size_type, value_type)
N        // if _InputIterator is any integral type (even not an exact match,
N        // Such as char)
N        // the cast to int is necessary to prevent an exact match
N        return replace (__first1, __last1, __first2, __last2,
N                        _RWSTD_DISPATCH (_InputIterator));
X                        ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string& replace (iterator first1, iterator last1,
S                           const_pointer first2, const_pointer last2) {
S        return replace (first1 - _C_make_iter (_C_data), last1 - first1,
S                        first2, last2 - first2, 0, last2 - first2), *this;
S    }
S
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N
N    basic_string& replace (iterator __first, iterator __last,
N        size_type __n, value_type __c) {
N
N        // unnamed arg is used for overload resolution
N        return replace (__first - _C_make_iter (_C_data), __last - __first,
N                        __n, __c);
N    }
N
N    size_type copy (pointer, size_type, size_type = 0) const;
N
N#ifndef _RWSTD_NO_EXT_DEEP_STRING_COPY
N
N    basic_string copy () const {
N        return basic_string (data (), data () + size ());
N    }
N
N#endif   //_RWSTD_NO_EXT_DEEP_STRING_COPY
N
N    void swap (basic_string &__s) {
N        if (get_allocator () == __s.get_allocator ()) {
N            pointer __temp = _C_data;
N            _C_data = __s._C_data;
N            __s._C_data = __temp;
N        }
N        else {
N            basic_string __tmp = *this;
N            *this = __s;
N            __s = __tmp;
N        }
N    }
N
N    //
N    // string operations
N    //
N    const_pointer c_str () const {
N        return _C_data;
N    }
N
N    const_pointer data () const {
N        return _C_data;
N    }
N
N    allocator_type get_allocator() const {
N        return *this;
N    }
N
N    // 21.3.6.1, p1
N    size_type find (const basic_string &__str, size_type __pos = 0) const {
N        return find (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.1, p4
N    size_type find (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.1, p5
N    size_type find (const_pointer, size_type = 0) const;
N
N    // 21.3.6.1, p7
N    size_type find (value_type, size_type = 0) const;
N
N    // 21.3.6.2, p1
N    size_type rfind (const basic_string &__str, size_type __pos = npos) const {
N        return rfind (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.2, p4
N    size_type rfind (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.2, p5
N    size_type rfind (const_pointer __s, size_type __pos = npos) const {
N        return rfind (__s, __pos, traits_type::length (__s));
N    }
N
N    // 21.3.6.2, p7
N    size_type rfind (value_type, size_type = npos) const;
N
N    // 21.3.6.3, p1
N    size_type find_first_of (const basic_string &__str,
N                             size_type __pos = 0) const {
N        return find_first_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.3, p4
N    size_type find_first_of (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.3, p5
N    size_type find_first_of (const_pointer, size_type = 0) const;
N
N    // 21.3.6.3, p6
N    size_type find_first_of (value_type __c, size_type __pos = 0) const {
N        return find (__c, __pos);
N    }
N
N    // 21.3.6.4, p1
N    size_type find_last_of (const basic_string &__str,
N                            size_type __pos = npos) const {
N        return find_last_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.4, p4
N    size_type find_last_of (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.4, p5
N    size_type find_last_of (const_pointer __s, size_type __pos = npos) const {
N        return find_last_of (__s, __pos, traits_type::length (__s));
N    }
N
N    // 21.3.6.4, p7
N    size_type find_last_of (value_type __c, size_type __pos = npos) const {
N        return rfind (__c, __pos);
N    }
N
N    // 21.3.6.5, p1
N    size_type find_first_not_of (const basic_string &__str, 
N                                 size_type __pos = 0) const {
N        return find_first_not_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.5, p4
N    size_type find_first_not_of (const_pointer, size_type,
N                                 size_type) const;
N
N    // 21.3.6.5, p5
N    size_type find_first_not_of (const_pointer, size_type = 0) const;
N
N    // 21.3.6.5, p7
N    size_type find_first_not_of (value_type, size_type = 0) const;
N
N    // 21.3.6.6, p1
N    size_type find_last_not_of (const basic_string &__str, 
N                                size_type __pos = npos) const {
N        return find_last_not_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.6, p4
N    size_type find_last_not_of (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.6, p6
N    size_type find_last_not_of (const_pointer __s,
N                                size_type __pos = npos) const {
N        return find_last_not_of (__s, __pos, traits_type::length (__s));
N    }
N
N    // 21.3.6.6, p7
N    size_type find_last_not_of (value_type, size_type = npos) const;
N  
N    // 21.3.6.7
N    basic_string substr (size_type = 0, size_type = npos) const;
N  
N    int compare (const basic_string &__str) const;
N
N    int compare (size_type __pos, size_type __n, const basic_string &__str) const {
N        return compare (__pos, __n, __str.c_str(), __str.size());
N    }
N
N    int compare (size_type, size_type, const basic_string&, 
N                size_type, size_type) const;
N
N    int compare (const_pointer __s) const {
N        return compare (0, size (), __s, traits_type::length(__s));
N    }
N
N    // LWG Issue #5.
N    int compare (size_type __pos, size_type __n, const_pointer __s) const {
N        return compare(__pos, __n, __s, traits_type::length (__s));
N    }
N
N    int compare (size_type, size_type, const_pointer, size_type) const;
N
Nprotected:
N
N    void _C_cow () {             // Do copy on write as necessary
N        if (_C_pref ()->_C_ref_count() > 1) 
N            _C_clone ();
N    }
N
N    void _C_cow (size_type __nc) {   // Do copy on write w/ new capacity
N        if (_C_pref ()->_C_ref_count () > 1 || capacity () < __nc)
N            _C_clone (__nc);
N    }
N
Nprivate:
N
N    void _C_initn (size_type, value_type);
N
N    void _C_clone (size_type __nc = npos);
N
N    _C_string_ref_type* _C_pref () const { 
N        return _RWSTD_REINTERPRET_CAST (_C_string_ref_type*, _C_data) - 1; 
X        return reinterpret_cast< _C_string_ref_type* >(_C_data) - 1; 
N    }
N
N    void _C_unlink ();   
N
N    friend struct _RW::__string_ref<value_type, traits_type, allocator_type>;
X    friend struct __rw::__string_ref<value_type, traits_type, allocator_type>;
N
N#ifndef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N    static _RW::__null_ref<_CharT, _Traits, _Allocator> __nullref;
X    static __rw::__null_ref<_CharT, _Traits, _Allocator> __nullref;
N
N    static pointer _C_null () {
N        return __nullref.data ();
N    }
N
N#else   // if defined (_RWSTD_NO_COLLAPSE_TEMPLATE_STATICS)
S
S    static pointer _C_null () {
S        typedef _RW::__null_ref<_CharT, _Traits, _Allocator> _NullRef;
S
S        return _RWSTD_REINTERPRET_CAST (_NullRef*, &_RW::__nullref)->data ();
S    }
S
N#endif   // _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N    _C_string_ref_type * _C_getRep (size_type, size_type);
N
N    // for convenience
N    pointer _C_allocate (size_type __cur, size_type __cap, size_type __size) {
N        return _C_getRep (max (size_type (_RW::__rw_new_capacity (__cur, this)),
X        return _C_getRep (max (size_type (__rw::__rw_new_capacity (__cur, this)),
N                               __cap), __size)->data ();
N    }
N
N    pointer _C_data;
N};
N
N
Ntypedef basic_string<char, char_traits<char>, allocator<char> > string;
N
N#ifndef _RWSTD_NO_WCHAR_T
N
Ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
Nwstring;
N
N#endif   // _RWSTD_NO_WCHAR_T
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline void basic_string<_CharT, _Traits, _Allocator>::_C_unlink()
N{
N    _RWSTD_ASSERT (0 != _C_data);
X    ((void)0);
N
N    if (data () == _C_null ())
N        return;
N
N    if (_C_pref ()->_C_ref_count () == 0 || _C_pref ()->_C_dec_ref () == 0) {
N        // Required to pass same size to deallocate as allocate (see string.cc).
N        // Also note that we cannot call capacity() after the destroy() call.
N        size_type __size =
N            capacity () + sizeof (_C_string_ref_type) / sizeof (value_type) + 2;
N
N        // explicitly destroy POD
N        _C_pref ()->_C_destroy ();
N        
N        _C_ref_alloc_type (*this).destroy (_C_pref ());
N        _RWSTD_VALUE_ALLOC (_C_value_alloc_type,
N                            deallocate (_RWSTD_REINTERPRET_CAST (pointer,
N                                                                 _C_pref()),
N                                        __size));
X        allocator_type::deallocate (reinterpret_cast< pointer >(_C_pref()), __size);
N    }
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const basic_string<_CharT, _Traits, _Allocator> &__s)
N    : allocator_type (__s.get_allocator ())
N{
N    if (__s._C_pref()->_C_ref_count () > 0) {
N        _C_data = __s._C_data;
N        _C_pref()->_C_inc_ref ();
N    }
N    else {
N        size_type __n = __s.size();
N        _C_data  = _C_getRep (__n, __n)->data ();
N        traits_type::copy (_C_data, __s.c_str (), __n);
N    }
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::erase (size_type __pos,
N                                                  size_type __n)
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::erase(size_type, size_type)"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    const value_type __tmp =  value_type () ;
N    size_type __len = size () - __pos;
N    return replace (__pos, __n < __len ? __n : __len, &__tmp, 0);
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::const_reference 
Xinline typename basic_string<_CharT, _Traits, _Allocator>::const_reference 
Nbasic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos) const
N{
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S    _RWSTD_REQUIRES (__pos <= size (),
S                     (_RWSTD_ERROR_OUT_OF_RANGE,
S                     _RWSTD_FUNC ("basic_string::operator[](size_type) const"),
S                     __pos, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N    // reference counting still enabled
N    return _C_data [__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::reference
Xinline typename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos)
N{
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S    // 21.3.4, p1 - behavior is undefined if __pos == size ()
S    _RWSTD_REQUIRES (__pos < size (),
S                     (_RWSTD_ERROR_OUT_OF_RANGE,
S                     _RWSTD_FUNC ("basic_string::operator[](size_type)"),
S                     __pos, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N    // prevent reference counting
N    return begin ()[__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::const_reference
Xinline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
Nbasic_string<_CharT, _Traits, _Allocator>::at (size_type __pos) const
N{
N    _RWSTD_REQUIRES (__pos < size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                     _RWSTD_FUNC ("basic_string::at (size_type) const"),
N                     __pos, size ()));
X    (__pos < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    // reference counting still enabled
N    return _C_data [__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::reference
Xinline typename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::at (size_type __pos)
N{
N    _RWSTD_REQUIRES (__pos < size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                     _RWSTD_FUNC ("basic_string::at (size_type)"),
N                     __pos, size ()));
X    (__pos < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    // prevent reference counting
N    return begin ()[__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline void
Nbasic_string<_CharT, _Traits, _Allocator>::
Nresize (size_type __n, value_type __c)
N{
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::resize(size_type, "
N                                   "value_type)"), __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (__n < size())
N        erase (__n, size () - __n);
N    else
N        replace (size (), 0, __n - size (), __c);
N}
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline void basic_string<_CharT, _Traits, _Allocator>::
Nreserve (size_type __n)
N{
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::reserve(size_type)"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (__n > capacity ())
N        _C_clone (__n);
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind (const_pointer __s, size_type __pos) const
N{
N    _RWSTD_ASSERT (__s != 0);
X    ((void)0);
N
N    // 21.3.6.1, p1, bullet 1
N    if (__pos > size ())
N        return npos;
N
N    const_pointer __where =
N        _RW::rw_traits<value_type, traits_type>::find (_C_data + __pos, __s);
X        __rw::rw_traits<value_type, traits_type>::find (_C_data + __pos, __s);
N 
N   return __where ? __where - _C_data : npos;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind (value_type __c, size_type __pos) const
N{
N    if (__pos > size())
N        return npos;
N
N    const_pointer __where =  traits_type::find (_C_data + __pos,
N                                                size() - __pos, __c);
N    return __where ? __where  - _C_data : npos;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nrfind (value_type __c, size_type __pos) const
N{
N    if (!size ())
N        return npos;
N
N    if (__pos >= size ())
N        __pos = size () - 1;   // start at the last valid position
N
N    const_pointer __where =
N        _RW::rw_traits<value_type, traits_type>::rfind (_C_data,
X        __rw::rw_traits<value_type, traits_type>::rfind (_C_data,
N                                                        __c, __pos);
N    return __where ? __where - _C_data : npos;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_of (const_pointer __s, size_type __pos) const
N{
N    _RWSTD_ASSERT (__s != 0);
X    ((void)0);
N
N    if (__pos > size())
N        return npos;
N
N    typedef _RW::rw_traits<_CharT, _Traits> __rw_traits;
X    typedef __rw::rw_traits<_CharT, _Traits> __rw_traits;
N
N    size_type __i = __rw_traits::find_first_of (_C_data + __pos, __s) + __pos;
N
N    return __i >= size () ? npos : __i;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_not_of (const_pointer __s, size_type __pos) const
N{
N    _RWSTD_ASSERT (__s != 0);
X    ((void)0);
N
N    if (__pos > size())
N        return npos;
N
N    typedef _RW::rw_traits<_CharT, _Traits> __rw_traits;
X    typedef __rw::rw_traits<_CharT, _Traits> __rw_traits;
N    
N    size_type __i = __rw_traits::find_first_not_of(_C_data + __pos, __s)+ __pos;
N
N    return __i >= size () ? npos : __i;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_not_of (value_type __c, size_type __pos) const
N{
N    return find_first_not_of (&__c, __pos, 1);
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_last_not_of (value_type __c, size_type __pos) const
N{
N#if 0
S    // disabled to work around a bug in several compilers
S    const value_type __tmp [] = { __c, value_type () };
N#else
N    value_type __tmp [2];
N    traits_type::assign (__tmp [0], __c);
N    traits_type::assign (__tmp [1], value_type ());
N#endif   // 0/1
N
N    return find_last_not_of (__tmp, __pos);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline void
Nbasic_string<_CharT, _Traits, _Allocator>::
N_C_clone (size_type __nc /* = npos */)
N{
N    size_type __len = size();
N    _C_string_ref_type * __temp = _C_getRep (npos == __nc ? size () : __nc,
N                                             __len > __nc ? __nc : __len);
N    traits_type::copy (__temp->data(), _C_data, size());
N    _C_unlink ();
N    _C_data = __temp->data ();
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline int
Nbasic_string<_CharT, _Traits, _Allocator>::
Ncompare (const basic_string &__str) const
N{
N    int __res = traits_type::compare (data (), __str.data (),
N                                      _STD::min (size (), __str.size ()));
X                                      std::min (size (), __str.size ()));
N
N    if (0 == __res)
N        __res = size () < __str.size () ? -1 : size () != __str.size ();
N
N    return __res;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::append (const basic_string &__str)
N{
N    size_type __len = size () + __str.size ();
N    if (__len > capacity () || _C_pref ()->_C_ref_count () > 1)
N        return append (__str, 0, __str.size ());
N
N    traits_type::copy (_C_data + size (), __str.data (), __str.size () + 1);
N    _C_pref ()->_C_size = __len;
N    return *this;
N}
N
N
N// 21.3.7.1, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const basic_string<_CharT, _Traits, _Allocator> &__lhs, 
N           const basic_string<_CharT, _Traits, _Allocator> &__rhs)
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> string_type;
N
N    // prevent reference counting while creating a copy of lhs
N    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
N}
N
N
N// 21.3.7.1, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const _CharT*                                    __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
N}
N
N
N// 21.3.7.1, p4
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (_CharT                                           __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return basic_string<_CharT, _Traits, _Allocator>(1, __lhs) += __rhs;
N}
N
N
N// 21.3.7.1, p5
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const _CharT*                                    __rhs)
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> string_type;
N
N    // prevent reference counting while creating a copy of lhs
N    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
N}
N
N
N// 21.3.7.1, p7
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           _CharT                                           __rhs)
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> string_type;
N
N    // prevent reference counting while creating a copy of lhs
N    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
N}
N
N
N// 21.3.7.2, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return __lhs.size () == __rhs.size () && 0 == __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.2, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator== (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return 0 == __rhs.compare (__lhs);
N}
N
N
N// 21.3.7.2, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return 0 == __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.4, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return 0 > __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.4, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator< (const _CharT*                                    __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return 0 < __rhs.compare (__lhs);
N}
N
N
N// 21.3.7.4, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const _CharT*                                    __rhs)
N{
N    return 0 > __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.3, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N
N// 21.3.7.5, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return __rhs < __lhs;
N}
N
N
N// 21.3.7.6, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N
N// 21.3.7.7, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N// 21.3.7.8, p1
N#ifndef _RWSTD_NO_PART_SPEC_OVERLOAD
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline void swap (basic_string<_CharT, _Traits, _Allocator>& __a, 
N                  basic_string<_CharT, _Traits, _Allocator>& __b)
N{
N    __a.swap (__b);
N}
N
N#endif   // _RWSTD_NO_PART_SPEC_OVERLOAD
N
N
N// 21.3.7.3, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator!= (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N
N// 21.3.7.3, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N
N// 21.3.7.5, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator> (const _CharT*                                    __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return __rhs < __lhs;
N}
N
N
N// 21.3.7.5, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const _CharT*                                    __rhs)
N{
N    return __rhs < __lhs;
N}
N
N
N// 21.3.7.6, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator<= (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N
N// 21.3.7.6, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N
N// 21.3.7.7, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator>= (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N
N// 21.3.7.7, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N
N// 21.3.7.9, p3 - declared here, defined inline in <ostream>
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline basic_ostream<_CharT, _Traits>&
Noperator<< (basic_ostream<_CharT, _Traits>&,
N            const basic_string<_CharT, _Traits, _Allocator>&);
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N_USING (namespace std);
Xusing namespace std;
N
N
N#ifndef _RWSTD_NO_FUNC_PARTIAL_SPEC
N
N// more specialized version for basic_string<>; may be further specialized
N// in user code for example on a user-defined allocator
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline size_t
N__rw_new_capacity (size_t __size,
N                   const basic_string<_CharT, _Traits, _Allocator>*)
N{
N    size_t __cap =
N        _RWSTD_STATIC_CAST (size_t, _RWSTD_INCREASE_STRING_CAPACITY(__size)
N                                    /*__size * _RWSTD_STRING_CAPACITY_RATIO*/);
X        static_cast< size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));
N    return (__size += _RWSTD_MINIMUM_STRING_CAPACITY) > __cap ? __size : __cap;
X    return (__size += std::size_t (128)) > __cap ? __size : __cap;
N}
N
N#else   // if defined (_RWSTD_NO_FUNC_PARTIAL_SPEC)
S
S// the following specializations of the __rw_new_capacity<> function template
S// are provided for char and wchar_t; the general case is given in the <memory>
S
S_RWSTD_SPECIALIZED_FUNCTION
Sinline size_t __rw_new_capacity (size_t __size, const string*)
S{
S    size_t __cap =
S        _RWSTD_STATIC_CAST (size_t, _RWSTD_INCREASE_STRING_CAPACITY(__size)
S                                    /*__size * _RWSTD_STRING_CAPACITY_RATIO*/);
S    return (__size += _RWSTD_MINIMUM_STRING_CAPACITY) > __cap ? __size : __cap;
S}
S
S_RWSTD_SPECIALIZED_FUNCTION
Sinline size_t __rw_new_capacity (size_t __size, const wstring*)
S{
S    size_t __cap =
S        _RWSTD_STATIC_CAST (size_t, _RWSTD_INCREASE_STRING_CAPACITY(__size)
S                                    /*__size * _RWSTD_STRING_CAPACITY_RATIO*/);
S    return (__size += _RWSTD_MINIMUM_STRING_CAPACITY) > __cap  ? __size : __cap;
S}
S
N#endif   // _RWSTD_NO_FUNC_PARTIAL_SPEC
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#if _RWSTD_DEFINE_TEMPLATE (BASIC_STRING)
X#if 0
S#  include <string.cc>
N#endif
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N_RWSTD_INSTANTIATE_3 (class _RWSTD_EXPORT
N                      basic_string<char, char_traits<char>, allocator<char> >);
Xtypedef void __rw_unused_typedef;
N
N#ifndef _RWSTD_NO_WCHAR_T
N_RWSTD_INSTANTIATE_3 (class _RWSTD_EXPORT
N                      basic_string<wchar_t, char_traits<wchar_t>,
N                                   allocator<wchar_t> >);
Xtypedef void __rw_unused_typedef;
N#endif   // _RWSTD_NO_WCHAR_T
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_STRING_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\bitset" 2
N
N#include <rw/_defs.h>
N#include <rw/_error.h>
N
N#include _RWSTD_CLIMITS
X#include <climits>
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// helper, implements bitset<>::count()
N_RWSTD_C::size_t
Xstd::size_t
N__rw_bit_count (const unsigned long*, _RWSTD_C::size_t) _THROWS (());
X__rw_bit_count (const unsigned long*, std::size_t) ;
N
N// helpers, implement bitset<>::operator<<=() and operator>>=()
Nvoid __rw_shl (unsigned long*, _RWSTD_C::size_t, _RWSTD_C::size_t) _THROWS (());
Xvoid __rw_shl (unsigned long*, std::size_t, std::size_t) ;
Nvoid __rw_shr (unsigned long*, _RWSTD_C::size_t, _RWSTD_C::size_t) _THROWS (());
Xvoid __rw_shr (unsigned long*, std::size_t, std::size_t) ;
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <size_t _Size>
Nclass bitset
N{
N    enum { _C_elembits = CHAR_BIT * sizeof (unsigned long) };
X    enum { _C_elembits = 8 * sizeof (unsigned long) };
N    enum { _C_nelems   = _Size ? 1 + (_Size - 1) / _C_elembits : 0 };
N
N    // must have at least one element even if size is 0
N    unsigned long _C_bits [_C_nelems ? _C_nelems : 1];
N
N    bool _C_valid_pos (size_t __pos) const _THROWS (()) {
X    bool _C_valid_pos (size_t __pos) const  {
N        // prevent warnings if _Size == 0
N        return _Size + 1 > __pos + 1;
N    }
N
Npublic:
N
N    class reference {
N        friend class bitset<_Size>;
N
N        bitset<_Size>& _C_ref;
N        size_t         _C_pos;
N
N        reference (bitset<_Size> &__r, size_t __p) _THROWS (())
X        reference (bitset<_Size> &__r, size_t __p) 
N            : _C_ref (__r), _C_pos (__p) { }
N    public:
N
N        reference& operator= (bool __val) _THROWS (()) {
X        reference& operator= (bool __val)  {
N            return _C_ref.set (_C_pos, __val), *this;
N        }
N
N        reference& operator= (const reference &__rhs) _THROWS (()) {
X        reference& operator= (const reference &__rhs)  {
N            return *this = bool (__rhs);
N        }
N
N        bool operator~ () const _THROWS (()) {
X        bool operator~ () const  {
N            return !bool (*this);
N        }
N
N        operator bool () const _THROWS (()) {
X        operator bool () const  {
N            return _RWSTD_CONST_CAST (const bitset<_Size>&, _C_ref)[_C_pos];
X            return const_cast< const bitset<_Size> & >(_C_ref)[_C_pos];
N        }
N
N        reference& flip () _THROWS (()) { 
X        reference& flip ()  { 
N            return _C_ref.flip (_C_pos), *this;
N        }
N    };
N
N    // 23.3.5.1, p1
N    bitset () _THROWS (()) {
X    bitset ()  {
N        reset ();
N    }
N
N    // 23.3.5.1, p2
N    bitset (unsigned long __n) _THROWS (()) {
X    bitset (unsigned long __n)  {
N        reset ();
N        _C_bits [0] =
N            __n & (~0UL >> ((_Size > _C_elembits ? 0 :
N                             _C_elembits - _Size % _C_elembits) % _C_elembits));
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    // using string::npos below rather than basic_string<...>::npos
N    // to work around a bug in g++ 2.95.2
N
N    // 23.3.5.1, p3
N    template <class _CharT, class _Traits, class _Allocator>
N    _EXPLICIT
X    explicit
N    bitset (const basic_string<_CharT, _Traits, _Allocator>&,
N            _TYPENAME basic_string<_CharT, _Traits,
X            typename basic_string<_CharT, _Traits,
N                                   _Allocator>::size_type = 0,
N            _TYPENAME basic_string<_CharT, _Traits,
X            typename basic_string<_CharT, _Traits,
N                                   _Allocator>::size_type = string::npos);
N#else
S
S    // 23.3.5.1, p3
S    _EXPLICIT bitset (const string&, size_t = 0, size_t = (size_t (-1)));
S
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    // 23.3.5.2, p1
N    bitset& operator&= (const bitset &__rhs) _THROWS (()) {
X    bitset& operator&= (const bitset &__rhs)  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            _C_bits [__i] &= __rhs._C_bits [__i];
N        return *this;
N    }
N
N    // 23.3.5.2, p3
N    bitset& operator|= (const bitset &__rhs) _THROWS (()) {
X    bitset& operator|= (const bitset &__rhs)  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            _C_bits[__i] |= __rhs._C_bits [__i];
N        return *this;
N    }
N
N    // 23.3.5.2, p5
N    bitset& operator^= (const bitset& __rhs) _THROWS (()) {
X    bitset& operator^= (const bitset& __rhs)  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            _C_bits [__i] ^= __rhs._C_bits [__i];
N        return *this;
N    }
N
N    // 23.3.5.2, p7
N    bitset& operator<<= (size_t) _THROWS (());
X    bitset& operator<<= (size_t) ;
N
N    // 23.3.5.2, p9
N    bitset& operator>>= (size_t) _THROWS (());
X    bitset& operator>>= (size_t) ;
N
N    // 23.3.5.2, p11
N    bitset& set () _THROWS (());
X    bitset& set () ;
N
N    // 23.3.5.2, p13: follows proposed resolution of lwg issue 186
N    bitset& set (size_t, bool = true);
N
N    // 23.3.5.2, p17
N    bitset& reset () _THROWS (()) {
X    bitset& reset ()  {
N        return 1 == _C_nelems ? (void)(_C_bits [0] = 0)
N            : (void)memset (_C_bits, 0, sizeof (_C_bits)), *this;
N    }
N
N    // 23.3.5.2, p19
N    bitset& reset (size_t __pos) {
N        return set (__pos, false);
N    }
N
N    // 23.3.5.2, p23
N    bitset operator~ () const _THROWS (()) {
X    bitset operator~ () const  {
N        return bitset (*this).flip ();
N    }
N
N    // 23.3.5.2, p25
N    bitset& flip () _THROWS (()) {
X    bitset& flip ()  {
N        for (size_t __i = 0; __i != _C_nelems; __i++) 
N            _C_bits [__i] = ~_C_bits [__i];
N        _C_bits [_C_nelems - !!_C_nelems] &=
N            ~0UL >> (_C_elembits - _Size % _C_elembits) % _C_elembits;
N        return *this;
N    }
N
N    // 23.3.5.2, p27
N    bitset& flip (size_t __pos) {
N        _RWSTD_REQUIRES (_C_valid_pos (__pos),
N                         (_RWSTD_ERROR_OUT_OF_RANGE,
N                          _RWSTD_FUNC ("bitset::flip(size_t)"),
N                          __pos, _C_nelems));
X        (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);
N
N        _C_bits [__pos / _C_elembits] ^= 1UL << __pos % _C_elembits;
N        return *this;
N    }
N
N    // 23.3.5.2, p??
N    bool operator[] (size_t __pos) const _THROWS (()) {
X    bool operator[] (size_t __pos) const  {
N        _RWSTD_ASSERT (_C_valid_pos (__pos));
X        ((void)0);
N        return !!(_C_bits [__pos / _C_elembits] & (1UL << __pos % _C_elembits));
N    }
N
N    // 23.3.5.2, p??
N    reference operator[] (size_t __pos) _THROWS (()) {
X    reference operator[] (size_t __pos)  {
N        _RWSTD_ASSERT (_C_valid_pos (__pos));
X        ((void)0);
N        return reference (*this, __pos); 
N    }
N
N    // 23.3.5.2, p31
N    unsigned long to_ulong () const;
N
N#if    !defined (_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
X#if    !0L     && !0L
N
N    // 23.3.5.2, p33
N    template <class _CharT, class _Traits, class _Allocator>
N    basic_string<_CharT, _Traits, _Allocator> to_string () const;
N
N# define _RWSTD_BITSET_TO_STRING(char_type) \
N    template to_string<char_type, _Traits, allocator <char_type> > ()
X# define _RWSTD_BITSET_TO_STRING(char_type)     template to_string<char_type, _Traits, allocator <char_type> > ()
N
N#else
S
S    // 23.3.5.2, p33
S    string to_string () const;
S
S# define _RWSTD_BITSET_TO_STRING(ignore)  to_string ()
S
N#endif   // !_RWSTD_NO_MEMBER_TEMPLATES && !_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N    // 23.3.5.2, p35
N    size_t count () const _THROWS (()) {
X    size_t count () const  {
N        return _Size ? _RW::__rw_bit_count (_C_bits, _C_nelems) : 0;
X        return _Size ? __rw::__rw_bit_count (_C_bits, _C_nelems) : 0;
N    }
N
N    // 23.3.5.2, p36
N    size_t size () const _THROWS (()) {
X    size_t size () const  {
N        return _Size;
N    }
N
N    // 23.3.5.2, p37
N    bool operator== (const bitset& __rhs) const _THROWS (()) {
X    bool operator== (const bitset& __rhs) const  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            if (_C_bits [__i] != __rhs._C_bits [__i])
N                return false;
N        return true;
N    }
N
N    // 23.3.5.2, p38
N    bool operator!= (const bitset& __rhs) const _THROWS (()) {
X    bool operator!= (const bitset& __rhs) const  {
N        return !(*this == __rhs);
N    }
N
N    // 23.3.5.2, p39
N    bool test (size_t __pos) const {
N        _RWSTD_REQUIRES (_C_valid_pos (__pos),
N                         (_RWSTD_ERROR_OUT_OF_RANGE,
N                          _RWSTD_FUNC ("bitset::test(size_t) const"),
N                          __pos, _C_nelems));
X        (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);
N
N        return !!(_C_bits [__pos / _C_elembits] & (1UL << __pos % _C_elembits));
N    }
N
N    // 23.3.5.2, p42
N    bool any () const _THROWS (()) {
X    bool any () const  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            if (_C_bits [__i])
N                return true;
N        return false;
N    }
N
N    // 23.3.5.2, p43
N    bool none () const _THROWS (()) {
X    bool none () const  {
N        return !any ();
N    }
N
N    // 23.3.5.2, p44
N    bitset operator<< (size_t __pos) const _THROWS (()) {
X    bitset operator<< (size_t __pos) const  {
N        return bitset (*this) <<= __pos;
N    }
N
N    // 23.3.5.2, p45
N    bitset operator>> (size_t __pos) const _THROWS (()) {
X    bitset operator>> (size_t __pos) const  {
N        return bitset (*this) >>= __pos;
N    }
N};
N
N
N// 23.3.5.2, p11
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::set () _THROWS (())
Xbitset<_Size>::set () 
N{
N    if (_C_nelems == 1)
N        _C_bits [0] = ~0;
N    else
N        memset (_C_bits, ~0, sizeof _C_bits);
N
N    _C_bits [_C_nelems - !!_C_nelems] >>=
N        (_C_elembits - _Size % _C_elembits) % _C_elembits;
N
N    return *this;
N}
N
N
N// 23.3.5.2, p13
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::set (size_t __pos, bool __val)
N{
N    _RWSTD_REQUIRES (_C_valid_pos (__pos),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("bitset::set(size_t, bool)"),
N                      __pos, _C_nelems));
X    (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);
N
N    if (__val)
N        _C_bits [__pos / _C_elembits] |=  (1UL << __pos % _C_elembits);
N    else
N        _C_bits [__pos / _C_elembits] &= ~(1UL << __pos % _C_elembits);
N    return *this;
N}
N
N
N// 23.3.5.2, p7
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::operator<<= (size_t __n) _THROWS (())
Xbitset<_Size>::operator<<= (size_t __n) 
N{
N    if (_Size > _C_elembits)
N        _RW::__rw_shl (_C_bits, _C_nelems, __n);
X        __rw::__rw_shl (_C_bits, _C_nelems, __n);
N    else
N        _C_bits [0] <<= __n;
N
N    // clear bits shifted past the MSB
N    if (_Size % _C_elembits) {
N        // prevent warnings about shifting too far
N        _C_bits [_C_nelems - 1] &=
N            ~0UL >> (_C_elembits - _Size % _C_elembits) % _C_elembits;
N    }
N    return *this;
N}
N
N
N// 23.3.5.2, p9
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::operator>>= (size_t __n) _THROWS (())
Xbitset<_Size>::operator>>= (size_t __n) 
N{
N    if (_Size > _C_elembits)
N        _RW::__rw_shr (_C_bits, _C_nelems, __n);
X        __rw::__rw_shr (_C_bits, _C_nelems, __n);
N    else
N        _C_bits [0] >>= __n;
N    return *this;
N}
N
N
N// 23.3.5.2, p31
Ntemplate <size_t _Size>
Ninline unsigned long
Nbitset<_Size>::to_ulong () const
N{
N    // add 1 to prevent warnings about pointless comparison with 0
N    for (size_t __i = 1; __i + 1 < _C_nelems + 1; ++__i)
N        _RWSTD_REQUIRES (!_C_bits[__i],
N                         (_RWSTD_ERROR_OVERFLOW_ERROR,
N                          _RWSTD_FUNC ("bitset::to_ulong() const")));
X        (!_C_bits[__i]) ? (void)0 : __rw::__rw_throw ((0 + 12), "", "");
N
N    return _C_bits [0];
N} 
N
N
N#if    !defined (_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
X#if    !0L     && !0L
N
N// 23.3.5.2, p33
Ntemplate <size_t _Size>
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Nbitset<_Size>::to_string () const 
N{
N    // extension: allocate but do not initialize
N    basic_string<_CharT, _Traits, _Allocator> __s ((_CharT*)0, _Size);
N
N    for (size_t __i = 0; __i != _Size; ++__i)
N        _Traits::assign (__s [_Size - 1 - __i], (*this)[__i] ? '1' : '0');
N
N    return __s;
N}
N
N#else   // _RWSTD_NO_MEMBER_TEMPLATES || _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
S
S// 23.3.5.2, p33
Stemplate <size_t _Size>
Sinline string bitset<_Size>::to_string () const 
S{
S    // extension: allocate but do not initialize
S    string __s ((char*)0, _Size);
S
S    for (size_t __i = 0; __i != _Size; ++__i)
S        __s [_Size - 1 - __i] = (*this)[__i] ? '1' : '0';
S
S    return __s;
S}
S
N#endif   // !_RWSTD_NO_MEMBER_TEMPLATES && !_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N// 23.3.5.3, p1
Ntemplate <size_t _Size>
Ninline bitset<_Size>
Noperator& (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) _THROWS (())
Xoperator& (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
N{
N    return bitset<_Size>(__lhs) &= __rhs;
N}
N
N
N// 23.3.5.3, p2
Ntemplate <size_t _Size>
Ninline bitset<_Size>
Noperator| (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) _THROWS (())
Xoperator| (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
N{
N    return bitset<_Size>(__lhs) |= __rhs;
N}
N
N
N// 23.3.5.3, p3
Ntemplate <size_t _Size>
Ninline bitset<_Size> 
Noperator^ (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) _THROWS (())
Xoperator^ (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
N{
N    return bitset<_Size>(__lhs) ^= __rhs;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
Ntemplate <class _CharT, class _Traits, size_t _Size> 
N_STD::basic_istream<_CharT, _Traits>&  
Xstd::basic_istream<_CharT, _Traits>&  
N__rw_extract_bitset (_STD::basic_istream<_CharT, _Traits>&,
X__rw_extract_bitset (std::basic_istream<_CharT, _Traits>&,
N                     _STD::bitset<_Size>&);
X                     std::bitset<_Size>&);
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N#if !defined (_MSC_VER) || _MSC_VER > 1300
X#if !0L || _MSC_VER > 1300
N
N// 23.3.5.3, p8
Ntemplate <class _CharT, class _Traits, size_t _Size> 
Ninline basic_ostream<_CharT,_Traits>&  
Noperator<< (basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
N{
N    return __os << __x._RWSTD_BITSET_TO_STRING (_CharT);
X    return __os << __x. template to_string<_CharT, _Traits, allocator <_CharT> > ();
N}
N
N
N// 23.3.5.3, p4
Ntemplate <class _CharT, class _Traits, size_t _Size> 
Ninline basic_istream<_CharT,_Traits>&  
Noperator>> (basic_istream<_CharT, _Traits>& __strm, bitset<_Size>& __x)
N{
N    return _RW::__rw_extract_bitset (__strm, __x);
X    return __rw::__rw_extract_bitset (__strm, __x);
N}
N
N#else   // if defined (_MSC_VER) && _MSC_VER <= 1300
S
Stemplate <size_t _Size> 
Sinline ostream& operator<< (ostream &__strm, const bitset<_Size>& __x)
S{
S    return __strm << __x._RWSTD_BITSET_TO_STRING (char);
S}
S
Stemplate <size_t _Size> 
Sinline istream& operator>> (istream &__strm, bitset<_Size>& __x)
S{
S    // working around three (yes, 3) MSVC 6.0 bugs
S    istream *__tmp = 0;
S    __tmp = &_RW::__rw_extract_bitset (__strm, __x);
S    return *__tmp;
S}
S
Stemplate <size_t _Size> 
Sinline wostream& operator<< (wostream &__strm, const bitset<_Size>& __x)
S{
S    string __s = __x.to_string ();
S    wstring __tmp (0, __s.length ());   // extension: allocate uninitialzed
S    for (string::size_type __i = 0; __i != __tmp.size (); ++__i)
S        __tmp [__i] = __s [__i];
S    return __strm << __tmp;
S}
S
Stemplate <size_t _Size> 
Sinline wistream& operator>> (wistream &__strm, bitset<_Size>& __x)
S{
S    return _RW::__rw_extract (__strm, __x);
S}
S
N#endif   // !defined (_MSC_VER) || _MSC_VER > 1300
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <bitset.cc>
N#endif
N
N
N#endif   // _RWSTD_BITSET_INCLUDED
N
L 5 "MixerController.h" 2
N#include <stdint.h>
N
Nclass MixerController {
N	public:
N		///Correspondencia entre los bits y botones. LSB a MSB
N		enum ButtonIndices {
N			BUTTON_INDEX_PROGRAM0,
N			BUTTON_INDEX_PROGRAM1,
N			BUTTON_INDEX_PROGRAM2,
N			BUTTON_INDEX_PROGRAM3,
N			BUTTON_INDEX_PROGRAM4,
N			BUTTON_INDEX_PROGRAM5,
N			BUTTON_INDEX_PROGRAM6,
N			BUTTON_INDEX_PROGRAM7,
N			
N			BUTTON_INDEX_PREVIEW0,
N			BUTTON_INDEX_PREVIEW1,
N			BUTTON_INDEX_PREVIEW2,
N			BUTTON_INDEX_PREVIEW3,
N			BUTTON_INDEX_PREVIEW4,
N			BUTTON_INDEX_PREVIEW5,
N			BUTTON_INDEX_PREVIEW6,
N			BUTTON_INDEX_PREVIEW7,
N			
N			BUTTON_INDEX_RESERVED0,
N			BUTTON_INDEX_RESERVED1,
N			BUTTON_INDEX_TRANSITION,
N			BUTTON_INDEX_CUT,
N			BUTTON_INDEX_RESERVED4,
N			BUTTON_INDEX_RESERVED5,
N			BUTTON_INDEX_RESERVED6,
N			BUTTON_INDEX_RESERVED7,
N			
N			//Add here
N			
N			BUTTON_INDEX_COUNT
N		};
N		
N		///Correspondencia entre los bits y leds. LSB a MSB
N		enum LedIndices {
N			LED_INDEX_PREVIEW0,
N			LED_INDEX_PREVIEW1,
N			LED_INDEX_PREVIEW2,
N			LED_INDEX_PREVIEW3,
N			LED_INDEX_PREVIEW4,
N			LED_INDEX_PREVIEW5,
N			LED_INDEX_PREVIEW6,
N			LED_INDEX_PREVIEW7,
N			
N			LED_INDEX_PROGRAM0,
N			LED_INDEX_PROGRAM1,
N			LED_INDEX_PROGRAM2,
N			LED_INDEX_PROGRAM3,
N			LED_INDEX_PROGRAM4,
N			LED_INDEX_PROGRAM5,
N			LED_INDEX_PROGRAM6,
N			LED_INDEX_PROGRAM7,
N			
N			//Add here
N			
N			LED_INDEX_COUNT
N		};
N		
N		static const size_t PROGRAM_CNT = BUTTON_INDEX_PROGRAM7 - BUTTON_INDEX_PROGRAM0 + 1; //8
N		static const size_t PREVIEW_CNT = BUTTON_INDEX_PREVIEW7 - BUTTON_INDEX_PREVIEW0 + 1; //8
N		static const size_t NO_SIGNAL = 0xFFFF;
N		
N		typedef std::bitset<BUTTON_INDEX_COUNT> ButtonState; ///<Tipo que representa el estado ede los botones
N		typedef std::bitset<LED_INDEX_COUNT> LedState; ///<Tipo que representa el estado ede los leds
N		
N		typedef void (*LedStateCallback)(void*, LedState); ///<Prototipo de la funcion a llamar cuando cambie el estado de los leds
N		typedef void (*BusCallback)(void*, size_t); ///<Prototipo de la funcion a llamar cuando cambie el estado de uno de los buses
N		typedef void (*ActionCallback)(void*); ///<Prototipo de la funcion a llamar cuando haya un evento
N	
N		/**
N		 * \brief Constructor
N		 */
N		MixerController(	void* ledUsrPtr = NULL,
X		MixerController(	void* ledUsrPtr = 0,
N											LedStateCallback ledCbk = NULL,
X											LedStateCallback ledCbk = 0,
N											void*	pgmUsrPtr = NULL,
X											void*	pgmUsrPtr = 0,
N											BusCallback pgmCbk = NULL,
X											BusCallback pgmCbk = 0,
N											void*	pvwUsrPtr = NULL,
X											void*	pvwUsrPtr = 0,
N											BusCallback pvwCbk = NULL,
X											BusCallback pvwCbk = 0,
N											void*	cutUsrPtr = NULL,
X											void*	cutUsrPtr = 0,
N											ActionCallback cutCbk = NULL,
X											ActionCallback cutCbk = 0,
N											void*	transUsrPtr = NULL,
X											void*	transUsrPtr = 0,
N											ActionCallback transCbk = NULL );
X											ActionCallback transCbk = 0 );
N			
N			
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de cambio de estado de leds
N		 */
N		void setLedUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de cambio de estado de leds
N		 */
N		void* getLedUserPointer() const;
N			
N		/**
N	   * \brief Establece la funcion a llamar cuando exista un nuevo dato a la entrada
N		 */
N		void setLedCallback(LedStateCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay un nuevo dato a la entrada
N		 */
N		LedStateCallback getLedCallback() const;
N											
N											
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de nueva senal en programa
N		 */
N		void setProgramUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de nueva senal en programa
N		 */
N		void* getProgramUserPointer() const;
N		
N		/**
N	   * \brief Establece la funcion a llamar cuando exista un nuevo dato a la entrada
N		 */
N		void setProgramCallback(BusCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay un nuevo dato a la entrada
N		 */
N		BusCallback getProgramCallback() const;
N		
N		
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de nueva senal en previo
N		 */
N		void setPreviewUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de nueva senal en previo
N		 */
N		void* getPreviewUserPointer() const;
N							
N		/**
N	   * \brief Establece la funcion a llamar cuando exista un nuevo dato a la entrada
N		 */
N		void setPreviewCallback(BusCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay un nuevo dato a la entrada
N		 */
N		BusCallback getPreviewCallback() const;
N
N
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de corte
N		 */
N		void setCutUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de corte
N		 */
N		void* getCutUserPointer() const;
N							
N		/**
N	   * \brief Establece la funcion a llamar cuando hay corte
N		 */
N		void setCutCallback(ActionCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay corte
N		 */
N		ActionCallback getCutCallback() const;	
N		
N		
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de transicion
N		 */
N		void setTransitionUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de transicion
N		 */
N		void* getTransitionUserPointer() const;
N							
N		/**
N	   * \brief Establece la funcion a llamar cuando hay transicion
N		 */
N		void setTransitionCallback(ActionCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay transicion
N		 */
N		ActionCallback getTransitionCallback() const;	
N											
N											
N			
N		/**
N		 * \brief Procesa el nuevo estado de los botones
N		 */
N		void process(ButtonState buttonState);
N		
N		
N		
N	private:		
N		void*							m_ledUserPtr;
N		LedStateCallback	m_ledCallback;
N	
N		void*							m_programUserPtr;
N		BusCallback				m_programCallback;
N	
N		void*							m_previewUserPtr;
N		BusCallback				m_previewCallback;
N	
N		void*							m_cutUserPtr;
N		ActionCallback		m_cutCallback;
N	
N		void*							m_transitionUserPtr;
N		ActionCallback		m_transitionCallback;
N	
N		ButtonState				m_lastState;
N		size_t						m_program;
N		size_t						m_preview;
N	
N};
N
N#endif //MIXER_CONTROLLER_H_INCLUDED
L 4 "main.cpp" 2
N#include "SerialInSerialOut.h"
L 1 "SerialInSerialOut.h" 1
N#ifndef SERIAL_IN_SERIAL_OUT_H_INCLUDED
N#define SERIAL_IN_SERIAL_OUT_H_INCLUDED
N
N#include "mbed.h"
N
N#include <bitset>
N#include <cassert>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cassert" 1
N/*
N * C++ header for C header assert.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#define __ARMCLIB_VERSION 5060037
N
N#include <assert.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
N#   define __assert_h
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define __ARMCLIB_VERSION 5060037
N#   ifndef __ARM_PROMISE
N#      define __ARM_PROMISE __promise
N#   endif
N#   undef __CLIBNS
N#   ifdef __cplusplus
N        namespace std {
N#           define __CLIBNS ::std::
N            extern "C" {
N#   else
S#       define __CLIBNS
N#   endif  /* __cplusplus */
N    extern _ARMABI_NORETURN void abort(void);
X    extern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
X    extern __declspec(__nothrow) __declspec(__noreturn) void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
N#   ifdef __cplusplus
N            }  /* extern "C" */
N        }  /* namespace std */
N#   endif
N#else
S#   undef assert
S#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !1L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 15 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cassert" 2
N
L 8 "SerialInSerialOut.h" 2
N
N///Macro de la funcion max, ya que para constantes no se admiten funciones
N#ifndef MAX
N	#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
N#endif
N
Ntemplate<size_t InCnt, size_t OutCnt>
Nclass SerialInSerialOut {
N	public:
N		typedef std::bitset<InCnt> InputData; ///<Tipo de datos que representa una palabra a la entrada
N		typedef std::bitset<OutCnt> OutputData; ///<Tipo de datos que representa una palabra a la salida
N		typedef void (*InputCallback)(void*, InputData); ///<Prototipo de la funcion a llamar cuando exista un nuevo dato
N	
N		/**
N	   * \brief Constructor
N	   * \param clk: Pin del reloj que gobierna los registros de desplazamiento
N	   * \param clk: Pin que indica la carga/descarga de los datos en el registro de desplazamiento
N	   * \param clk: Pin que se utiliza para la entrada de datos en serie
N	   * \param clk: Pin que se utiliza para la salida de datos en serie
N		 */
N		SerialInSerialOut(PinName clk,
N											PinName latch,
N											PinName load,
N											PinName dataIn,
N											PinName dataOut,
N											void* usrPtr = NULL,
X											void* usrPtr = 0,
N											InputCallback inputCbk = NULL,
X											InputCallback inputCbk = 0,
N											OutputData outData = 0 )
N			: m_clk(clk, 0)
N			, m_latch(latch, 0)
N			, m_load(load, 1)
N			, m_din(dataIn) //No necesita pullup ni pulldown
N			, m_dout(dataOut, 0)
N			, m_userPtr(usrPtr)	
N			, m_inputCallback(inputCbk)
N			, m_dataIn(0)
N			, m_dataOut(outData)
N			, m_iteration(0)
N		{
N		}
N	
N	
N
N		
N		/**
N	   * \brief Establece la siguiente palabra a transmitir
N		 */
N		void setOutputData(const OutputData& d) {
N			m_dataOut = d;
N		}
N		
N		/**
N	   * \brief Devuelve la siguiente palabra a transmitir
N		 */
N		const InputData& getOutputData() const {
N			return m_dataOut;
N		}
N		
N
N		
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de nuevo dato a la entrada
N		 */
N		void setUserPointer(void* usrPtr) {
N			m_userPtr = usrPtr;
N		}
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de nuevo dato a la entrada
N		 */
N		void* getUserPointer() const {
N			return m_userPtr;
N		}
N		
N		/**
N	   * \brief Establece la funcion a llamar cuando exista un nuevo dato a la entrada
N		 */
N		void setInputCallback(InputCallback cbk) {
N			m_inputCallback = cbk;
N		}
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay un nuevo dato a la entrada
N		 */
N		InputCallback getInputCallback() const {
N			return m_inputCallback;
N		}
N		
N		
N		
N		/**
N	   * \brief Avanza al siguiente estado
N		 */
N		void tick() {
N			//La configuracion de los pines se realiza en el pulso de bajada
N			if(m_clk){ 
N				//Pulso de bajada
N				m_clk = 0;
N				
N			} else {
N				//Pulso de subida. La configuracion se realiza aqui
N				m_clk = 1;
N				
N				//Configurar los pines de salida y leer a la entrada
N				if(m_iteration == 0) {
N					//En la primera iteracion cargar los valores en el registro de desplazamiento
N					m_latch = 1;
N					m_load = 0;
N					
N				} else {
N					//Dejar de cargar los valores
N					if(m_iteration == 1) {
N						m_latch = 0;
N						m_load = 1;
N					}
N					assert(!static_cast<bool>(m_latch)); //Asegurarse de que la carga este desactivada
X					((!static_cast<bool>(m_latch)) ? (void)0 : ::std:: __aeabi_assert("!static_cast<bool>(m_latch)", "SerialInSerialOut.h", 123), (__promise)((!static_cast<bool>(m_latch))?1:0)); 
N					assert(static_cast<bool>(m_load)); //Asegurarse de que la carga este desactivada
X					((static_cast<bool>(m_load)) ? (void)0 : ::std:: __aeabi_assert("static_cast<bool>(m_load)", "SerialInSerialOut.h", 124), (__promise)((static_cast<bool>(m_load))?1:0)); 
N					
N					//Durante las iteraciones [1 ... InCnt], leer los datos a la entrada
N					if(m_iteration <= m_dataIn.size()) {
N						//Hacer "hueco" al dato entrante en el LSB
N						m_dataIn <<= 1;
N						
N						//Escribe el dato a la entrada en el LSB (posicion 0)
N						m_dataIn.set(0, static_cast<bool>(m_din));
N						
N						//Si se trata del ultimo valor, llamar a la funcion de atencion
N						if(m_iteration == m_dataIn.size() && m_inputCallback) {
N							m_inputCallback(m_userPtr, m_dataIn);
N						}
N					}
N					
N					//Durante los ultimos OutCnt sacar los valores a la salida
N					const int outIndex = static_cast<int>(m_iteration) - static_cast<int>(ITERATION_OFFSET_OUT);
N					if(outIndex >= 0) {
N						//Asegurarse de que el indice es valido
N						assert(outIndex < m_dataOut.size());
X						((outIndex < m_dataOut . size()) ? (void)0 : ::std:: __aeabi_assert("outIndex < m_dataOut.size()", "SerialInSerialOut.h", 144), (__promise)((outIndex < m_dataOut . size())?1:0));
N						
N						//Sacar el valor correspondiente a este indice,
N						//de MSB hacia LSB
N						m_dout = m_dataOut.test(m_dataOut.size() - outIndex - 1);
N					}
N				}
N				
N				//Siguiente iteracion
N				m_iteration = m_iteration < (ITERATION_COUNT-1) ? m_iteration + 1 : 0;
N				assert(m_iteration < ITERATION_COUNT); //Nunca puede ser mayor o igual que el maximo
X				((m_iteration < ITERATION_COUNT) ? (void)0 : ::std:: __aeabi_assert("m_iteration < ITERATION_COUNT", "SerialInSerialOut.h", 154), (__promise)((m_iteration < ITERATION_COUNT)?1:0)); 
N				
N			}
N		}
N		
N		
N		
N		
N	
N	private:
N		DigitalOut		m_clk; ///<Pin que gobierna el reloj de los registros de desplazamiento
N		DigitalOut		m_latch; ///<Pin que carga los datos en los registros de salida
N		DigitalOut		m_load; ///<Pin que carga los datos en los registros de desplazamiento de entrada. Activo a nivel bajo
N		DigitalIn			m_din; ///<Datos de entrada en serie
N		DigitalOut		m_dout; ///<Datos de salida en serie
N	
N		void*					m_userPtr; ///<Puntero que acompaa a las llamadas de entrada
N		InputCallback	m_inputCallback; ///<Funcion a llamar cuando exista un nuevo dato a la entrada
N
N		InputData			m_dataIn;	///<Ultima palabra leida
N		OutputData 		m_dataOut; ///<Siguiente palabra a transmitir
N	
N		size_t				m_iteration; //Indice de la iteracion. [0, ITERATION_COUNT)
N	
N	
N		///El numero de iteraciones que se van a realizar para introducir/sacar
N		///Valores en serie. +1 para contar el pulso del latch
N		static const size_t ITERATION_COUNT = MAX(InCnt, OutCnt) + 1;
X		static const size_t ITERATION_COUNT = ((InCnt) > (OutCnt) ? (InCnt) : (OutCnt)) + 1;
N	
N		///El numero de interaciones que deben transcurrir antes de comenzar a
N		///sacar la salida. Esto se debe a que la salida se escribe en las ultimas
N		///iteraciones. Nota: Nunca sera menor que 1, ya que al menos le precede el
N		///pulso del latch.
N		static const size_t ITERATION_OFFSET_OUT = ITERATION_COUNT - OutCnt; 
N		
N};
N
N#endif //SERIAL_IN_SERIAL_OUT_H_INCLUDED
L 5 "main.cpp" 2
N
N#include <cassert>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cassert" 1
N/*
N * C++ header for C header assert.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#define __ARMCLIB_VERSION 5060037
N
N#include <assert.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\assert.h" 1
N/* assert.h: ANSI 'C' (X3J11 Oct 88) library header section 4.2 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N/*
N * The assert macro puts diagnostics into programs. When it is executed,
N * if its argument expression is false, it writes information about the
N * call that failed (including the text of the argument, the name of the
N * source file, and the source line number - the latter are respectively
N * the values of the preprocessing macros __FILE__ and __LINE__) on the
N * standard error stream. It then calls the abort function.
N * If its argument expression is true, the assert macro returns no value.
N */
N
N/*
N * Note that <assert.h> may be included more that once in a program with
N * different setting of NDEBUG. Hence the slightly unusual first-time
N * only flag.
N */
N
N#ifndef __assert_h
S#   define __assert_h
S#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
S#define __ARMCLIB_VERSION 5060037
S#   ifndef __ARM_PROMISE
S#      define __ARM_PROMISE __promise
S#   endif
S#   undef __CLIBNS
S#   ifdef __cplusplus
S        namespace std {
S#           define __CLIBNS ::std::
S            extern "C" {
S#   else
S#       define __CLIBNS
S#   endif  /* __cplusplus */
S    extern _ARMABI_NORETURN void abort(void);
S    extern _ARMABI_NORETURN void __aeabi_assert(const char *, const char *, int) __attribute__((__nonnull__(1,2)));
S#   ifdef __cplusplus
S            }  /* extern "C" */
S        }  /* namespace std */
S#   endif
N#else
N#   undef assert
N#   undef __promise
N#endif
N
N#ifdef NDEBUG
S#   define assert(ignore) ((void)0)
S#   define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#else
N#   if defined __DO_NOT_LINK_PROMISE_WITH_ASSERT
X#   if 0L
S#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort())
S#      elif defined __STDC__
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__))
S#      else
S#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert("e", __FILE__, __LINE__))
S#      endif
S#      define __promise(e) ((__ARM_PROMISE)((e)?1:0))
N#   else
N#      if defined __OPT_SMALL_ASSERT && !defined __ASSERT_MSG && !defined __STRICT_ANSI__ && !(_AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
X#      if 0L && !1L && !0L && !(_AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0))
S#undef __promise
S#          define assert(e) ((e) ? (void)0 : __CLIBNS abort(), (__ARM_PROMISE)((e)?1:0))
N#      else
N#          define assert(e) ((e) ? (void)0 : __CLIBNS __aeabi_assert(#e, __FILE__, __LINE__), (__ARM_PROMISE)((e)?1:0))
N#      endif
N#      define __promise(e) assert(e)
N#   endif
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* end of assert.h */
N
L 15 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cassert" 2
N
L 7 "main.cpp" 2
N
N
N
N//Para for ever:
N#define ever (;;)
N
N
N
N///Tipo que representa la interfaz de E/S en serie utilizado
Ntypedef SerialInSerialOut<MixerController::BUTTON_INDEX_COUNT, 
N													MixerController::LED_INDEX_COUNT > SerialInterface;
N
N
N//Interfaz USART
Nstatic Serial pc(USBTX, USBRX); // tx, rx
N
N//Modulo que representa el estado del mezclador
Nstatic MixerController mixer;
N
N//Modulo que realiza E/S en serie 
N//por registros de desplazamiento
Nstatic SerialInterface serialIO(
N	p14, //CLK
N	p13, //Latch
N	p8, //Load
N	p11, //Din
N	p12 //Dout
N);
N
N//Ticker
Nstatic Ticker serialIOClk;
Nstatic volatile bool serialIOClkEventFlag = false;
Nstatic void serialIOClkEvent() {
N	serialIOClkEventFlag = true;
N}
N
N
N//Funciones que enlazan modulos
Nstatic void mixerButCallback(void* usrPtr, MixerController::ButtonState but) {
N	assert(usrPtr);
X	((usrPtr) ? (void)0 : ::std:: __aeabi_assert("usrPtr", "main.cpp", 46), (__promise)((usrPtr)?1:0));
N	static_cast<MixerController*>(usrPtr)->process(but);
N}
N
Nstatic void mixerLedCallback(void* usrPtr, MixerController::LedState led) {
N	assert(usrPtr);
X	((usrPtr) ? (void)0 : ::std:: __aeabi_assert("usrPtr", "main.cpp", 51), (__promise)((usrPtr)?1:0));
N	static_cast<SerialInterface*>(usrPtr)->setOutputData(led);
N}
N
Nstatic void mixerPgmCallback(void* usrPtr, size_t sig) {
N	assert(usrPtr);
X	((usrPtr) ? (void)0 : ::std:: __aeabi_assert("usrPtr", "main.cpp", 56), (__promise)((usrPtr)?1:0));
N	static_cast<Serial*>(usrPtr)->printf("pgm %u\n", sig);
N}
N
Nstatic void mixerPvwCallback(void* usrPtr, size_t sig) {
N	assert(usrPtr);
X	((usrPtr) ? (void)0 : ::std:: __aeabi_assert("usrPtr", "main.cpp", 61), (__promise)((usrPtr)?1:0));
N	static_cast<Serial*>(usrPtr)->printf("pvw %u\n", sig);
N}
N
Nstatic void mixerCutCallback(void* usrPtr) {
N	assert(usrPtr);
X	((usrPtr) ? (void)0 : ::std:: __aeabi_assert("usrPtr", "main.cpp", 66), (__promise)((usrPtr)?1:0));
N	static_cast<Serial*>(usrPtr)->printf("cut\n");
N}
N
Nstatic void mixerTransCallback(void* usrPtr) {
N	assert(usrPtr);
X	((usrPtr) ? (void)0 : ::std:: __aeabi_assert("usrPtr", "main.cpp", 71), (__promise)((usrPtr)?1:0));
N	static_cast<Serial*>(usrPtr)->printf("trans\n");
N}
N
N
N
Nint main(void) {
N	//Configura USART
N	pc.format(8, Serial::None, 1); //Bits, Parity, Stop bits
N	pc.baud(9600);
N
N	//Enlazar el controlador a la salida por usart
N	mixer.setProgramUserPointer(&pc);
N	mixer.setPreviewUserPointer(&pc);
N	mixer.setCutUserPointer(&pc);
N	mixer.setTransitionUserPointer(&pc);
N	mixer.setProgramCallback(mixerPgmCallback);
N	mixer.setPreviewCallback(mixerPvwCallback);
N	mixer.setCutCallback(mixerCutCallback);
N	mixer.setTransitionCallback(mixerTransCallback);
N	
N	//Enlazar el controlador con la interfaz de registros serie/paralelo
N	mixer.setLedUserPointer(&serialIO);
N	mixer.setLedCallback(mixerLedCallback);
N	
N	serialIO.setUserPointer(&mixer);
N	serialIO.setInputCallback(mixerButCallback);
N	
N	//Configurar el reloj
N	const uint32_t T_CLK = 1000; //1ms de periodod de reloj
N	serialIOClk.attach_us(serialIOClkEvent, T_CLK/2);
N	
N	//Bucle de atencion a los flags de las interrupciones
N	for ever {
X	for (;;) {
N		//Atender al reloj del controlador SISO
N		if(serialIOClkEventFlag) {
N			serialIO.tick();
N			serialIOClkEventFlag = false;
N		}
N		
N		//Dormirse hasta la llegada de otra interrupcion.
N		//Cuidado con la seccion critica
N		__disable_irq();
N		if(!serialIOClkEventFlag) {
N			__WFI();
X			__wfi();
N		}
N		__enable_irq();
N	}
N}
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.CC"
N/***************************************************************************
N *
N * string.cc - Definitions for the Standard Library string classes
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N#if    defined (_RWSTD_LLP64_ARCHITECTURE)          \
N    && defined (_RWSTD_NO_STATIC_CONST_MEMBER_INIT) \
N    && defined (_RWBUILD_std)
X#if    0L              && 0L     && 0L
S
Stemplate <class _CharT, class _Traits, class _Allocator>
Sconst _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Sbasic_string<_CharT, _Traits, _Allocator>::npos = size_t(-1);
S
N#elif !defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT) 
X#elif !0L 
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nconst _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xconst typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::npos;
N
N#endif    
N
N
N#ifndef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_RW::__null_ref<_CharT, _Traits, _Allocator>
X__rw::__null_ref<_CharT, _Traits, _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::__nullref;
N
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::_C_string_ref_type *
Xtypename basic_string<_CharT, _Traits, _Allocator>::_C_string_ref_type *
Nbasic_string<_CharT, _Traits, _Allocator>::
N_C_getRep (size_type __cap, size_type __len)
N{
N    _RWSTD_REQUIRES (__cap <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::_C_getRep(size_type, "
N                                   "size_type)"), __cap, max_size ()));
X    (__cap <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __cap, max_size ());
N
N    _RWSTD_REQUIRES (__len <= __cap,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::_C_getRep(size_type, "
N                                   "size_type)"), __len, __cap));
X    (__len <= __cap) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __len, __cap);
N
N    if (!__cap) {
N        _RWSTD_ASSERT (!__len);
X        ((void)0);
N
N#ifndef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N        return &__nullref;
N
N#else   // if defined (_RWSTD_NO_COLLAPSE_TEMPLATE_STATICS)
S
S        return _RWSTD_REINTERPRET_CAST (_C_string_ref_type*, &_RW::__nullref);
S
N#endif   // _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N    }
N
N    // allocate, initialize the __string_ref, and initialize each character
N    _C_string_ref_type * __ret =
N    _RWSTD_REINTERPRET_CAST (_C_string_ref_type*,
N            _RWSTD_VALUE_ALLOC (_C_value_alloc_type,
N                                allocate (__cap + sizeof (_C_string_ref_type) /
N                                          sizeof (value_type) + 2)));
X    reinterpret_cast< _C_string_ref_type* >(allocator_type::allocate (__cap + sizeof (_C_string_ref_type) / sizeof (value_type) + 2));
N
N    // avoid copy construction (mutex isn't copy-constructible)
N    // _C_ref_alloc_type (*this).construct (__ret, _C_string_ref_type ());
N    new (__ret) _C_string_ref_type ();
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N    // set initial reference count to 1
N    __ret->_C_init (1, __cap, __len);
N
N#else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S
S    // initial reference count is 0 (ref counting disabled)
S    __ret->_C_init (0, __cap, __len);
S
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N
N    _RWSTD_VALUE_ALLOC (_C_value_alloc_type, construct (__ret->data () + __len,
N        value_type ()));
X    allocator_type::construct (__ret->data () + __len, value_type ());
N
N    return __ret;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const basic_string &__s, 
N              size_type __pos, size_type __n, const allocator_type& __alloc)
N    : allocator_type (__alloc)
N{
N    _RWSTD_REQUIRES (__pos <= __s.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::basic_string(const "
N                                   "basic_string&, size_type, size_type)"),
N                      __pos, __s.size ()));
X    (__pos <= __s . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, __s . size ());
N
N    size_type __slen = __s.size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N    size_type __nlen =  __n == npos ? 0 : __n;
N    size_type __maxlen = __nlen > __rlen ? __nlen : __rlen; 
N    if (__maxlen)
N        _C_data = _C_allocate (0, __maxlen, __rlen);
N    else
N        _C_data = _C_getRep (__maxlen,__rlen)->data();
N
N    traits_type::copy(_C_data, &__s._C_data[__pos], __rlen);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid basic_string<_CharT, _Traits, _Allocator>::
N_C_initn (size_type __n, value_type __c)
N{
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::_C_initn(size_type, "
N                                   "value_type)"), __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N   
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    while (__n--)
N        traits_type::assign (_C_data [__n], __c);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const_pointer __s, size_type __n, const allocator_type& __alloc)
N    : allocator_type (__alloc)
N{
N    // extension: if `s' is 0 then `n' unitialized elements are allocated
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::basic_string(const_pointer,"
N                                   "size_type, const allocator_type&)"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N    
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    if (__s)
N        traits_type::copy (_C_data, __s, __n);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const_pointer __s, const allocator_type& __alloc)
N    : allocator_type(__alloc)
N{     
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    size_type __n = traits_type::length (__s);
N
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    traits_type::copy (_C_data, __s, __n);
N}
N
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _InputIterator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (_InputIterator __first, _InputIterator __last, 
N              const allocator_type &__alloc)
N    : allocator_type (__alloc),
N      _C_data (_C_null ())
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    replace (_C_make_iter (_C_data), _C_make_iter (_C_data), __first, __last);
N}
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const_pointer __first, const_pointer __last, 
N              const allocator_type& __alloc)
N    : allocator_type (__alloc)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N    _RWSTD_ASSERT (__first <= __last);
X    ((void)0);
N
N    size_type __n = __last - __first;
N
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    traits_type::copy (_C_data, __first, __n);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::operator= (const basic_string &__rhs)
N{
N    if (__rhs._C_pref ()->_C_ref_count () > 0) {
N        __rhs._C_pref ()->_C_inc_ref ();
N        _C_unlink ();
N        _C_data = __rhs._C_data;
N    }
N    else if (this != &__rhs)
N        replace (0, size (), __rhs.data (), __rhs.size ());
N
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::operator= (const_pointer __rhs)
N{
N    _RWSTD_ASSERT (__rhs != 0);
X    ((void)0);
N
N    size_type __len = traits_type::length (__rhs);
N
N    if (0 == __len) {
N        if (_C_pref ()->_C_ref_count () == 1) {
N            _C_pref ()->_C_size = 0;
N            traits_type::assign (_C_data [0], value_type ());
N        }
N        else {
N            _C_unlink();
N            _C_data = _C_null ();
N        }
N        return *this;
N    }
N
N    return replace (0, size (), __rhs, __len);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Nappend (const basic_string &__str, size_type __pos, size_type __n)
N{
N    _RWSTD_REQUIRES (__pos <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::append(const basic_string&,"
N                                   " size_type, size_type)"),
N                      __pos, __str.size ()));
X    (__pos <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, __str . size ());
N
N    size_type __slen = __str.size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N
N
N    _RWSTD_REQUIRES (size () <= max_size () - __rlen,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::append(const basic_string&,"
N                                   " size_type, size_type)"),
N                      size (), max_size () - __rlen));
X    (size () <= max_size () - __rlen) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size (), max_size () - __rlen);
N
N    replace(size(), 0, __str.c_str(), __str.size(), __pos, __n);
N
N    return *this;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Nassign (const basic_string &__str, size_type __pos, size_type __n)
N{
N    _RWSTD_REQUIRES (__pos <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::assign(basic_string&, "
N                                   "size_type, size_type)"),
N                      __pos, __str.size ()));
X    (__pos <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, __str . size ());
N
N    size_type __slen = __str.size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N    return replace(0, size(), __str, __pos, __rlen);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Ninsert (size_type __pos1, const basic_string& __str, 
N        size_type  __pos2,  size_type         __n)
N{
N    _RWSTD_REQUIRES (__pos1 <= size() && __pos2 <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, const "
N                                   "basic_string&, size_type, size_type)"), 
N                      __pos1 > size() ? __pos1:__pos2, __str.size ()));
X    (__pos1 <= size() && __pos2 <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos1 > size() ? __pos1:__pos2, __str . size ());
N    
N    size_type __slen = __str.size() - __pos2;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N
N    _RWSTD_REQUIRES (size () <= max_size () - __rlen,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, const "
N                                   "basic_string&, size_type, size_type)"), 
N                      size (), max_size () - __rlen));
X    (size () <= max_size () - __rlen) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size (), max_size () - __rlen);
N
N    return replace(__pos1, 0, __str, __pos2, __n);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Ninsert (size_type __pos1, const basic_string &__str)
N{
N    _RWSTD_REQUIRES (__pos1 <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, const "
N                                   "basic_string&)"), __pos1, size ()));
X    (__pos1 <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos1, size ());
N    
N    _RWSTD_REQUIRES (size() <= max_size() - __str.size(),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, "
N                                   "const basic_string&)"),
N                      size (), max_size () - __str.size ()));
X    (size() <= max_size() - __str . size()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size (), max_size () - __str . size ());
N
N    return replace(__pos1, 0, __str);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::iterator 
Xtypename basic_string<_CharT, _Traits, _Allocator>::iterator 
Nbasic_string<_CharT, _Traits, _Allocator>::
Nreplace (size_type __pos1, size_type __n1, const_pointer __cs, 
N         size_type __cslen, size_type __pos2, size_type __n2)
N{
N    _RWSTD_REQUIRES (__pos1 <= size () && __pos2 <= __cslen,
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::replace(size_type, size_type,"
N                                   " const_pointer, size_type, size_type, "
N                                   "size_type)"), 
N                      __pos1 > size() ? __pos1 : __pos2,
N                      size () > __cslen ? size () : __cslen));
X    (__pos1 <= size () && __pos2 <= __cslen) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos1 > size() ? __pos1 : __pos2, size () > __cslen ? size () : __cslen);
N
N    size_type __slen = size() - __pos1;
N    size_type __xlen = __n1 < __slen ? __n1 : __slen; 
N    size_type __clen = __cslen - __pos2;
N    size_type __rlen = __n2 < __clen ? __n2 : __clen; 
N
N    _RWSTD_REQUIRES (size () - __xlen <= max_size () - __rlen,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::replace(size_type, size_type,"
N                                   " const_pointer, size_type, size_type, "
N                                   "size_type)"), 
N                      size () - __xlen, max_size() - __rlen));
X    (size () - __xlen <= max_size () - __rlen) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size () - __xlen, max_size() - __rlen);
N
N    size_type __len = size() - __xlen + __rlen;  // final string length
N
N    if (!__len) {
N        // Special case a substitution that leaves the string empty.
N        _C_unlink ();
N        _C_data = _C_null ();
N    }
N    else {
N        // Length of bit at end of string
N        size_type __rem = size () - __xlen - __pos1;
N        // Check for shared representation, insufficient capacity, 
N        //  or overlap copy.
N        if (   _C_pref()->_C_ref_count () > 1
N            || capacity () < __len
N            || __cs && __cs >= data () && __cs < data () + size ()) {
N            // Need to allocate a new reference.
N            size_t __new_capacity = max (_RW::__rw_new_capacity (size(), this),
X            size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
N                                         size_t (__len));
N            _C_string_ref_type * __temp = _C_getRep(__new_capacity, __len);
N            if (__pos1)
N                traits_type::copy (__temp->data (), _C_data, __pos1);
N
N            if (__rlen)
N                traits_type::copy (__temp->data() + __pos1,
N                                   __cs + __pos2, __rlen);
N
N            if (__rem)
N                traits_type::copy (__temp->data() + __pos1 + __rlen,
N                                   _C_data + __pos1 + __n1, __rem);
N            _C_unlink();
N            _C_data = __temp->data();
N        }
N        else {
N            // Current reference has enough room.
N            if (__rem)
N                traits_type::move (_C_data + __pos1 + __rlen,
N                                   _C_data + __pos1 + __n1, __rem);
N
N            if (__rlen)
N                traits_type::move (_C_data + __pos1, __cs + __pos2, __rlen);
N
N            traits_type::assign (_C_data [_C_pref()->_C_size = __len],
N                                 value_type ());
N        }
N    }
N    return _C_make_iter (_C_data + __pos1);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Nreplace (size_type __pos, size_type __n, size_type __n2, value_type __c)
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string:::replace(size_type, "
N                                   "size_type, size_type, value_type)"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N    
N    size_type __slen = size() - __pos;
N    size_type __xlen = __n < __slen ? __n : __slen; 
N
N    _RWSTD_REQUIRES (size() - __xlen < max_size () - __n2,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::replace(size_type, "
N                                   "size_type, size_type, value_type)"), 
N                      size () - __xlen, max_size () - __n2));
X    (size() - __xlen < max_size () - __n2) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size () - __xlen, max_size () - __n2);
N    
N    size_type __len = size() - __xlen + __n2;  // Final string length.
N
N    if (!__len)
N    {
N      // Special case a substitution that leaves the string empty.
N      _C_unlink();
N      _C_data = _C_null ();
N    }
N    else
N    {
N      size_type __rem = size () - __xlen - __pos; // length of bit at the end
N      // Check for shared representation, insufficient capacity, 
N      if ( (_C_pref()->_C_ref_count() > 1) || (capacity() < __len))
N      {
N        // Need to allocate a new reference.
N          size_t __new_capacity = max (_RW::__rw_new_capacity (size(), this),
X          size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
N                                       size_t (__len));
N        _C_string_ref_type * __temp = _C_getRep(__new_capacity, __len);
N        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
N        if (__n2) traits_type::assign(__temp->data()+__pos, __n2, __c);
N        if (__rem)
N            traits_type::copy (__temp->data () + __pos + __n2,
N                               _C_data + __pos + __n, __rem);
N        _C_unlink();
N        _C_data = __temp->data();
N      }
N      else
N      {
N        // Current reference has enough room.
N        if (__rem) 
N            traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, __rem);
N        if (__n2)
N            traits_type::assign(_C_data+__pos, __n2, __c);
N        traits_type::assign (_C_data [_C_pref()->_C_size = __len],
N                             value_type ());
N      }
N    }
N    return *this;
N}
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIter>
Nbasic_string<_CharT, _Traits, _Allocator>& 
Nbasic_string<_CharT, _Traits, _Allocator>::
Nreplace (iterator __first1, iterator __last1,
N         _InputIter __first2, _InputIter __last2, _RWSTD_DISPATCH_INT (false))
X         _InputIter __first2, _InputIter __last2, const __rw::__rw_select < false > *)
N{
N    _RWSTD_ASSERT_RANGE (__first1, _C_make_iter (_C_data + size ()));
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first2, __last2);
X    ((void)0);
N
N     // use a (probably) faster algorithm if possible
N     if (__is_bidirectional_iterator(_RWSTD_ITERATOR_CATEGORY (_InputIter,
N                                                               __last2)))
X     if (__is_bidirectional_iterator(typename std::iterator_traits< _InputIter > ::iterator_category ()))
N         return __replace_aux (__first1, __last1, __first2, __last2);
N
N     for ( ; __first2 != __last2; ++__first1, ++__first2) {
N
N         size_type __off = __first1 - _C_make_iter (_C_data);
N
N         _RWSTD_REQUIRES (__off <= max_size(),
N                          (_RWSTD_ERROR_LENGTH_ERROR,
N                           _RWSTD_FUNC ("basic_string::replace(iterator, "
N                                        "iterator, InputIterator, "
N                                        "InputIterator)"),
N                           __first1 - _C_make_iter (_C_data), max_size ()));
X         (__off <= max_size()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __first1 - _C_make_iter (_C_data), max_size ());
N         
N         // extend the string if necessary
N         if (__first1 == __last1) {
N             // compute the size of new buffer
N             size_t __new_cap = _RW::__rw_new_capacity (size (), this);
X             size_t __new_cap = __rw::__rw_new_capacity (size (), this);
N             size_t __delta   = __new_cap - size ();
N
N             // allocate a new buffer
N             _C_string_ref_type *__tmp = _C_getRep (__new_cap, __new_cap);
N
N             // copy data from old to new, leaving a hole for additions
N             traits_type::copy (__tmp->data (), _C_data, __off);
N             traits_type::copy (__tmp->data () + __off + __delta,
N                                _C_data + __off,
N                                _C_make_iter (_C_data + size ()) - __last1);
N             _C_unlink ();
N             _C_data  = __tmp->data ();
N             __first1 = _C_make_iter (_C_data + __off);
N             __last1  = __first1 + __delta;
N         }
N
N         // copy data over
N         traits_type::assign (*__first1, *__first2);
N     }
N
N     if (__first1 != __last1)
N         replace (__first1 - _C_make_iter (_C_data), __last1 - __first1,
N                  0, value_type ());
N
N     return *this;
N}
N
N// Special function for random access and bi-directional iterators
N// Avoids the possibility of multiple allocations
N// We still have to copy characters over one at a time.
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIterator>
Nbasic_string<_CharT, _Traits, _Allocator>& 
Nbasic_string<_CharT, _Traits, _Allocator>::
N__replace_aux (iterator __first1, iterator __last1, 
N               _InputIterator __first2, _InputIterator __last2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, _C_make_iter (_C_data + size ()));
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first2, __last2);
X    ((void)0);
N
N    difference_type __n2  = _DISTANCE (__first2, __last2, __n2);
X    difference_type __n2  = std::distance (__first2, __last2);
N    size_type       __n   = __last1 - __first1;
N    size_type       __pos = __first1 - _C_make_iter (_C_data);
N
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::__replace_aux(iterator, "
N                                   "iterator, InputIterator, InputIterator)"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    size_type __slen = size() - __pos;
N    size_type __xlen = __n < __slen ? __n : __slen; 
N
N    _RWSTD_REQUIRES (size () - __xlen < max_size() - __n2,
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::__replace_aux(iterator, "
N                                   "iterator, InputIterator, InputIterator)"),
N                      size () - __xlen, max_size () - __n2));
X    (size () - __xlen < max_size() - __n2) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size () - __xlen, max_size () - __n2);
N
N    size_type __len = size() - __xlen + __n2;  // Final string length.
N
N    if (!__len) {
N        // Special case a substitution that leaves the string empty.
N        _C_unlink();
N        _C_data = _C_null ();
N    }
N    else {
N      size_type __d = 0;
N      size_type __rem = size() - __xlen - __pos; // length of bit at the end
N      // Check for shared representation, insufficient capacity, 
N      if ( (_C_pref()->_C_ref_count () > 1) || (capacity() < __len))
N      {
N        // Need to allocate a new reference.
N        size_t __new_capacity = max (_RW::__rw_new_capacity (size(), this),
X        size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
N                                     size_t (__len));
N        _C_string_ref_type * __temp = _C_getRep(__new_capacity, __len);
N        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
N        for (__d = 0; __d < (size_type)__n2; __d++)
N            traits_type::assign (*(__temp->data()+__pos+__d), *__first2++);
N        if (__rem)
N            traits_type::copy (__temp->data () + __pos + __n2,
N                               _C_data + __pos + __n, __rem);
N        _C_unlink();
N        _C_data = __temp->data();
N      }
N      else
N      {
N        // Current reference has enough room.
N        if (__rem)  
N          traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, __rem);
N        for (__d = 0; __d < (size_type)__n2; __d++)
N            traits_type::assign (*(_C_data+__pos+__d), *__first2++);
N        traits_type::assign (_C_data[_C_pref()->_C_size = __len],
N                             value_type());
N      }
N    }
N    return *this;
N}
N
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Ncopy (pointer __s, size_type __n, size_type __pos) const
N{
N    _RWSTD_REQUIRES (__pos <= size(),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::copy(pointer, size_type, "
N                                   "size_type)"), __pos, size ()));
X    (__pos <= size()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    size_type __slen = size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen;
N    traits_type::copy(__s, _C_data+__pos, __rlen);
N    return __rlen;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    for (size_type xpos = __pos; (xpos + __n) <= size() ; xpos++)
N    {
N      if (!traits_type::compare(_C_data+xpos, __s, __n))
N        return xpos;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nrfind (const_pointer __s,  size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::rfind(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (size() < __n)
N      return npos;
N    
N    size_type __slen = size() -__n;
N    size_type xpos_start = __slen < __pos ? __slen : __pos; 
N
N    for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
N    {
N      if (!traits_type::compare(_C_data+xpos-1, __s, __n))
N        return xpos-1;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_of (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::find_first_of(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    for (size_type xpos = __pos; xpos < size() ; xpos++)
N    {
N      for (size_type __i = 0; __i < __n ; __i++)
N        if (traits_type::eq(_C_data[xpos], __s[__i]))
N          return xpos;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_last_of (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find_last_of(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (size())
N    {
N      size_type __slen = size() -1;
N      size_type xpos_start = __pos < __slen ? __pos : __slen; 
N      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
N      {
N        for(size_type __i = 0; __i < __n ; __i++)
N          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
N            return xpos-1;
N      } 
N    }
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_not_of (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find_first_not_of("
N                                  "const_pointer, size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    for (size_type xpos = __pos; xpos < size() ; xpos++)
N    {
N      bool found = false;
N      for (size_type __i = 0; __i < __n ; __i++)
N      {
N        if (traits_type::eq(_C_data[xpos], __s[__i]))
N        {
N          found = true;
N          break;
N        }
N      }
N      if (!found)
N        return xpos;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_last_not_of(const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find_last_not_of("
N                                  "const_pointer, size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N    
N    if (size())
N    {
N      size_type __slen = size() -1;
N      size_type xpos_start = __pos < __slen ? __pos : __slen; 
N      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
N      {
N        bool found = false;
N        for (size_type __i = 0; __i < __n ; __i++)
N        {
N          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
N          {
N            found = true;
N            break;
N          }
N        }
N        if (!found)
N          return xpos-1;
N      }
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nsubstr (size_type __pos, size_type __n) const
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::substr(size_type, size_type) "
N                                   "const"), __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    size_type __slen = size() -__pos;
N    size_type __rlen = __n < __slen ? __n : __slen;
N    return basic_string (_C_data + __pos, __rlen);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint basic_string<_CharT, _Traits, _Allocator>::
Ncompare (size_type __pos1, size_type __n1, 
N         const basic_string& __str, 
N         size_type __pos2, size_type __n2) const
N{
N    _RWSTD_REQUIRES (__pos2 <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::compare(size_type, size_type,"
N                                   "const basic_string&, size_type, size_type) "
N                                   "const"), __pos2, __str.size ()));
X    (__pos2 <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos2, __str . size ());
N
N//  "reduce" __n2 if necessary, where
N//  "reduce" := Ensure __pos2+__n2 < __str.size() so we can call a function that
N//              doesn't check this same inequality.
N
N    if(__str.size() - __pos2 < __n2)
N      __n2 = __str.size() - __pos2;
N
N//  compare(size_type, size_type, char*, size_type) will both
N//   (i) check pos1 to make sure it's less than size() and
N//  (ii) "reduce" __n1 if necessary
N
N    return compare(__pos1, __n1, __str.c_str()+__pos2, __n2);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint basic_string<_CharT, _Traits, _Allocator>::
Ncompare (size_type __pos, size_type __n1,
N         const_pointer __s, size_type __n2) const
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::compare(size_type, size_type,"
N                                   " const const_pointer, size_type) const"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    if(size() - __pos < __n1)
N      __n1 = size() - __pos;
N    size_type __rlen = __n1 < __n2 ? __n1 : __n2; 
N    int __res = traits_type::compare(_C_data+__pos,__s, __rlen);
N
N    if (__res == 0)
N      __res = (__n1 < __n2) ? -1 : (__n1 != __n2);
N
N    return __res;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
