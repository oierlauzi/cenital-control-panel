L 1 "MixerController.cpp"
L 1 "mbed/mbed_config.h" 1
N// Automatically generated configuration file.
N// DO NOT EDIT, content will be overwritten.
N
N#ifndef __MBED_CONFIG_DATA__
N#define __MBED_CONFIG_DATA__
N
N// Configuration parameters
N#define MBED_CONF_PLATFORM_STDIO_BAUD_RATE          9600 // set by library:platform
N#define MBED_CONF_PLATFORM_DEFAULT_SERIAL_BAUD_RATE 9600 // set by library:platform
N#define MBED_CONF_PLATFORM_STDIO_FLUSH_AT_EXIT      1    // set by library:platform
N#define MBED_CONF_PLATFORM_STDIO_CONVERT_NEWLINES   0    // set by library:platform
N
N#endif
L 1 "MixerController.cpp" 2
N#include "MixerController.h"
L 1 "MixerController.h" 1
N#ifndef MIXER_CONTROLLER_H_INCLUDED
N#define MIXER_CONTROLLER_H_INCLUDED
N
N#include <bitset>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\bitset" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * <bitset> - definition of the bitset template
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_BITSET_INCLUDED
N#define _RWSTD_BITSET_INCLUDED
N
N
N#include <iosfwd>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\iosfwd" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * iosfwd - forward declarations for the iostreams
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_IOSFWD_INCLUDED
N#define _RWSTD_IOSFWD_INCLUDED
N
N#include <rw/_defs.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 1
N/***************************************************************************
N *
N * _defs.h - Common macro definitions to be included by every library file
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_DEFS_H_INCLUDED
N#define _RWSTD_DEFS_H_INCLUDED
N
N#include <rw/_config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 1
N/***************************************************************************
N *
N * _config.h - Compiler and C library configuration definitions
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2000 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_CONFIG_H_INCLUDED
N#define _RWSTD_CONFIG_H_INCLUDED
N
N// Always use the auto-generated config file for ARM Compilers
N#include <rw/config.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/config.h" 1
N/* Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved. */
N/* Copyright (c) 2002 ARM Ltd. All Rights Reserved.                        */
N#ifndef __RW_CONFIG_H_INCLUDED
N#define __RW_CONFIG_H_INCLUDED
N
N#define _RWSTD_NO_NATIVE_IO // Rogue Wave global config options
N#define _RWSTD_NO_CONST_FLT_ROUNDS // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_EXCEPTIONS // auto config
N#else
N#endif
N#define _RWSTD_NO_FILENO // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_FUNCTION_TRY_BLOCK // auto config
N#endif
N#define _RWSTD_NO_IEEEFP_H_REQUIRED // auto config
N#define _RWSTD_LLONG_PRINTF_PREFIX "ll"
N#define _RWSTD_NO_LRAND48 // auto config
N#define _RWSTD_NO_MATH_EXCEPTION // auto config
N#define _RWSTD_NO_MBSTATE_COMPARE // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_NEW_THROWS // auto config
N#else
N#endif
N#define _RWSTD_NO_NL_TYPES_H // auto config
N#define _RWSTD_NO_SSIZE_T // auto config
N#ifndef __EXCEPTIONS
N#define _RWSTD_NO_UNCAUGHT_EXCEPTION // auto config
N#else
N#endif
N#define _RWSTD_WINT_T int
N
N#endif /* __RW_CONFIG_H_INCLUDED */
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_config.h" 2
N
N// Library version number
N// 
N#define _RWSTD_VER 0x02020300
N//                    | | | |
N//                   AABBCCDD
N//                    | | | |
N//                    | | | +--- DD = Point release or "patch" release. 
N//                    | | |      Left D-digit is reserved for alpha releases
N//                    | | |      and right D-digit for beta releases
N//                    | | |      
N//                    | | +----- CC = Maintenance number
N//                    | +------- BB = Minor Release number
N//                    +--------- AA = Major Release number
N
N/*********************************************************************
N *                OVERRIDES FOR CONFIGURATION MACROS                 *
N *********************************************************************/
N
N/********************** ARM armcc **************************************/
N
N/* If implicit includes are switched off, include the file.cc explicitly */
N#ifndef __IMPLICIT_INCLUDE
S#  define _RWSTD_COMPILE_INSTANTIATE
N#endif /* __IMPLICIT_INCLUDE */
N#if __TARGET_ARCH_AARCH64
S#  define _RWSTD_NO_LONG_DOUBLE 1
N#endif /* __TARGET_ARCH_AARCH64 */
N
N/********************** EDG eccp *************************************/
N
N// NOTE: the __EDG__ macro is #defined by most edg-based compilers
N
N#if defined (__EDG__) && !defined (__DECCXX)
X#if 1L && !0L
N#  define _RWSTD_NO_DEPRECATED_C_HEADERS
N#  undef _RWSTD_NO_NEW_HEADER
N#  undef _RWSTD_NO_LIBC_IN_STD
N
N#  ifdef _RWSTD_MULTI_THREAD
S     // std::uncaught_exception() not thread-safe
S     // in the vanilla front-end (demo)
S#    define _RWSTD_NO_UNCAUGHT_EXCEPTION
N#  endif   // _RWSTD_MULTI_THREAD
N#endif   // __EDG__
N
N/********************** gcc ******************************************/
N
N/* armcc supports __attribute__ */
N#define _RWSTD_GNUC_ATTRIBUTE(attr)   __attribute__ (attr)
N
N/********************** Threads ***************************************/
N
N#ifdef _RWSTD_DCE_THREADS
S#  define _RWSTD_NO_STATIC_MUTEX_INIT
N#endif   // _RWSTD_DCE_THREADS
N
N/********************** Miscellaneous *********************************/
N
N// g++ cannot inline functions that take a variable number of arguments
N// or functions that contain static (local) variables
N#if !defined (__GNUG__) || __GNUG__ > 2 || __GNUG_MINOR__ > 96
X#if !1L || 4 > 2 || __GNUG_MINOR__ > 96
N#  define _INLINE_VARARGS      inline
N#  if !defined (__HP_aCC) || __HP_aCC > 012100
X#  if !0L || __HP_aCC > 012100
N     // working around a known aCC 1.21 bug
N#    define _INLINE_WITH_STATICS inline
N#  endif   // !__HP_aCC || __HP_aCC > 012100
N#endif   // !__GNUG__ || __GNUG__ > 2 || __GNUG_MINOR__ > 96
N
N#ifdef _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
S   // static mutex initialization depends on the compiler's (and the
S   // linker's in gcc's case) ability to correctly handle explicitly
S   // initialized static members of class templates
S#  ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S#    define _RWSTD_NO_STATIC_MUTEX_INIT
S#  endif
N#endif   // _RWSTD_NO_STATIC_TEMPLATE_MEMBER_INIT
N
N/********************** Environment *********************************/
N
N/*
N * Most (but not all) non-unix systems convert new line to carriage
N * return / line feed on output:
N */
N#if defined (__OS2__) || defined (_WIN32) || defined (_WIN64)
X#if 0L || 0L || 0L
S#  define _RWSTD_CRLF_CONVENTION
N#endif
N
N
N// define wherever atomic instructions are not provided
N// affects the size of string reference (i.e., is binary incompatible)
N#if    !defined (__DECCXX)                           \
N    && !(defined (__i386__) && defined (__GNUG__))   \
N    && !defined (_WIN32) && !defined (_WIN64)
X#if    !0L                               && !(0L && 1L)       && !0L && !0L
N#  ifndef _RWSTD_NO_TEST_AND_SET
N#    define _RWSTD_NO_TEST_AND_SET
N#  endif   // _RWSTD_NO_TEST_AND_SET
N#endif   // !_WIN32 && !(__i386__ && __GNUG__)
N
N
N#ifdef _RWSTD_NO_WCHAR_T
S#  ifndef _RWSTD_NO_NATIVE_WCHAR_T /* may be defined in config.h */
S#    define _RWSTD_NO_NATIVE_WCHAR_T 1
S#  endif
N#endif
N
N
N#ifndef _RWSTD_NO_STL_SPECIALIZATION
N// #ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC
N// disable partial specialization for void* of STL sequences
N#  define _RWSTD_NO_STL_SPECIALIZATION
N// #endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N#endif   // _RWSTD_NO_STL_SPECIALIZATION
N
N// 
N// Macro for path to the ANSI 'C' headers 
N// Must be set specifically for each platform when the
N// C++ wrappers for 'C' headers are used.
N//
N#define _RWSTD_ANSIC(x) </usr/include/x>
N
N// define unless already specified
N#ifndef _RWSTD_LDBL_PRINTF_PREFIX
N#  define _RWSTD_LDBL_PRINTF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_PRINTF_PREFIX
N
N#ifndef _RWSTD_LDBL_SCANF_PREFIX
N#  define _RWSTD_LDBL_SCANF_PREFIX   "L"
N#endif   // _RWSTD_LDBL_SCANF_PREFIX
N
N
N/********************** Library Option Dependencies *************************/
N
N/*
N * The following macro sets the default size of file stream internal buffers
N */
N
N#ifndef _RWSTD_DEFAULT_BUFSIZE         // specified on command line?
N#  define _RWSTD_DEFAULT_BUFSIZE   512
N#endif
N
N#ifndef _RWSTD_NO_LONG_LONG
N   #if defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__) && !defined(__clang__)
X   #if 1L && !0L && !0L
N     /* strict armcc has '__int64' */
N     #define _RWSTD_LONG_LONG __int64
N   #endif
N   /* armclang and non-strict armcc allow 'long long' in system headers */
N   // Win32/64 #defines _RWSTD_LONG_LONG to __int64
N#  ifndef _RWSTD_LONG_LONG
S#    define _RWSTD_LONG_LONG long long
N#  endif   // _RWSTD_LONG_LONG
N#endif   // _RWSTD_NO_LONG_LONG
N
N
N// disable all extensions in strict ANSI mode
N#ifdef _RWSTD_STRICT_ANSI
S#  define _RWSTD_NO_EXT_FILEBUF
S#  define _RWSTD_NO_EXT_VECTOR_BOOL_REF_OPS
S#  define _RWSTD_NO_EXT_LOCALE
S#  define _RWSTD_NO_EXT_DEEP_STRING_COPY
S   // no support for exceptions derived from ios_base::failure
S#  define _RWSTD_NO_EXT_FAILURE
S   // no support for writing out integral values in base 2
S#  define _RWSTD_NO_EXT_BIN_IO
S   // no support for optional mt-locking in iostreams
S#  define _RWSTD_NO_EXT_REENTRANT_IO
S   // allocator<const T> not possible
S#  define _RWSTD_NO_EXT_CONST_ALLOCATOR
S   // no definitions provided for missing operator new or delete
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
S   // void std::count<>() not provided (except when necessary)
S#  define _RWSTD_NO_EXT_VOID_COUNT
S   // void std::distance<>()  not provided
S#  define _RWSTD_NO_EXT_VOID_DISTANCE
N#endif   // _RWSTD_STRICT_ANSI
N
N   // macros that are enabled in library source files
N#ifdef _RWSTD_LIB_SRC
S   // don't instantiate templates in library source code
S   //  (but see _RWSTD_INSTANTIATE_TEMPLATES macro below) 
S#  define _RWSTD_NO_TEMPLATE_DEFINITIONS
S   // don't provide definitions of operator new in library 
S#  define _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _RWSTD_LIB_SRC
N
N#if _MSC_VER <= 1300
N   // msvc60 expects a definition to be provided for all variants
N   // of operator new/delete that are declared. This means that either
N   // the operators must be defined - preventing redefinition in user code -
N   // or that they must be undeclared - preventing them from being called
N   // directly in user code. We have chosen the former option.
N#  undef _RWSTD_NO_EXT_OPERATOR_NEW
N#endif  // _MSC_VER
N
N#ifdef _RWSTD_INSTANTIATE_TEMPLATES
S   // instantiate templates (this macro appears in instance.cpp)
S#  undef _RWSTD_NO_TEMPLATE_DEFINITIONS
N#endif
N
N
N#endif   // _RWSTD_CONFIG_H_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_defs.h" 2
N
N
N// provide definitions for C++ versions of standard C headers
N// if a header is not available its name is #defined to the name of
N// this file (it's harmless and avoids polluting code with
N// tons of ugly platform-specific #ifdefs)
N#ifndef _RWSTD_NO_NEW_HEADER
N
N#  define _RWSTD_CASSERT   <cassert>
N#  define _RWSTD_CCTYPE    <cctype>
N#  define _RWSTD_CERRNO    <cerrno>
N#  define _RWSTD_CFLOAT    <cfloat>
N#  define _RWSTD_CISO646   <ciso646>
N#  define _RWSTD_CLIMITS   <climits>
N#  define _RWSTD_CLOCALE   <clocale>
N#  define _RWSTD_CMATH     <cmath>
N#  define _RWSTD_CSETJMP   <csetjmp>
N#  define _RWSTD_CSIGNAL   <csignal>
N#  define _RWSTD_CSTDARG   <cstdarg>
N#  define _RWSTD_CSTDDEF   <cstddef>
N#  define _RWSTD_CSTDIO    <cstdio>
N#  define _RWSTD_CSTDLIB   <cstdlib>
N#  define _RWSTD_CSTRING   <cstring>
N#  define _RWSTD_CTIME     <ctime>
N
N#  ifndef _RWSTD_NO_WCHAR_H
N#    define _RWSTD_CWCHAR  <cwchar>
N#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCHAR_H
N
N#  ifndef _RWSTD_NO_WCTYPE_H
N#    define _RWSTD_CWCTYPE <cwctype>
N#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
N#  endif   // _RWSTD_NO_WCTYPE_H
N
N#else   // if defined (_RWSTD_NO_NEW_HEADER)
S
S#  define _RWSTD_CASSERT   <assert.h>
S#  define _RWSTD_CCTYPE    <ctype.h>
S#  define _RWSTD_CERRNO    <errno.h>
S#  define _RWSTD_CFLOAT    <float.h>
S#  define _RWSTD_CISO646   <iso646.h>
S#  define _RWSTD_CLIMITS   <limits.h>
S#  define _RWSTD_CLOCALE   <locale.h>
S#  define _RWSTD_CMATH     <math.h>
S#  define _RWSTD_CSETJMP   <setjmp.h>
S#  define _RWSTD_CSIGNAL   <signal.h>
S#  define _RWSTD_CSTDARG   <stdarg.h>
S#  define _RWSTD_CSTDDEF   <stddef.h>
S#  define _RWSTD_CSTDIO    <stdio.h>
S#  define _RWSTD_CSTDLIB   <stdlib.h>
S#  define _RWSTD_CSTRING   <string.h>
S#  define _RWSTD_CTIME     <time.h>
S
S#  ifndef _RWSTD_NO_WCHAR_H
S#    define _RWSTD_CWCHAR  <wchar.h>
S#  else
S#    define _RWSTD_CWCHAR  <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCHAR_H
S
S#  ifndef _RWSTD_NO_WCTYPE_H
S#    define _RWSTD_CWCTYPE <wctype.h>
S#  else
S#    define _RWSTD_CWCTYPE <rw/_defs.h>
S#  endif   // _RWSTD_NO_WCTYPE_H
S
N#endif   // _RWSTD_NO_NEW_HEADER
N
N
N#if defined(_WIN64)
X#if 0L
S#  define _RWSTD_SYS_TYPES_H <basetsd.h>
S#elif defined(_WIN32)
X#elif 0L
S#  define _RWSTD_SYS_TYPES_H <rw/_defs.h>
N#else
N#  define _RWSTD_SYS_TYPES_H <sys/types.h>
N#endif   // _WIN32
N
N
N#ifdef _RWSTD_REQUIRES_IEEEFP
S// non-standard file required on Some platforms (e.g., Siemens) for <limits>
S#  define _RWSTD_IEEEFP <ieeefp.h>
N#else
N#  define _RWSTD_IEEEFP <rw/_defs.h>
N#endif
N
N
N// provide default #definitions of ANSI C library headers
N#if !defined (_RWSTD_NO_ASSERT_H) && !defined (_RWSTD_ANSI_C_ASSERT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ASSERT_H "/usr/include/assert.h"
N#endif
N#if !defined (_RWSTD_NO_CTYPE_H) && !defined (_RWSTD_ANSI_C_CTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_CTYPE_H "/usr/include/ctype.h"
N#endif
N#if !defined (_RWSTD_NO_ERRNO_H) && !defined (_RWSTD_ANSI_C_ERRNO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ERRNO_H "/usr/include/errno.h"
N#endif
N#if !defined (_RWSTD_NO_FLOAT_H) && !defined (_RWSTD_ANSI_C_FLOAT_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_FLOAT_H "/usr/include/float.h"
N#endif
N#if !defined (_RWSTD_NO_ISO646_H) && !defined (_RWSTD_ANSI_C_ISO646_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_ISO646_H "/usr/include/iso646.h"
N#endif
N#if !defined (_RWSTD_NO_LIMITS_H) && !defined (_RWSTD_ANSI_C_LIMITS_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LIMITS_H "/usr/include/limits.h"
N#endif
N#if !defined (_RWSTD_NO_LOCALE_H) && !defined (_RWSTD_ANSI_C_LOCALE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_LOCALE_H "/usr/include/locale.h"
N#endif
N#if !defined (_RWSTD_NO_MATH_H) && !defined (_RWSTD_ANSI_C_MATH_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_MATH_H "/usr/include/math.h"
N#endif
N#if !defined (_RWSTD_NO_SETJMP_H) && !defined (_RWSTD_ANSI_C_SETJMP_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SETJMP_H "/usr/include/setjmp.h"
N#endif
N#if !defined (_RWSTD_NO_SIGNAL_H) && !defined (_RWSTD_ANSI_C_SIGNAL_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_SIGNAL_H "/usr/include/signal.h"
N#endif
N#if !defined (_RWSTD_NO_STDARG_H) && !defined (_RWSTD_ANSI_C_STDARG_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDARG_H "/usr/include/stdarg.h"
N#endif
N#if !defined (_RWSTD_NO_STDDEF_H) && !defined (_RWSTD_ANSI_C_STDDEF_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDDEF_H "/usr/include/stddef.h"
N#endif
N#if !defined (_RWSTD_NO_STDIO_H) && !defined (_RWSTD_ANSI_C_STDIO_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDIO_H "/usr/include/stdio.h"
N#endif
N#if !defined (_RWSTD_NO_STDLIB_H) && !defined (_RWSTD_ANSI_C_STDLIB_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STDLIB_H "/usr/include/stdlib.h"
N#endif
N#if !defined (_RWSTD_NO_STRING_H) && !defined (_RWSTD_ANSI_C_STRING_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_STRING_H "/usr/include/string.h"
N#endif
N#if !defined (_RWSTD_NO_TIME_H) && !defined (_RWSTD_ANSI_C_TIME_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_TIME_H "/usr/include/time.h"
N#endif
N#if !defined (_RWSTD_NO_WCHAR_H) && !defined (_RWSTD_ANSI_C_WCHAR_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCHAR_H "/usr/include/wchar.h"
N#endif
N#if !defined (_RWSTD_NO_WCTYPE_H) && !defined (_RWSTD_ANSI_C_WCTYPE_H)
X#if !0L && !0L
N#  define _RWSTD_ANSI_C_WCTYPE_H "/usr/include/wctype.h"
N#endif
N
N
N// Macro for determining the number of bits in a word.
N// Used by vector<bool>.
N//
N#define _RWSTD_WORD_BIT (int(CHAR_BIT*sizeof(unsigned int)))
N
N
N//
N// These macros tune the speed vs. space optimization of container
N// performance with regard to allocation of memory. These have been tuned
N// with speed efficiency as a primary conern. Space efficiency was
N// considered, but was secondary. (refer to Onyx QA Entry #4920)
N//
N// The ratio parameter must be above one for an amortized constant time
N// algorithm.  Lowering the ratio will lower rapidity and improve space
N// efficiency. This effect will be most noticable when working with
N// containers of few elements (few being less than 32 for the general case)
N// If your use case is with containers that typically have many elements
N// lowering the ratio will have less effect on rapidity.
N//
N// The minimum elements parameter refers to minimum amount of additional
N// capcity requested (in number of elements) when more memory is needed.
N// Rapidity with containers of few elements will be affected most noticably
N// as this amount this is lowered.
N//
N// For strings, the specializations on char and wchar_t were seen as an
N// exploitable common case, and have their own more specialized template
N// function overloads in the string header.  These are tweakable here
N// with the STRING version of these macros.
N//
N#if !defined(_RWSTD_MINIMUM_NEW_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_NEW_CAPACITY _RWSTD_C::size_t (32)
N#endif
N#if !defined(_RWSTD_NEW_CAPACITY_RATIO)
X#if !0L
N   // using long doubles to eliminate bogus warnings on g++ 2.95.2/sparc
N   // (-W -O2/3 only): warning: overflow on truncation to integer
N   //#  define _RWSTD_NEW_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_CAPACITY(x) ((x) + ((x) >> 1) + ((x) >> 3)) // 'x * 1.625'
N#endif
N#if !defined(_RWSTD_MINIMUM_STRING_CAPACITY)
X#if !0L
N#  define _RWSTD_MINIMUM_STRING_CAPACITY _RWSTD_C::size_t (128)
N#endif
N#if !defined(_RWSTD_STRING_CAPACITY_RATIO)
X#if !0L
N   //#  define _RWSTD_STRING_CAPACITY_RATIO 1.618L
N#  define _RWSTD_INCREASE_STRING_CAPACITY(x) _RWSTD_INCREASE_CAPACITY(x)
N#endif
N
N
N// set up Win32/64 DLL export/import directives
N// _DLL - defined by the compiler when either -MD or -MDd is used
N// RWDLL - defined for all Rogue Wave products to be built as shared libs
N// _RWSHARED - defined for stdlib to be built/used as a shared lib
N#if    (defined (_WIN32) || defined (_WIN64)) \
N    && (defined (RWDLL) || defined (_RWSHARED))
X#if    (0L || 0L)     && (0L || 0L)
S#  ifdef _RWBUILD_std
S     // building a shared lib, export names
S#    define _RWSTD_EXPORT   __declspec (dllexport)
S#  else
S     // using a shared lib, import names
S#    define _RWSTD_EXPORT   __declspec (dllimport)
S#  endif
S
S   // disable warnings:
S   // C4251: class needs to have dll-interface to be used by cliens
S   // C4275: non dll-interface class used as base for dll-interface class
S#  pragma warning (disable: 4251)
S#  pragma warning (disable: 4275)
N#else
N// disable Windows hacks
N#  define _RWSTD_EXPORT
N#endif
N
N
N// The member variable string::npos is required to be static to allow its
N// use in constant expressions.  For compilers that do not support static
N// intialization an enumeration is used.  This workaround is not available
N// on LLP64 architectures however, where enums are 32 bit.  In this case it
N// we don't have a workaround to support the use of npos in constant
N// expressions, the macro _RWSTD_NPOS must be used instead
N#if defined(_RWSTD_LLP64_ARCHITECTURE) && defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if 0L && 0L
S#  define _RWSTD_NPOS _RWSTD_C::size_t(-1)
N#else
N#  define _RWSTD_NPOS string::npos
N#endif
N
N
N/*
N** Miscellaneous workarounds.
N*/
N
N#ifdef _RWSTD_NO_BOOL
S#  ifdef _RWSTD_MSVC_BOOL_WARNING
S#    pragma warning ( disable : 4237 )
S#  endif
S
S   typedef int     bool;
S
S#  ifndef true
S#    define true    1
S#  endif
S
S#  ifndef false
S#    define false   0
S#  endif
N#endif // _RWSTD_NO_BOOL
N
N
N#ifndef _RWSTD_NO_TYPENAME
N#  define _TYPENAME typename
N#else
S#  define _TYPENAME
N#endif
N
N#if defined (SNI) || defined (__SUNPRO_CC) && __SUNPRO_CC <= 0x520
X#if 0L || 0L && __SUNPRO_CC <= 0x520
S#  define _TYPENAME_CTOR
N#else
N#  define _TYPENAME_CTOR _TYPENAME
N#endif
N
N#ifndef _RWSTD_NO_EXPLICIT
N#  define _EXPLICIT explicit
N#else
S#  define _EXPLICIT
N#endif
N
N
N#ifndef _RWSTD_NO_MUTABLE
N#  define _MUTABLE mutable
N#else
S#  define _MUTABLE
N#endif
N
N
N//
N// Macro for forming or omitting default template arguments in constructors
N//
N
N#ifndef _RWSTD_NO_DEFAULT_TEMPLATE_ARGS
N#  define _RWSTD_DEFAULT_ARG(n) = n
N#else
S#  define _RWSTD_DEFAULT_ARG(n)
N#endif
N
N
N// MSVC version 12.00.xxxx (and perhaps prior) can't parse template
N// re-declarations if the previous declaration contains two or more
N// default template parameters (go figure)
N#if defined (_MSC_VER) && _MSC_VER <= 1300
X#if 0L && _MSC_VER <= 1300
S#  define _RWSTD_REDECLARED_DEFAULT(arg)   = arg
N#else   // if !(!defined (_MSC_VER) || (_MSC_VER <= 1300))
N#  define _RWSTD_REDECLARED_DEFAULT(ignore)
N#endif   // !defined (_MSC_VER) || (_MSC_VER <= 1300)
N
N
N//
N// Macro for forming or ommitting default template parameters.
N//
N#ifndef _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N#  define _RWSTD_SIMPLE_DEFAULT(a)  = a
N#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N#    define _RWSTD_COMPLEX_DEFAULT(a)  = a
N#  else
S#    define _RWSTD_COMPLEX_DEFAULT(a)
N#  endif
N#else   // if defined (_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES)
S#  ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
S#  endif
S#  define _RWSTD_SIMPLE_DEFAULT(a)
S#  define _RWSTD_COMPLEX_DEFAULT(a)
S#  ifndef _RWSTD_NO_DEFAULT_TEMPLATES
S#    define _RWSTD_NO_DEFAULT_TEMPLATES
S#  endif
N#endif   // _RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES
N
N
N// Macro for casting, using either the "old" method
N// or the new C++ cast system
N#ifdef _RWSTD_NO_STATIC_CAST
S#  define _RWSTD_STATIC_CAST(x, y)      ((x)y)
S#  define _RWSTD_REINTERPRET_CAST(x, y) ((x)y)
S#  define _RWSTD_CONST_CAST(x, y)       ((x)y)
N#else
N#  define _RWSTD_STATIC_CAST(x, y)      static_cast< x >(y)
N#  define _RWSTD_REINTERPRET_CAST(x, y) reinterpret_cast< x >(y)
N#  define _RWSTD_CONST_CAST(x, y)       const_cast< x >(y)
N#endif   // _RWSTD_NO_STATIC_CAST
N
N//
N// Macros for the new template specialization syntax
N//
N
N#ifdef _RWSTD_NO_NEW_FUNC_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_FUNCTION
N#else
N#  define _RWSTD_SPECIALIZED_FUNCTION template<>
N#endif
N
N#ifdef _RWSTD_NO_NEW_CLASS_TEMPLATE_SYNTAX
S#  define _RWSTD_SPECIALIZED_CLASS
N#else
N#  define _RWSTD_SPECIALIZED_CLASS template<>
N#endif
N
N// for compilers or environments that do not support namespaces
N#ifndef _RWSTD_NO_NAMESPACE
N#  define _RWSTD_NAMESPACE_BEGIN(name)    namespace name {
N#  define _RWSTD_NAMESPACE_END            }
N
N#  define _USING(name)                    using name
N
N#  ifdef _MSC_VER
S#    define _STD                       ::std
S#    define _STD_RW                    ::std
S#    define _RW                        ::__rw
N#  else
N#    define _STD                       std
N#    define _STD_RW                    std
N#    define _RW                        __rw
N#  endif
N
N#else   // if defined (_RWSTD_NO_NAMESPACE)
S#  define _RWSTD_NAMESPACE_BEGIN(ignore)
S#  define _RWSTD_NAMESPACE_END
S
S#  define _USING(ignore)              typedef void __rw_unused_typedef
S
S#  define _STD
S#  define _STD_RW
S#  define _RW
N#endif   // _RWSTD_NO_NAMESPACE
N
N//
N// for compilers that don't like specialized friends
N// such as operator== in template classes
N//
N#ifdef _RWSTD_NO_SPECIALIZED_FRIEND
S#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
S#  else   // if !defined (__TURBOC__)
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   name
S#  endif   // __TURBOC__
N#else   // if defined (_RWSTD_NO_SPECIALIZED_FRIEND)
N#  ifdef __TURBOC__
S#    define _RWSTD_SPECIALIZED_FRIEND(name)   (_STD_RW::name)
N#  else   // if !defined (__TURBOC__)
N     // the space between `name' and `<>' is necessary
N     // to prevent ..._FRIEND (operator<) from expanding into operator<<>
N     // (only the GNU preprocessor inserts a space)
N#    define _RWSTD_SPECIALIZED_FRIEND(name)   name <>
N#  endif  // __TURBOC__
N#endif   // _RWSTD_NO_SPECIALIZED_FRIEND
N
N
N//
N// If compiler supports member and default templates then it support
N// the _RWSTD_ALLLOCATOR
N//
N#if    !defined(_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined(_RWSTD_NO_SIMPLE_DEFAULT_TEMPLATES) \
N    && !defined(_RWSTD_NO_MEM_CLASS_TEMPLATES)
X#if    !0L     && !0L     && !0L
N#  define _RWSTD_ALLOCATOR
N#endif
N
N
N#define _RWSTD_MB_CUR_MAX 16  //???  Need to find absolute maximum for this
N
N
N// helper macros for token pasting
N#define _RWSTD_DO_PASTE(a, b)   a ## b
N#define _RWSTD_PASTE(a, b)      _RWSTD_DO_PASTE (a, b)
N
N#ifdef _RWSTD_MULTI_THREAD
S// synchronizes access by all objects holding the same mutex
S#  define _RWSTD_MT_GUARD(mutex)  \
S          _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
X#  define _RWSTD_MT_GUARD(mutex)            _RW::__rw_guard _RWSTD_PASTE (__guard, __LINE__) (mutex)
S
S// synchronizes access by all threads
S#  define _RWSTD_MT_STATIC_GUARD(name)        \
S          static _RW::__rw_mutex name; \
S          _RWSTD_MT_GUARD (name)
X#  define _RWSTD_MT_STATIC_GUARD(name)                  static _RW::__rw_mutex name;           _RWSTD_MT_GUARD (name)
S
S// synchronizes access by all objects of the same type
S#  define _RWSTD_MT_CLASS_GUARD(name, type) \
S          _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
X#  define _RWSTD_MT_CLASS_GUARD(name, type)           _RWSTD_MT_GUARD (_RW::__rw_get_static_mutex ((type*)0))
S
S#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex) \
S          _RW::__rw_atomic_preincrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREINCREMENT(x, mutex)           _RW::__rw_atomic_preincrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex) \
S          _RW::__rw_atomic_predecrement (x, mutex)
X#  define _RWSTD_ATOMIC_PREDECREMENT(x, mutex)           _RW::__rw_atomic_predecrement (x, mutex)
S
S#  define _RWSTD_ATOMIC_SWAP(x, y, mutex) \
S          _RW::__rw_atomic_exchange  (x, y, mutex)
X#  define _RWSTD_ATOMIC_SWAP(x, y, mutex)           _RW::__rw_atomic_exchange  (x, y, mutex)
S
S#  ifndef _RWSTD_NO_EXT_REENTRANT_IO
S// conditional swap used in iostreams
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            ((this->flags () & _RWSTD_IOS_NOLOCK) ?      \
S                _RW::__rw_ordinary_exchange  (x, y)      \
S             :  _RW::__rw_atomic_exchange  (x, y, mutex))
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       ((this->flags () & _RWSTD_IOS_NOLOCK) ?                      _RW::__rw_ordinary_exchange  (x, y)                   :  _RW::__rw_atomic_exchange  (x, y, mutex))
S
S#  else
S#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)           \
S            _RWSTD_ATOMIC_SWAP(x, y, mutex)
X#    define _RWSTD_ATOMIC_IO_SWAP(x, y, mutex)                       _RWSTD_ATOMIC_SWAP(x, y, mutex)
S#  endif    // _RWSTD_NO_EXT_REENTRANT_IO
S
N#else   // if !defined _RWSTD_MULTI_THREAD
N
N#  define _RWSTD_MT_GUARD(ignore)                   ((void)0)
N#  define _RWSTD_MT_STATIC_GUARD(name)              _RWSTD_MT_GUARD (name)
N#  define _RWSTD_MT_CLASS_GUARD(name, ignore)       _RWSTD_MT_GUARD (name)
N
N#  define _RWSTD_ATOMIC_PREINCREMENT(x, ignore)     ++(x)
N#  define _RWSTD_ATOMIC_PREDECREMENT(x, ignore)     --(x)
N#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)  \
N          _RW::__rw_atomic_exchange ((x), (y), false)
X#  define _RWSTD_ATOMIC_SWAP(x, y, ignore)            _RW::__rw_atomic_exchange ((x), (y), false)
N
N#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)  \
N          _RW::__rw_ordinary_exchange ((x), (y))
X#  define _RWSTD_ATOMIC_IO_SWAP(x, y, ignore)            _RW::__rw_ordinary_exchange ((x), (y))
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N// macro for qualifying C library names in the std namespace
N#ifndef _RWSTD_NO_LIBC_IN_STD
N# define _RWSTD_C std
N#else
S# define _RWSTD_C
N#endif
N
N#define _RWSTD_INVALID_FILE_DESC -1
N#define _RWSTD_INVALID_FILE_PTR   0
N
N#ifndef _RWSTD_NO_NATIVE_IO
S# define _RWSTD_INVALID_FILE     -1
S# define _RWSTD_INVALID_OPENMODE -1
N#else
N# define _RWSTD_INVALID_FILE      (FILE*)0
N# define _RWSTD_INVALID_OPENMODE  0
N#endif // _RWSTD_NO_NATIVE_IO
N
N
N// std::ios_base static const data members' values
N#define _RWSTD_IOS_BOOLALPHA    0x00001
N#define _RWSTD_IOS_DEC          0x00002
N#define _RWSTD_IOS_FIXED        0x00004
N#define _RWSTD_IOS_HEX          0x00008
N#define _RWSTD_IOS_INTERNAL     0x00010
N#define _RWSTD_IOS_LEFT         0x00020
N#define _RWSTD_IOS_OCT          0x00040
N#define _RWSTD_IOS_RIGHT        0x00080
N#define _RWSTD_IOS_SCIENTIFIC   0x00100
N#define _RWSTD_IOS_SHOWBASE     0x00200
N#define _RWSTD_IOS_SHOWPOINT    0x00400
N#define _RWSTD_IOS_SHOWPOS      0x00800
N#define _RWSTD_IOS_SKIPWS       0x01000
N#define _RWSTD_IOS_UNITBUF      0x02000
N#define _RWSTD_IOS_UPPERCASE    0x04000
N#define _RWSTD_IOS_BIN          0x08000
N// NOLOCK[BUF] used rather than LOCK[BUF] to maintain functional compatibility
N// with release 2.2 (which was always safe when these bits were cleared)
N#define _RWSTD_IOS_NOLOCK       0x10000
N#define _RWSTD_IOS_NOLOCKBUF    0x20000
N
N#define _RWSTD_IOS_FLOATFIELD   _RWSTD_IOS_FIXED | _RWSTD_IOS_SCIENTIFIC
N
N#define _RWSTD_IOS_ADJUSTFIELD    \
N        (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
X#define _RWSTD_IOS_ADJUSTFIELD            (_RWSTD_IOS_LEFT | _RWSTD_IOS_RIGHT | _RWSTD_IOS_INTERNAL)
N
N#ifndef _RWSTD_NO_EXT_BIN_IO
N#  define _RWSTD_IOS_BASEFIELD    \
N          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT | _RWSTD_IOS_BIN)
N#else
S#  define _RWSTD_IOS_BASEFIELD    \
S          (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
X#  define _RWSTD_IOS_BASEFIELD              (_RWSTD_IOS_DEC | _RWSTD_IOS_HEX | _RWSTD_IOS_OCT)
N#endif   // _RWSTD_NO_EXT_BIN_IO
N
N
N#define _RWSTD_IOS_GOODBIT       0x00
N#define _RWSTD_IOS_BADBIT        0x01
N#define _RWSTD_IOS_EOFBIT        0x02
N#define _RWSTD_IOS_FAILBIT       0x04
N
N#define _RWSTD_IOS_APP           0x01
N#define _RWSTD_IOS_BINARY        0x02
N#define _RWSTD_IOS_IN            0x04
N#define _RWSTD_IOS_OUT           0x08
N#define _RWSTD_IOS_TRUNC         0x10
N#define _RWSTD_IOS_ATE           0x20
N
N#ifndef _RWSTD_STRICT_ANSI
N#  define _RWSTD_IOS_NOCREATE    0x40
N#  define _RWSTD_IOS_NOREPLACE   0x80
N#else
S#  define _RWSTD_IOS_NOCREATE    0
S#  define _RWSTD_IOS_NOREPLACE   0
N#endif
N
N#define _RWSTD_IOS_MASK                         \
N        (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY   \
N         | _RWSTD_IOS_IN | _RWSTD_IOS_OUT       \
N         | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE    \
N         | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
X#define _RWSTD_IOS_MASK                                 (  _RWSTD_IOS_APP | _RWSTD_IOS_BINARY            | _RWSTD_IOS_IN | _RWSTD_IOS_OUT                | _RWSTD_IOS_TRUNC | _RWSTD_IOS_ATE             | _RWSTD_IOS_NOCREATE | _RWSTD_IOS_NOREPLACE)
N
N
N#if    !defined (_RWSTD_NO_STATIC_IOSTREAM_INIT)  \
N    && !defined (_RWSTD_NO_IOSTREAM_OBJECT_REFS)
X#if    !0L      && !0L
N   // standard iostream objects are references
N#  define _RWSTD_IOSTREAM_OBJECT(name)   &name
N#else
S   // standard iostream objects are declared to be real objects
S   // they may be implemented as real objects of the same type
S   // that get destroyed during program lifetime or as objects
S   // of some POD type that do not get destroyed at all
S#  define _RWSTD_IOSTREAM_OBJECT(name)   name
N#endif   //  _RWSTD_NO_STATIC_IOSTREAM_INIT && !_RWSTD_NO_IOSTREAM_OBJECT_REFS
N
N
N// exceptions can be completely disabled (bodies of catch blocks are still
N// compiled but will be removed by the optimizing stage of the compiler)
N// this approach reveals any errors even if _RWSTD_NO_EXCEPTIONS is #defined
N#ifndef _RWSTD_NO_EXCEPTIONS
S#  define _TRY           try
S#  define _CATCH(ex)     catch (ex)
S#  define _CATCH_T(ex)   catch (ex)
S#  define _THROW(ex)     throw ex
S#  define _RETHROW       throw
N#else   // if defined (_RWSTD_NO_EXCEPTIONS)
N#  define _TRY
N#  define _CATCH(ignore)   while (0)
N#  define _CATCH_T(type)   for (type; 0;) 
N#  define _THROW(ignore)   ((void)0)
N#  define _RETHROW         ((void)0)
N#endif   // _RWSTD_NO_EXCEPTIONS
N
N
N// for compilers that can't handle standard allocators we provide four
N// workarounds: _RWSTD_REBIND, used in place of _Allocator::rebind, allows
N// containers to use the same allocator for different data types
N// _RWSTD_ALLOC_TYPE is required to "rebind", or rather wrap,  the user
N// supplied non-conforming allocator in allocator_interface so that the
N// container need not be aware of the allocator's special properties (namely
N// the fact that the allocator allocates in terms of bytes rather than
N// elemements)
N//
N// _RWSTD_VALUE_ALLOC creates a temporary allocator_interface wrapper
N// from the given parameter (usually *this) when allocating values in
N// the sequence containers with non-conforming allocators.
N// _RWSTD_VALUE_ALLOC_CAST casts the given container to a reference to
N// a value allocator, allowing access to inherited allocator members
N// outside of the class.  For non-conforming compilers, this macro is
N// equivalent to _RWSTD_VALUE_ALLOC.
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `to' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifdef _RWSTD_ALLOCATOR
N#  define _RWSTD_REBIND(from, to) \
N          _TYPENAME from::template rebind < to >::other
X#  define _RWSTD_REBIND(from, to)           _TYPENAME from::template rebind < to >::other
N#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   _Allocator
N#  define _RWSTD_VALUE_ALLOC(ignore, call)            allocator_type::call
N#  define _RWSTD_VALUE_ALLOC_CAST(rvalue) \
N          _RWSTD_STATIC_CAST (allocator_type&, rvalue)
X#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)           _RWSTD_STATIC_CAST (allocator_type&, rvalue)
N#else   // if !defined (_RWSTD_ALLOCATOR)
S#  define _RWSTD_REBIND(from, to) \
S          _STD_RW::allocator_interface < from, to >
X#  define _RWSTD_REBIND(from, to)           _STD_RW::allocator_interface < from, to >
S#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)   \
S          _RWSTD_REBIND (_Allocator, _ValueType)
X#  define _RWSTD_ALLOC_TYPE(_Allocator, _ValueType)             _RWSTD_REBIND (_Allocator, _ValueType)
S#  define _RWSTD_VALUE_ALLOC(type, call)      type(*this).call
S#  define _RWSTD_VALUE_ALLOC_CAST(rvalue)     _C_value_alloc_type(rvalue)
N#endif   // _RWSTD_ALLOCATOR
N
N
N// for compilers that can't deal with template functions parametrized
N// on the function's return type (as opposed to function arguments)
N//
N// NOTE: the spaces around type below are necessary to prevent errors
N//       if `type' is a template-id and the preprocessor doesn't put
N//       the spaces there automatically (GNU does, Sun does not)
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N#  define _STD_USE_FACET(type, arg)    _STD::use_facet < type >(arg)
N#  define _USE_FACET(type, arg)        use_facet < type >(arg)
N#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer < type >(size)
N#else   // if defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
S#  define _STD_USE_FACET(type, arg)    _STD::use_facet (arg, (type*)(0))
S#  define _USE_FACET(type, arg)        use_facet (arg, (type*)(0))
S#  define _GET_TEMP_BUFFER(type, size) get_temporary_buffer (size, (type*)0)
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N#ifndef _RWSTD_NO_NONCLASS_ARROW_RETURN
N   // expected signature: "_TypeT* operator->()"
N   // and/or:             "const _TypeT* operator->() const"
N#  define _RWSTD_OPERATOR_ARROW(signature) signature { return &**this; }
N#else
S#  define _RWSTD_OPERATOR_ARROW(ignore)
N#endif   // _RWSTD_NO_NONCLASS_ARROW_RETURN
N
N
N// to prevent warnings about unused arguments
N#define _RWSTD_UNUSED(arg)   ((void)&arg)
N
N
N// allows all externs to be declared/defined only in headers
N// and defined just by first #defining _RWSTD_DEFINE_EXTERNS
N// and then #including the header in a .cpp file
N#ifndef _RWSTD_DEFINE_EXTERNS
N#  define _RWSTD_EXTERN(decl, ignore)   extern decl
N#else
S#  define _RWSTD_EXTERN(decl, value)    extern decl = value
N#endif   // _RWSTD_DEFINE_EXTERNS
N
N
N// allows static const integral or enum class members to be initialized
N// inside the class and defined (w/o being initialized) outside
N// of the class (as required by 9.4.2, p4)
N#if !defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if !0L
N#  define _RWSTD_STATIC_CONST(type, init)    static const type init
N#  define _RWSTD_DEFINE_STATIC_CONST(decl)   decl
N#else
S#  define _RWSTD_STATIC_CONST(ignore, init)  enum { init }
S#  define _RWSTD_DEFINE_STATIC_CONST(ignore)
N#endif   // _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N
N
N// Selection of vendor dependent "format" string argument to wcsftime()
N#ifndef _RWSTD_NO_WCSFTIME
N   // 7.24.5.1 of C99 - wcsftime()'s 3rd arg is const wchar* [restrict]
N   //                   HP-UX 11 (and perhaps others) still uses const char*
N#  ifndef _RWSTD_NO_WCSFTIME_WCHAR_T_FMAT
N#     define _RWSTD_FMT_TYPE(arg)  const wchar_t* arg
N#     define _RWSTD_FMT_ASSGN(str) L##str
N#  else
S#     define _RWSTD_FMT_TYPE(arg)  const char* arg
S#     define _RWSTD_FMT_ASSGN(str) str
N#  endif
N#else   // if defined (_RWSTD_NO_WCSFTIME)
S#  define _RWSTD_FMT_TYPE(arg)     const char* arg
S#  define _RWSTD_FMT_ASSGN(str)    str
N#endif // _RWSTD_NO_WCSFTIME
N
N
N// _Iterator typedefs
N// (note that you must use a semi-colon at the end of this macro)
N#define _RWSTD_ITERATOR_TYPES(_Iterator)                               \
N     typedef _TYPENAME _Iterator::difference_type difference_type;     \
N     typedef _TYPENAME _Iterator::value_type value_type;               \
N     typedef _TYPENAME _Iterator::pointer pointer;                     \
N     typedef _TYPENAME _Iterator::reference reference;                 \
N     typedef _TYPENAME _Iterator::iterator_category iterator_category
X#define _RWSTD_ITERATOR_TYPES(_Iterator)                                    typedef _TYPENAME _Iterator::difference_type difference_type;          typedef _TYPENAME _Iterator::value_type value_type;                    typedef _TYPENAME _Iterator::pointer pointer;                          typedef _TYPENAME _Iterator::reference reference;                      typedef _TYPENAME _Iterator::iterator_category iterator_category
N
N// helpers making working w/o iterator_traits transparent
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_VALUE_TYPE(iterT) \
N       (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
X#  define _RWSTD_VALUE_TYPE(iterT)        (_TYPENAME _STD::iterator_traits< iterT >::value_type*)0
N#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
N       (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          (_TYPENAME _STD::iterator_traits< iterT >::difference_type*)0
N#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore) \
N       _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
X#  define _RWSTD_ITERATOR_CATEGORY(iterT, ignore)        _TYPENAME_CTOR _STD::iterator_traits< iterT >::iterator_category ()
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S#  define _RWSTD_VALUE_TYPE(iterT) __value_type ((iterT*)0)
S   // assume default ctor is defined and accessible
S#  define _RWSTD_DIFFERENCE_TYPE(iterT)   \
S       _STD::__distance_type (iterT ())
X#  define _RWSTD_DIFFERENCE_TYPE(iterT)          _STD::__distance_type (iterT ())
S   // macro cannot use the default ctor to construct a temporary
S   // with the type of the first argument since the default ctor
S   // may not exist or be accessible (e.g., istream_iterator<>)
S#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter) \
S       _STD::__iterator_category (iter)
X#  define _RWSTD_ITERATOR_CATEGORY(ignore, iter)        _STD::__iterator_category (iter)
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// Use -D_RWSTDDEBUG to compile a version of the libraries to debug
N// the user's code.  This will perform pre- and post-condition checks
N// upon entering routines, but will be larger and run more slowly.
N// This option affects the binary compatibility of generated code.
N
N
N#if defined(RWDEBUG) && !defined(_RWSTDDEBUG)
X#if 0L && !0L
S#  define _RWSTDDEBUG 1
N#endif
N
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_ASSERT(expr)                                                \
S     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__, \
S                                                __PRETTY_FUNCTION__))
X#  define _RWSTD_ASSERT(expr)                                                     ((expr) ? (void)0 : _RW::__rw_assert_fail (#expr, __MODULE__, __LINE__,                                                 __PRETTY_FUNCTION__))
N#else   //  if !defined (_RWSTDDEBUG)
N#  define _RWSTD_ASSERT(ignore)         ((void)0)
N#endif   // _RWSTDDEBUG
N
N// compile-time assertion - asserts constant expressions during
N// compilation with no runtime overhead; failed assertions are reported
N// as compilation errors
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
Ntemplate <bool __b>
Nstruct __rw_compile_assert;
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_compile_assert<true> { enum { _C_ok }; };
N
N#define _RWSTD_COMPILE_ASSERT(const_expr) \
N        ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
X#define _RWSTD_COMPILE_ASSERT(const_expr)         ((void)_RW::__rw_compile_assert<(const_expr)>::_C_ok)
N
N// called for failed assertions
Nvoid _RWSTD_EXPORT
Xvoid 
N__rw_assert_fail (const char *__expr,
N                       const char *__file, int __line, const char *__func);
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N#  define _RWSTD_STR(x)       #x
N#  define _RWSTD_STRSTR(x)    _RWSTD_STR(x)
N
N#if defined(_RWSTDDEBUG) && _RWSTDDEBUG
X#if 0L && _RWSTDDEBUG
S#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, __PRETTY_FUNCTION__
S#  define _RWSTD_FILE_LINE   __MODULE__ ":" _RWSTD_STRSTR (__LINE__)
N#else
N#  define _RWSTD_FUNC(ignore) _RWSTD_FILE_LINE, ""
N#  define _RWSTD_FILE_LINE   ""
N#endif
N
N/* at least some of the _RWSTD_REQUIRES are needed for conformance */
N#  define _RWSTD_REQUIRES(pred, args)   (pred) ? (void)0 : _RW::__rw_throw args
N
N// function exception specification
N#if    !defined (_RWSTD_NO_EXCEPTIONS) \
N    && !defined (_RWSTD_NO_EXCEPTION_SPECIFICATION)
X#if    !1L     && !0L
S   // type_id_list is a possibly empty parenthesized list
S   //of comma-separated type-id's
S#  define _THROWS(type_id_list)   throw type_id_list
N#else   // if _RWSTD_NO_EXCEPTIONS || _RWSTD_NO_EXCEPTION_SPECIFICATION
N#  define _THROWS(ignore)
N#endif   // !_RWSTD_NO_EXCEPTIONS && !_RWSTD_NO_EXCEPTION_SPECIFICATION
N
N
N// for convenience
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N#  define _DISTANCE(first, last, ignore) _STD_RW::distance (first, last)
N#else
S#  define _DISTANCE(first, last, type) _RW::__rw_distance (first, last, type())
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// pointers to the incomplete types declared below are used
N// to disambiguate calls to template member functions
N// bodies provided only to work around an HP aCC 3.14.10 bug
Ntemplate <bool __b>
Nstruct __rw_select { };
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct __rw_select<true> { };
N
N#define _RWSTD_DISPATCH_INT(yes) const _RW::__rw_select < yes >*
N#define _RWSTD_DISPATCH(iter) \
N        ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
X#define _RWSTD_DISPATCH(iter)         ((_RW::__rw_select<numeric_limits< iter >::is_integer>*)0)
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#if defined (__IBMCPP__) && __IBMCPP <= 500
X#if 0L && __IBMCPP <= 500
S
S// working around an xlC 5.0 bug
S_USING (__rw::__rw_select);
S
N#endif
N
N
N// select appropriate C multibyte conversion function based on
N// whether "restartable" functions are available.
N
N
N#ifndef _RWSTD_NO_MBRTOWC
N   // reentrant versions return size_t - see 7.24.6.3.2 of C99
N#  define _RWSTD_MBTOWC(to, from, size, state) mbrtowc (to, from, size, state)
N#elif !defined (_RWSTD_NO_MBTOWC)
X#elif !0L
S   // non-reentrant versions return int - see 7.20.7.2 of C99
S#  define _RWSTD_MBTOWC(to, from, size, ignore_state) \
S          _RWSTD_C::size_t (mbtowc(to, from, size))
X#  define _RWSTD_MBTOWC(to, from, size, ignore_state)           _RWSTD_C::size_t (mbtowc(to, from, size))
S#else
S   // mbtowc not supported
S#  define _RWSTD_MBTOWC(ign1, ign2, ign3, ign4) _RWSTD_C::size_t (-1)
N#endif   // _RWSTD_NO_MBRTOWC
N
N#ifndef _RWSTD_NO_WCRTOMB
N#  define _RWSTD_WCTOMB(to, from, state)       wcrtomb (to, from, state)
N#else   // if defined (_RWSTD_NO_WCRTOMB)
S#  define _RWSTD_WCTOMB(to, from, ignore_state) \
S          _RWSTD_C::size_t (wctomb (to, from))
X#  define _RWSTD_WCTOMB(to, from, ignore_state)           _RWSTD_C::size_t (wctomb (to, from))
N#endif   // _RWSTD_NO_WCRTOMB
N
N
N// unsafe when underlying libc doesn't support mbsinit
N// as described in 7.24.6.3.1 of C99
N#ifndef _RWSTD_NO_MBSINIT
N# if defined(SNI) && defined(_RWSTD_STRICT_ANSI)
X# if 0L && 0L
S#  define _MBSINIT(ps)   __SNI::mbsinit (ps)
N# else
N#  define _MBSINIT(ps)   mbsinit (ps)
N# endif
N#else   // if defined (_RWSTD_NO_MBSINIT)
S#  define _MBSINIT(ps)   (0 == (ps))
N#endif   // _RWSTD_NO_MBSINIT
N
N
N// enable only in debug mode and only id partial class specialization
N// is supported; prevent multiple definition of _RWSTD_NO_DEBUG_ITER
N#if    defined(_RWSTDDEBUG) && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_DEBUG_ITER) && !defined (SNI)
X#if    0L && !0L     && !0L && !0L
S#  define _RWSTD_ASSERT_RANGE(first, last) \
S      _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
X#  define _RWSTD_ASSERT_RANGE(first, last)       _RWSTD_ASSERT (_RW::__rw_valid_range (first, last))
S#  define _RWSTD_ASSERT_IN_RANGE(it, first, last) \
S      _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
X#  define _RWSTD_ASSERT_IN_RANGE(it, first, last)       _RWSTD_ASSERT (_RW::__rw_in_range (it, first, last))
S#  define _RWSTD_ASSERT_DEREF(it) \
S      _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
X#  define _RWSTD_ASSERT_DEREF(it)       _RWSTD_ASSERT (_RW::__rw_dereferenceable (it))
N#else
N#  ifndef _RWSTD_NO_DEBUG_ITER
N#    define  _RWSTD_NO_DEBUG_ITER
N#  endif   // _RWSTD_NO_DEBUG_ITER
N
N#  define _RWSTD_ASSERT_RANGE(ign1, ign2)          ((void)0)
N#  define _RWSTD_ASSERT_IN_RANGE(ign1, ign2, ign3) ((void)0)
N#  define _RWSTD_ASSERT_DEREF(ignore)              ((void)0)
N#endif   // _RWSTDDEBUG && !_RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// convenience macro to get the "real" iterator embedded in __rw_debug_iter<>
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  define _ITER_BASE(it)   ((it).base ())
N#else   // if defined (_RWSTD_NO_DEBUG_ITER)
N#  define _ITER_BASE(it)   (it)
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N// will use the deduced native type rather than the typedef to prevent
N// conflicts caused by inconsistent definition of wint_t (gcc 2.95.2/AIX)
N#ifndef _RWSTD_WINT_T
S   // hardcode if wint_t is not available in <wchar.h>
S   // used by std::traits and std::basic_[i|o]stream
S#  define _RWSTD_WINT_T int
N#endif   // _RWSTD_WINT_T
N
N
N// used by std::traits and std::basic_[i|o]stream,
N// required to be int by 21.1.3.1, p2
N#define _RWSTD_INT_T int
N
N
N// ssize_t is defined by POSIX.1
N#ifndef _RWSTD_SSIZE_T
N#  ifdef _WIN64
S#    define _RWSTD_SSIZE_T SSIZE_T
N#  else
N#    define _RWSTD_SSIZE_T long
N#  endif
N#endif
N
N
N#if defined(SNI)
X#if 0L
S#  define _RWSTD_USING_SNI(name) _USING(__SNI::name)
S#  if defined(_RWSTD_STRICT_ANSI)
S#    define fileno(p)       (int) ((p)->_file)
S#  endif
N#else
N#  define _RWSTD_USING_SNI(ignore)    typedef void __rw_unused_typedef
N#endif
N
N
N#ifndef _RWSTD_TMPBUF_SIZE
N#  define _RWSTD_TMPBUF_SIZE 4096
N#endif
N
N#ifndef _RWSTD_NO_STRTOLL
N#  define _STRTOLL           strtoll
N#else
S   // libc has no strtoll, use strtol instead
S#  define _STRTOLL           (_RWSTD_LONG_LONG)strtol
N#endif   // _RWSTD_NO_STRTOLL
N
N
N#ifndef _RWSTD_NO_STRTOULL
N#  define _STRTOULL          strtoull
N#else
S   // libc has no strtoull, use strtoul instead
S#  define _STRTOULL          (unsigned _RWSTD_LONG_LONG)strtoul
N#endif   // _RWSTD_NO_STRTOULL
N
N
N#if     defined (_RWSTD_INSTANTIATE_TEMPLATES)       \
N    && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N    && !defined (_RWSTD_NO_INSTANTIATE)
X#if     0L           && !0L       && !0L
S#  define _RWSTD_INSTANTIATE_1(arg)          template arg
S#  define _RWSTD_INSTANTIATE_2(a1, a2)       template a1, a2
S#  define _RWSTD_INSTANTIATE_3(a1, a2, a3)   template a1, a2, a3
N#else
N#  if    defined (_MSC_VER)                          \
N      && !defined (_RWSTD_NO_EXPLICIT_INSTANTIATION) \
N      && !defined (_RWSTD_NO_INSTANTIATE)
X#  if    0L                                && !0L       && !0L
S     // disable warning C4231: nonstandard extension used :
S     //         'extern' before template explicit instantiation
S#    pragma warning (disable: 4231)
S#    define _RWSTD_INSTANTIATE_1(arg)        extern template arg
S#    define _RWSTD_INSTANTIATE_2(a1, a2)     extern template a1, a2
S#    define _RWSTD_INSTANTIATE_3(a1, a2, a3) extern template a1, a2, a3
N#  else
N#    define _RWSTD_INSTANTIATE_1(ignore)           \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_1(ignore)                       typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_2(ign1, ign2)       \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_2(ign1, ign2)                   typedef void __rw_unused_typedef
N#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3) \
N            typedef void __rw_unused_typedef
X#    define _RWSTD_INSTANTIATE_3(ign1, ign2, ign3)             typedef void __rw_unused_typedef
N#  endif
N#endif   // _RWSTD_INSTANTIATE_TEMPLATES
N
N
N#ifndef _RWSTD_NO_UNCAUGHT_EXCEPTION
S#  define _UNCAUGHT_EXCEPTION()   uncaught_exception()
N#else   // if defined (_RWSTD_NO_UNCAUGHT_EXCEPTION)
N#  define _UNCAUGHT_EXCEPTION()   true
N#endif   // _RWSTD_NO_UNCAUGHT_EXCEPTION
N
N// allows for efficient compilation without implicit inclusion; only
N// specializations explicitly instantiated in the library are available
N#if     defined _RWSTD_COMPILE_INSTANTIATE               \
N    && (   !defined (_RWSTD_NO_TEMPLATE_DEFINITIONS)     \
N        ||  defined (_RWSTD_NO_EXPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_IMPLICIT_INSTANTIATION)   \
N        ||  defined (_RWSTD_NO_INSTANTIATE))
X#if     0L                   && (   !0L             ||  0L           ||  0L           ||  0L)
S#  define _RWSTD_DEFINE_TEMPLATE(name)     !(_RWSTD_NO_ ## name ## _DEFINITION)
N#else
N#  define _RWSTD_DEFINE_TEMPLATE(ignore)   0
N#endif
N
N
N// introduce namespace std so that "using namespace std;" always works
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#ifndef _RWSTD_NO_NAMESPACE
N#ifdef __EDG_IMPLICIT_USING_STD 
S/* Implicitly include a using directive for the STD namespace when this */ 
S/* preprocessing flag is TRUE. */ 
Susing namespace ::std; 
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */ 
N#endif /* _RWSTD_NO_NAMESPACE */
N
N#endif   // _RWSTD_DEFS_H_INCLUDED
N
L 36 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\iosfwd" 2
N
N
N#ifndef _RWSTD_NO_MBSTATE_T
N
N#  if defined (__GNUG__) && __GNUG__ < 3 &&__GNUC_MINOR__ < 96
X#  if 1L && 4 < 3 &&7 < 96
S     // <cstring> included to work around a g++ 2.95.2 bug
S#    include _RWSTD_CSTRING
N#  endif
N
N   // get mbstate_t (and wchar_t for MSVC 6.0)
N#  include _RWSTD_CWCHAR   
X#  include <cwchar>   
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cwchar" 1
N/*
N * C++ header for C header wchar.h
N * Copyright 2002 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cwchar
N#define __cwchar
N#define __ARMCLIB_VERSION 5060037
N
N  #define __WCHAR_NO_EXPORTS 1
N  #include <wchar.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\wchar.h" 1
N/* wchar.h: C99 header */
N/* Copyright 2002 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __wchar_h
N#define __wchar_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __WCHAR_DECLS
N  #define __WCHAR_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
N        #define __CLIBNS ::std::
N        namespace std {
N        extern "C" {
N    #else /* ndef __cplusplus */
S      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N    #if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X    #if 1L || !0L || !0L
N     /* always defined in C++ and non-strict C for consistency of debug info */
N      #if __sizeof_ptr == 8
X      #if 4 == 8
S        typedef unsigned long size_t;   /* see <stddef.h> */
N      #else
N        typedef unsigned int size_t;   /* see <stddef.h> */
N      #endif
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !1L && 0L
S        #define __size_t 1
N      #endif
N    #endif
N
N    #ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S      #if !defined(__STRICT_ANSI__) || !defined(__wchar_t)
S       /* always defined in non-strict C for consistency of debug info */
S        #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S          typedef unsigned int wchar_t; /* see <stddef.h> */
S        #else
S          typedef unsigned short wchar_t; /* see <stddef.h> */
S        #endif
S        #ifdef __STRICT_ANSI__
S          #define __wchar_t 1
S        #endif
S      #endif
N    #endif
N
N    #if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__wint_t)
X    #if 1L || !0L || !0L
N     /* always defined in C++ and non-strict C for consistency of debug info */
N      typedef int wint_t;   /* see also <wctype.h> */
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !1L && 0L
S        #define __wint_t 1
N      #endif
N    #endif
N
N        /* limits of wchar_t */
N        /* NB we have to undef and redef because they're defined in both
N         * stdint.h and wchar.h */
N    #undef WCHAR_MIN
N    #undef WCHAR_MAX
N
N    #if defined(__WCHAR32)  || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L  || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      #define WCHAR_MIN   0
S      #define WCHAR_MAX   0xffffffffU
N    #else
N      #define WCHAR_MIN   0
N      #define WCHAR_MAX   65535
N    #endif
N
N    #undef NULL
N    #define NULL 0                   /* see <stddef.h> */
N
N    /* ANSI forbids va_list to be defined here */
N    /* keep in step with <stdarg.h> and <stdio.h> */
N    #if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X    #if !0L && (1L || !0L || !0L)
N    /* always defined in C++ and non-strict C for consistency of debug info */
N      #ifdef __clang__
S        typedef __builtin_va_list __va_list;
N      #else
N        typedef struct __va_list __va_list;
N      #endif
N      #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X      #if !1L && 0L
S        #define __va_list_defined 1
N      #endif
N    #endif
N
N  #ifndef __ARM_WCHAR_NO_IO
N    #undef WEOF
N    #define WEOF ((__CLIBNS wint_t)-1)
N
N    /* ANSI forbids FILE to be defined here */
N    #if !defined(__STRICT_ANSI__)
X    #if !0L
N    /* always defined in non-strict C/C++ for consistency of debug info */
N      typedef struct __FILE FILE;
N    #else
S      struct __FILE;
N    #endif
N  #endif /* __ARM_WCHAR_NO_IO */
N
N    /*
N     * If the compiler supports signalling nans as per N965 then it
N     * will define __SUPPORT_SNAN__, in which case a user may define
N     * _WANT_SNAN in order to obtain compliant versions of the
N     * fwprintf, fwscanf, and wcstod families of functions.
N     */
N    #if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X    #if 0L && 0L
S    #pragma import(__use_snan)
N    #endif
N
N
N    /*
N     * mbstate_t must be able to contain all the data from an
N     * incomplete MB character, plus shift states. CJK-specific
N     * encodings seem to tend to have at most three bytes per
N     * character, and a single-figure number of shift states, so 32
N     * bits is sufficient for any of these. UTF-8 encoding a full
N     * 32-bit value is the hardest thing to deal with, and in that
N     * situation the worst case is having to store 25 bits of
N     * character (1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx) plus
N     * a few bits saying what sort of state is being stored. This is
N     * still easy enough to fit into 32 bits, so I think a single
N     * 32-bit integer is enough in here.
N     */
N    typedef struct __mbstate_t {
N        unsigned int __state, __state2;
N    } mbstate_t;
N
N    /*
N     * `struct tm' must be declared in this header as an incomplete
N     * type.
N     */
N    struct tm;
N            
N    extern _ARMABI size_t wcsftime(wchar_t * __restrict /*s*/, size_t /*maxsize*/,
X    extern __declspec(__nothrow) size_t wcsftime(wchar_t * __restrict  , size_t  ,
N                       const wchar_t * __restrict /*format*/, const struct tm * __restrict /*timeptr*/) __attribute__((__nonnull__(1,3,4)));
N
N  #ifndef __ARM_WCHAR_NO_IO
N    /*
N     * Formatted wide-character I/O functions
N     */
N#pragma __printf_args
N    int swprintf(wchar_t * __restrict /*s*/, size_t /*n*/,
N                 const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N#pragma __printf_args
N    int vswprintf(wchar_t * __restrict /*s*/, size_t /*n*/,
N                  const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#pragma __scanf_args
N    int swscanf(const wchar_t * __restrict /*s*/,
N                const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int vswscanf(const wchar_t * __restrict /*s*/,
N                 const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N
N
N#pragma __printf_args
N    int fwprintf(struct __FILE * __restrict /*stream*/,
N                 const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __printf_args
N    int vfwprintf(struct __FILE * __restrict /*stream*/,
N                  const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int fwscanf(struct __FILE * __restrict /*stream*/,
N                const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N#pragma __scanf_args
N    int vfwscanf(struct __FILE * __restrict /*stream*/,
N                 const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N
N
N#pragma __printf_args
N    int wprintf(const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
N#pragma __printf_args
N    int vwprintf(const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
N#pragma __scanf_args
N    int wscanf(const wchar_t * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
N#pragma __scanf_args
N    int vwscanf(const wchar_t * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
N
N    /* 
N     * Unformatted wide-character I/O functions
N     */
N    wint_t fgetwc(struct __FILE * /*stream*/) __attribute__((__nonnull__(1)));
N    wchar_t *fgetws(wchar_t * __restrict /*s*/, int /*n*/, struct __FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N    wint_t fputwc(wchar_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N    int fputws(const wchar_t * __restrict /*s*/, struct __FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
N    int fwide(struct __FILE * /*stream*/, int /*mode*/) __attribute__((__nonnull__(1)));
N    wint_t getwc(struct __FILE * /*stream*/) __attribute__((__nonnull__(1)));
N    wint_t getwchar(void);
N    wint_t putwc(wchar_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N    wint_t putwchar(wchar_t /*c*/);
N    wint_t ungetwc(wint_t /*c*/, struct __FILE * /*stream*/) __attribute__((__nonnull__(2)));
N  #endif /* __ARM_WCHAR_NO_IO */
N
N    wint_t btowc(int /*c*/);
N    wint_t wctob(int /*c*/);
N    int mbsinit(const mbstate_t * /*ps*/);
N    size_t mbrlen(const char * __restrict /*s*/, size_t /*n*/,
N                  mbstate_t * __restrict /*ps*/);
N    size_t mbrtowc(wchar_t * __restrict /*pwc*/,
N                   const char * __restrict /*s*/,
N                   size_t /*n*/, mbstate_t * __restrict /*ps*/);
N    size_t wcrtomb(char * __restrict /*s*/, wchar_t /*wc*/,
N                   mbstate_t * __restrict /*ps*/);
N    size_t mbsrtowcs(wchar_t * __restrict /*dst*/,
N                     const char ** __restrict /*src*/,
N                     size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t wcsrtombs(char * __restrict /*dst*/,
N                     const wchar_t ** __restrict /*src*/,
N                     size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t _mbsnrtowcs(wchar_t * __restrict /*dst*/,
N                       const char ** __restrict /*src*/,
N                       size_t /*nmb*/,
N                       size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t _wcsnrtombs(char * __restrict /*dst*/,
N                       const wchar_t ** __restrict /*src*/,
N                       size_t /*nwc*/,
N                       size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N#if !defined(__STRICT_ANSI__)
X#if !0L
N    size_t mbsnrtowcs(wchar_t * __restrict /*dst*/,
N                      const char ** __restrict /*src*/,
N                      size_t /*nmb*/,
N                      size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N    size_t wcsnrtombs(char * __restrict /*dst*/,
N                      const wchar_t ** __restrict /*src*/,
N                      size_t /*nwc*/,
N                      size_t /*len*/, mbstate_t * __restrict /*ps*/) __attribute__((__nonnull__(2)));
N#endif
N
N    /*
N     * Wide-character string-to-number conversions. Parallel to strto*.
N     */
N    double wcstod(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    float wcstof(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    long double wcstold(const wchar_t * /*nptr*/, wchar_t ** /*endptr*/) __attribute__((__nonnull__(1)));
N    long int wcstol(const wchar_t * /*nptr*/, wchar_t **/*endptr*/,
N                    int /*base*/) __attribute__((__nonnull__(1)));
N    unsigned long int wcstoul(const wchar_t * /*nptr*/,
N                              wchar_t ** /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N    long long int wcstoll(const wchar_t * __restrict /*nptr*/,
N                          wchar_t ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N    unsigned long long int wcstoull(const wchar_t * __restrict /*nptr*/,
N                                    wchar_t ** __restrict /*endptr*/,
N                                    int /*base*/) __attribute__((__nonnull__(1)));
N#endif
N
N    /*
N     * General wide-character string utilities.
N     */
N    wchar_t *wcscpy(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcsncpy(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wmemcpy(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wmemmove(wchar_t * __restrict /*s1*/,
N                      const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcscat(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcsncat(wchar_t * __restrict /*s1*/,
N                     const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscmp(const wchar_t * __restrict /*s1*/,
N               const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    int wcsncmp(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscasecmp(const wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    int wcsncasecmp(const wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    int wcscoll(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    size_t wcsxfrm(wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N    int wmemcmp(const wchar_t * __restrict /*s1*/,
N                const wchar_t * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N    size_t wcscspn(const wchar_t * __restrict /*s1*/,
N                   const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    size_t wcsspn(const wchar_t * __restrict /*s1*/,
N                  const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    wchar_t *wcstok(wchar_t * __restrict /*s1*/,
N                    const wchar_t * __restrict /*s2*/,
N                    wchar_t ** __restrict /*ptr*/) __attribute__((__nonnull__(2,3)));
N    size_t wcslen(const wchar_t * __restrict /*s*/) __attribute__((__nonnull__(1)));
N    wchar_t *wmemset(wchar_t * __restrict /*s*/, wchar_t /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 1L && !0L
N    /*
N     * C++'s overloading allows us to provide versions of these
N     * functions which search a const string and return a const
N     * pointer into it, and separate versions which search a
N     * non-const string and return a non-const pointer.
N     */
N    const wchar_t *wcschr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
N    const wchar_t *wcspbrk(const wchar_t * __restrict /*s1*/,
N                           const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    const wchar_t *wcsrchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
N    const wchar_t *wcsstr(const wchar_t * __restrict /*s1*/,
N                          const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
N    const wchar_t *wmemchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/,
N                           size_t /*n*/) __attribute__((__nonnull__(1)));
N#ifndef __WCHAR_DISABLED
N    extern "C++" wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
N    extern "C++" inline wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c)
N      { return const_cast<wchar_t *>(wcschr(const_cast<const wchar_t *>(__s), __c)); }
N    extern "C++" wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
N    extern "C++" inline wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2)
N      { return const_cast<wchar_t *>(wcspbrk(const_cast<const wchar_t *>(__s1), __s2)); }
N    extern "C++" wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
N    extern "C++" inline wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c)
N      { return const_cast<wchar_t *>(wcsrchr(const_cast<const wchar_t *>(__s), __c)); }
N    extern "C++" wchar_t *wcsstr(wchar_t * __restrict __s1,
N                          const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
N    extern "C++" inline wchar_t *wcsstr(wchar_t * __restrict __s1,
N                          const wchar_t * __restrict __s2)
N      { return const_cast<wchar_t *>(wcsstr(const_cast<const wchar_t *>(__s1), __s2)); }
N    extern "C++" wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
N                                  size_t __n) __attribute__((__nonnull__(1)));
N    extern "C++" inline wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
N                                  size_t __n)
N    { return const_cast<wchar_t *>(wmemchr(const_cast<const wchar_t *>(__s), __c, __n)); }
N#endif
N#else
S    /*
S     * C's approximation to the above is to have all of these
S     * functions search a const string and return a non-const
S     * pointer. This is the only way to prevent compile errors in
S     * all sensible uses of the functions, but unfortunately
S     * renders them unable to spot a lot of the possible error
S     * cases.
S     */
S#if defined(__cplusplus) && defined(__ARMCOMPILER_LIBCXX)
S  }  /* extern "C" */
S  }  /* namespace std */
S  extern "C" {
S#endif
S    wchar_t *wcschr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
S    wchar_t *wcspbrk(const wchar_t * __restrict /*s1*/,
S                     const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S    wchar_t *wcsrchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/) __attribute__((__nonnull__(1)));
S    wchar_t *wcsstr(const wchar_t * __restrict /*s1*/,
S                    const wchar_t * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
S    wchar_t *wmemchr(const wchar_t * __restrict /*s*/, wchar_t /*c*/,
S                     __CLIBNS size_t /*n*/) __attribute__((__nonnull__(1)));
S#if defined(__cplusplus) && defined(__ARMCOMPILER_LIBCXX)
S  }  /* extern "C" */
S  namespace std {
S  extern "C" {
S#endif
N#endif
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __WCHAR_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
N    #ifndef __WCHAR_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::wint_t;
S      using ::std::mbstate_t;
S      using ::std::tm;
S      using ::std::wcsftime;
S    #ifndef __ARM_WCHAR_NO_IO
S      using ::std::swprintf;
S      using ::std::vswprintf;
S      using ::std::swscanf;
S      using ::std::vswscanf;
S      using ::std::fwprintf;
S      using ::std::vfwprintf;
S      using ::std::fwscanf;
S      using ::std::vfwscanf;
S      using ::std::wprintf;
S      using ::std::vwprintf;
S      using ::std::wscanf;
S      using ::std::vwscanf;
S      using ::std::fgetwc;
S      using ::std::fgetws;
S      using ::std::fputwc;
S      using ::std::fputws;
S      using ::std::fwide;
S      using ::std::getwc;
S      using ::std::getwchar;
S      using ::std::putwc;
S      using ::std::putwchar;
S      using ::std::ungetwc;
S      using ::std::btowc;
S    #endif /* __ARM_WCHAR_NO_IO */
S      using ::std::wctob;
S      using ::std::mbsinit;
S      using ::std::mbrlen;
S      using ::std::mbrtowc;
S      using ::std::wcrtomb;
S      using ::std::mbsrtowcs;
S      using ::std::wcsrtombs;
S      using ::std::_mbsnrtowcs;
S      using ::std::_wcsnrtombs;
S#if !defined(__STRICT_ANSI__)
S      using ::std::mbsnrtowcs;
S      using ::std::wcsnrtombs;
S#endif
S      using ::std::wcstod;
S      using ::std::wcstof;
S      using ::std::wcstold;
S      using ::std::wcstol;
S      using ::std::wcstoul;
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::wcstoll;
S      using ::std::wcstoull;
S#endif /* !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus) */
S      using ::std::wcscpy;
S      using ::std::wcsncpy;
S      using ::std::wmemcpy;
S      using ::std::wmemmove;
S      using ::std::wcscat;
S      using ::std::wcsncat;
S      using ::std::wcscmp;
S      using ::std::wcsncmp;
S      using ::std::wcscasecmp;
S      using ::std::wcsncasecmp;
S      using ::std::wcscoll;
S      using ::std::wcsxfrm;
S      using ::std::wmemcmp;
S#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
S      using ::std::wcschr;
S      using ::std::wcspbrk;
S      using ::std::wcsrchr;
S      using ::std::wcsstr;
S      using ::std::wmemchr;
S#endif /* defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX) */
S      using ::std::wcscspn;
S      using ::std::wcsspn;
S      using ::std::wcstok;
S      using ::std::wcslen;
S      using ::std::wmemset;
S#if !defined(__STRICT_ANSI__) && !defined(__ARM_WCHAR_NO_IO)
S      using ::std::FILE;
S#endif
N    #endif /* __WCHAR_NO_EXPORTS */
N  #endif /* __cplusplus */
N#endif /* ndef __wchar_h */
N
N/* end of wchar.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cwchar" 2
N  #undef __WCHAR_NO_EXPORTS
N
N  #undef __wchar_h  // later inclusion of wchar.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cwchar */
N
L 47 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\iosfwd" 2
N
N#  if defined (_RWSTD_NO_LIBC_IN_STD)
X#  if 0L
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
S// bring global mbstate_t into namespace std if it's not there yet
S_USING (::mbstate_t);
S
S_RWSTD_NAMESPACE_END   // std
S
N#  endif   // _RWSTD_NO_LIBC_IN_STD
N
N#else   // if defined (_RWSTD_NO_MBSTATE_T)
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
Sstruct mbstate_t
S{ 
S    mbstate_t () 
S        : _C_state (0) { }
S    
S    mbstate_t (const mbstate_t & __rhs) 
S        : _C_state(__rhs._C_state) { }
S    
S    mbstate_t& operator= (const mbstate_t &__rhs) {
S        if (&__rhs != this)
S            _C_state = __rhs._C_state;              
S        return *this;
S    }
S
S    bool operator== (const mbstate_t &__rhs) const {
S        return _C_state == __rhs._C_state;
S    }
S
S    bool operator!= (const mbstate_t &__rhs) const {
S        return !(*this == __rhs);
S    }
S                   
S    long _C_state;                
S};
S
S_RWSTD_NAMESPACE_END   // std
S
N#endif // _RWSTD_NO_MBSTATE_T 
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _TypeT>
Nclass allocator;
N
Ntemplate<class _CharT>
Nstruct char_traits;
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct char_traits<char>;
N
N#ifndef _RWSTD_NO_WCHAR_T
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nstruct char_traits<wchar_t>;
N
N#endif   // _RWSTD_NO_WCHAR_T
N
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ios;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_streambuf;
N
N// 27.2, p4
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_istream;
N
N// 27.2, p5
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ostream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>) > 
X         class _Allocator = allocator<_CharT> > 
Nclass basic_stringbuf;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>)  > 
X         class _Allocator = allocator<_CharT>  > 
Nclass basic_istringstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>) > 
X         class _Allocator = allocator<_CharT> > 
Nclass basic_ostringstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_filebuf;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ifstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_ofstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) > 
X         class _Traits = char_traits<_CharT> > 
Nclass ostreambuf_iterator;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) > 
X         class _Traits = char_traits<_CharT> > 
Nclass istreambuf_iterator;
N
N// 27.2, p6
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_iostream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>) >
X         class _Traits = char_traits<_CharT> >
Nclass basic_fstream;
N
Ntemplate<class _CharT,
N         class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>),
X         class _Traits = char_traits<_CharT>,
N         class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>)  > 
X         class _Allocator = allocator<_CharT>  > 
Nclass basic_stringstream;
N
N
N#ifndef _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N
Ntypedef basic_ios<char>                                    ios;
Ntypedef basic_streambuf<char>                              streambuf;
Ntypedef basic_istream<char>                                istream;
Ntypedef basic_ostream<char>                                ostream;
Ntypedef basic_stringbuf<char>                              stringbuf;
Ntypedef basic_istringstream<char>                          istringstream;
Ntypedef basic_ostringstream<char>                          ostringstream;
Ntypedef basic_filebuf<char>                                filebuf;
Ntypedef basic_ifstream<char>                               ifstream;
Ntypedef basic_ofstream<char>                               ofstream;
Ntypedef basic_fstream<char>                                fstream;
Ntypedef basic_iostream<char>                               iostream;
Ntypedef basic_stringstream<char>                           stringstream;
N
N#ifndef _RWSTD_NO_WCHAR_T
N
Ntypedef basic_ios<wchar_t>                                 wios;
Ntypedef basic_streambuf<wchar_t>                           wstreambuf;
Ntypedef basic_istream<wchar_t>                             wistream;
Ntypedef basic_ostream<wchar_t>                             wostream;
Ntypedef basic_stringbuf<wchar_t>                           wstringbuf;
Ntypedef basic_istringstream<wchar_t>                       wistringstream;
Ntypedef basic_ostringstream<wchar_t>                       wostringstream;
Ntypedef basic_filebuf<wchar_t>                             wfilebuf;
Ntypedef basic_ifstream<wchar_t>                            wifstream;
Ntypedef basic_ofstream<wchar_t>                            wofstream;
Ntypedef basic_fstream<wchar_t>                             wfstream;
Ntypedef basic_iostream<wchar_t>                            wiostream;
Ntypedef basic_stringstream<wchar_t>                        wstringstream;
N
N#endif // _RWSTD_NO_WCHAR_T
N
N#else
S
Stypedef basic_ios<char, char_traits<char> >                ios;
Stypedef basic_streambuf<char, char_traits<char> >          streambuf;
Stypedef basic_istream<char, char_traits<char> >            istream;
Stypedef basic_ostream<char, char_traits<char> >            ostream;
Stypedef basic_stringbuf<char, char_traits<char>, allocator<char> >
S        stringbuf;
Stypedef basic_istringstream<char, char_traits<char>, allocator<char> >
S        istringstream;
Stypedef basic_ostringstream<char, char_traits<char>, allocator<char> >
S        ostringstream;
Stypedef basic_filebuf<char, char_traits<char> >            filebuf;
Stypedef basic_ifstream<char, char_traits<char> >           ifstream;
Stypedef basic_ofstream<char, char_traits<char> >           ofstream;
Stypedef basic_fstream<char, char_traits<char> >            fstream;
Stypedef basic_iostream<char, char_traits<char> >           iostream;
Stypedef basic_stringstream<char, char_traits<char>, allocator<char> >
S        stringstream;
S
S#ifndef _RWSTD_NO_WCHAR_T
S
Stypedef basic_ios<wchar_t, char_traits<wchar_t> >          wios;
Stypedef basic_streambuf<wchar_t, char_traits<wchar_t> >    wstreambuf;
Stypedef basic_istream<wchar_t, char_traits<wchar_t> >      wistream;
Stypedef basic_ostream<wchar_t, char_traits<wchar_t> >      wostream;
Stypedef basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
S        wstringbuf;
Stypedef basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
S        wistringstream;
Stypedef basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
S        wostringstream;
Stypedef basic_filebuf<wchar_t, char_traits<wchar_t> >      wfilebuf;
Stypedef basic_ifstream<wchar_t, char_traits<wchar_t> >     wifstream;
Stypedef basic_ofstream<wchar_t, char_traits<wchar_t> >     wofstream;
Stypedef basic_fstream<wchar_t,char_traits<wchar_t> >       wfstream;
Stypedef basic_iostream<wchar_t, char_traits<wchar_t> >     wiostream;
Stypedef basic_stringstream<wchar_t,char_traits<wchar_t>, allocator<wchar_t> >
S        wstringstream;
S
S#endif // _RWSTD_NO_WCHAR_T
N#endif // _RWSTD_NO_COMPLEX_DEFAULT_TEMPLATES
N
N
N// 27.2, p8
Ntemplate <class _StateT>
Nclass fpos;
N
N// 27.2, p9 - identical to std::fpos<char_traits<char>::state_type>
N//            and std::fpos<char_traits<wchar_t>::state_type>, respectively
Ntypedef fpos<mbstate_t>                                    streampos;
Ntypedef fpos<mbstate_t>                                    wstreampos;
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_IOSFWD_INCLUDED
N
L 37 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\bitset" 2
N#include <string>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * <string> - definition of the C++ Standard Library basic_string template
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_STRING_INCLUDED
N#define _RWSTD_STRING_INCLUDED
N
N#include <iosfwd>
N#include <limits>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * limits - Declarations for the C++ Standard Library class numeric_limits
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_LIMITS_INCLUDED
N#define _RWSTD_LIMITS_INCLUDED
N
N#include <rw/_defs.h>
N#include <rw/_math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_math.h" 1
N/***************************************************************************
N *
N * _math.h - Standard Library vs math.h exception conflict hack.
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_MATH_H_INCLUDED
N#define _RWSTD_MATH_H_INCLUDED
N
N#include <rw/_defs.h>
N
N// avoid a conflicting exception structure on platforms where
N// struct exception is defined unguarded in <math.h>
N#ifndef _RWSTD_NO_MATH_EXCEPTION
S#  undef exception
S#  define exception math_exception
N#endif   // _RWSTD_NO_MATH_EXCEPTION
N
N#include _RWSTD_CMATH
X#include <cmath>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cmath" 1
N/*
N * C++ header for C header math.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cmath
N#define __cmath
N#define __ARMCLIB_VERSION 5060037
N
N  #define __MATH_NO_EXPORTS 1
N  #include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF inline
N#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 1L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
S#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
N      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xinline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
N      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
N      namespace std {
N#       define __CLIBNS ::std::
N        extern "C" {
N#   else
S#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 0L
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 1L && ((!0L || 0L) || 0L)
N  extern "C++" {
N    inline int (fpclassify)(double __x) { return fpclassify(__x); }
X    inline int (fpclassify)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_fpclassifyf(__x) : __ARM_fpclassify(__x)); }
N    inline bool (isfinite)(double __x) { return isfinite(__x); }
X    inline bool (isfinite)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isfinitef(__x) : __ARM_isfinite(__x)); }
N    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
X    inline bool (isgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x20000000)); }
N    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
X    inline bool (isgreaterequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x30000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0x30000000) == 0x20000000)); }
N    inline bool (isinf)(double __x) { return isinf(__x); }
X    inline bool (isinf)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isinff(__x) : __ARM_isinf(__x)); }
N    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
X    inline bool (isless)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x80000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x80000000)); }
N    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
X    inline bool (islessequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xc0000000) != 0) : ((__ARM_dcmp4((__x), (__y)) & 0xc0000000) != 0)); }
N    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
X    inline bool (islessgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? __ARM_islessgreaterf((__x), (__y)) : __ARM_islessgreater((__x), (__y))); }
N    inline bool (isnan)(double __x) { return isnan(__x); }
X    inline bool (isnan)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnanf(__x) : __ARM_isnan(__x)); }
N    inline bool (isnormal)(double __x) { return isnormal(__x); }
X    inline bool (isnormal)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnormalf(__x) : __ARM_isnormal(__x)); }
N    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
X    inline bool (isunordered)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x10000000) == 0x10000000) : ((__ARM_dcmp4((__x), (__y)) & 0x10000000) == 0x10000000)); }
N
N  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 1L && !0L
N  extern "C++" {
N    inline float abs(float __x)   { return fabsf(__x); }
N    inline float acos(float __x)  { return acosf(__x); }
N    inline float asin(float __x)  { return asinf(__x); }
N    inline float atan(float __x)  { return atanf(__x); }
N    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
N    inline float ceil(float __x)  { return ceilf(__x); }
N    inline float cos(float __x)   { return cosf(__x); }
N    inline float cosh(float __x)  { return coshf(__x); }
N    inline float exp(float __x)   { return expf(__x); }
N    inline float fabs(float __x)  { return fabsf(__x); }
N    inline float floor(float __x) { return floorf(__x); }
N    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
N    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
N    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
N    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
N    inline float log(float __x)   { return logf(__x); }
N    inline float log10(float __x) { return log10f(__x); }
N    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
N    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
N    inline float pow(float __x, float __y)      { return powf(__x,__y); }
N    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
N    inline float sin(float __x)   { return sinf(__x); }
N    inline float sinh(float __x)  { return sinhf(__x); }
N    inline float sqrt(float __x)  { return sqrtf(__x); }
N    inline float _sqrt(float __x) { return _sqrtf(__x); }
N    inline float tan(float __x)   { return tanf(__x); }
N    inline float tanh(float __x)  { return tanhf(__x); }
N
N    inline double abs(double __x) { return fabs(__x); }
N    inline double pow(double __x, int __y)
N                { return pow(__x, (double) __y); }
N
N#ifdef __HAVE_LONGDOUBLE
N    inline long double abs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double acos(long double __x)
N                { return (long double)acosl(__x); }
N    inline long double asin(long double __x)
N                { return (long double)asinl(__x); }
N    inline long double atan(long double __x)
N                { return (long double)atanl(__x); }
N    inline long double atan2(long double __y, long double __x)
N                { return (long double)atan2l(__y, __x); }
N    inline long double ceil(long double __x)
N                { return (long double)ceill( __x); }
N    inline long double cos(long double __x)
N                { return (long double)cosl(__x); }
N    inline long double cosh(long double __x)
N                { return (long double)coshl(__x); }
N    inline long double exp(long double __x)
N                { return (long double)expl(__x); }
N    inline long double fabs(long double __x)
N                { return (long double)fabsl(__x); }
N    inline long double floor(long double __x)
N                { return (long double)floorl(__x); }
N    inline long double fmod(long double __x, long double __y)
N                { return (long double)fmodl(__x, __y); }
N    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
N    inline long double frexp(long double __x, int* __p)
N                { return (long double)frexpl(__x, __p); }
N    inline long double ldexp(long double __x, int __exp)
N                { return (long double)ldexpl(__x, __exp); }
N    inline long double log(long double __x)
N                { return (long double)logl(__x); }
N    inline long double log10(long double __x)
N                { return (long double)log10l(__x); }
N    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
N    inline long double modf(long double __x, long double* __p)
N                { return (long double)modfl(__x, __p); }
N    inline long double pow(long double __x, long double __y)
N                { return (long double)powl(__x, __y); }
N    inline long double pow(long double __x, int __y)
N                { return (long double)powl(__x, __y); }
N    inline long double sin(long double __x)
N                { return (long double)sinl(__x); }
N    inline long double sinh(long double __x)
N                { return (long double)sinhl(__x); }
N    inline long double sqrt(long double __x)
N                { return (long double)sqrtl(__x); }
N    inline long double _sqrt(long double __x)
N                { return (long double)_sqrt((double) __x); }
N    inline long double tan(long double __x)
N                { return (long double)tanl(__x); }
N    inline long double tanh(long double __x)
N                { return (long double)tanhl(__x); }
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N    inline float acosh(float __x) { return acoshf(__x); }
N    inline float asinh(float __x) { return asinhf(__x); }
N    inline float atanh(float __x) { return atanhf(__x); }
N    inline float cbrt(float __x) { return cbrtf(__x); }
N    inline float erf(float __x) { return erff(__x); }
N    inline float erfc(float __x) { return erfcf(__x); }
N    inline float expm1(float __x) { return expm1f(__x); }
N    inline float log1p(float __x) { return log1pf(__x); }
N    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
N    inline float lgamma(float __x) { return lgammaf(__x); }
N    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
N    inline float rint(float __x) { return rintf(__x); }
N#endif
N
N#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
N#endif
N
N  }
N#endif
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 1L && !1L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cmath" 2
N  #undef __MATH_NO_EXPORTS 
N
N  #undef __math_h  // later inclusion of math.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __cmath */
N
N/* end of cmath */
N
L 47 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_math.h" 2
N
N#undef exception
N
N// MSVC provides its own complex macro
N#ifdef _MSC_VER
S#  ifdef complex
S#    undef complex
S#  endif
N#endif
N
N
N#endif   // _RWSTD_MATH_H_INCLUDED
N
L 37 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N
N#include _RWSTD_CFLOAT
X#include <cfloat>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cfloat" 1
N/*
N * C++ header for C header float.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cfloat
N#define __cfloat
N#define __ARMCLIB_VERSION 5060037
N
N  #define __FLOAT_NO_EXPORTS 1
N  #include <float.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\float.h" 1
N/* float.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd, 1988                             */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.01 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __float_h
N#define __float_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __FLOAT_DECLS
N  #define __FLOAT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N      #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* IEEE version: the following values are taken from the above ANSI draft.  */
N/* The ACORN FPE (v17) is known not to precisely implement IEEE arithmetic. */
N
N#define FLT_RADIX     2
N    /* radix of exponent representation */
N#ifdef __FP_FENV_ROUNDING
Sextern unsigned __ieee_status(unsigned,unsigned); /* from fenv.h */
S#define FLT_ROUNDS ((1+(__CLIBNS __ieee_status(0, 0)>>22))&3)
N#else
N#define FLT_ROUNDS    1
N#endif
N    /*
N     * The rounding mode for floating-point addition is characterised by the
N     * value of FLT_ROUNDS:
N     *  -1 : indeterminable.
N     *   0 : towards zero.
N     *   1 : to nearest.
N     *   2 : towards positive infinity.
N     *   3 : towards negative infinity.
N     *   ? : any other is implementation-defined.
N     */
N
N#define FLT_MANT_DIG        24
N#define DBL_MANT_DIG        53
N#define LDBL_MANT_DIG       53
N    /* number of base-FLT_RADIX digits in the floating point mantissa */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N#define DECIMAL_DIG 17
N    /* number of decimal digits that the widest floating point type
N       can be rounded to and back again without changing the value */
N#ifdef __FP_FAST
S#  define FLT_EVAL_METHOD (-1)
N#else
N#  define FLT_EVAL_METHOD 0
N#endif
N    /*
N     * The use of evaluation formats is characterized by the value of
N     * FLT_EVAL_METHOD:
N     *  -1 : indeterminable.
N     *   0 : evaluate all operations and constants just to the range
N     *       and precision of the type.
N     *   1 : evaluate operations and constants of type float and
N     *       double to the range and precision of the double type,
N     *       evaluate long double operations and constants to the
N     *       range and precision of the long double type.
N     *   2 : evaluate all opertations and constants to the range and
N     *       precision of the long double type.
N     */
N#endif
N
N/* The values that follow are not achieved under Acorn's FPE version 17  */
N/* but they should be correct in due course!                             */
N
N#define FLT_DIG      6
N#define DBL_DIG      15
N#define LDBL_DIG     15
N    /* number of decimal digits of precision */
N
N#define FLT_MIN_EXP  (-125)
N#define DBL_MIN_EXP  (-1021)
N#define LDBL_MIN_EXP (-1021)
N    /* minimum negative integer such that FLT_RADIX raised to that power */
N    /* minus 1 is a normalised floating-point number. */
N
N#define FLT_MIN_10_EXP  (-37)
N#define DBL_MIN_10_EXP  (-307)
N#define LDBL_MIN_10_EXP (-307)
N    /* minimum negative integer such that 10 raised to that power is in the */
N    /* range of normalised floating-point numbers. */
N
N#define FLT_MAX_EXP  128
N#define DBL_MAX_EXP  1024
N#define LDBL_MAX_EXP 1024
N    /* maximum integer such that FLT_RADIX raised to that power minus 1 is a */
N#define FLT_MAX_10_EXP  38
N#define DBL_MAX_10_EXP  308
N#define LDBL_MAX_10_EXP 308
N    /* maximum integer such that 10 raised to that power is in the range of */
N    /* representable finite floating-point numbers. */
N
N#define FLT_MAX  3.40282347e+38F
N#define DBL_MAX  1.79769313486231571e+308
N#define LDBL_MAX 1.79769313486231571e+308L
N    /* maximum representable finite floating-point number. */
N
N#define FLT_EPSILON         1.19209290e-7F
N#define DBL_EPSILON         2.2204460492503131e-16
N#define LDBL_EPSILON        2.2204460492503131e-16L
N    /* minimum positive floating point number x such that 1.0 + x != 1.0 */
N
N#define FLT_MIN  1.175494351e-38F
N#define DBL_MIN  2.22507385850720138e-308
N#define LDBL_MIN 2.22507385850720138e-308L
N    /* minimum normalised positive floating-point number. */
N
N/*
N * The Microsoft <float.h> extensions.
N */
N#ifdef __cplusplus
Nextern "C" {
N#endif
Nunsigned _controlfp(unsigned, unsigned);
Nunsigned _clearfp(void);
Nunsigned _statusfp(void);
N#ifdef __cplusplus
N}
N#endif
N
N
N/*
N * Because the _EM_ constants are shared between _controlfp (masks)
N * and _statusfp (sticky bits), we adopt the convention that
N * _controlfp will shift its arguments left by 8 bits before using
N * them.
N */
N
N#define _MCW_EM         0x001F
N#define _EM_INVALID     0x0001
N#define _EM_ZERODIVIDE  0x0002
N#define _EM_OVERFLOW    0x0004
N#define _EM_UNDERFLOW   0x0008
N#define _EM_INEXACT     0x0010
N
N#define _MCW_RC         0xC000
N#define _RC_CHOP        0xC000
N#define _RC_UP          0x4000
N#define _RC_DOWN        0x8000
N#define _RC_NEAR        0x0000
N
N/*
N * _FPE_ constants passed as the hidden second argument to SIGFPE
N * handlers.
N */
N#define _FPE_INVALID     0x04000000
N#define _FPE_ZERODIVIDE  0x08000000
N#define _FPE_OVERFLOW    0x10000000
N#define _FPE_UNDERFLOW   0x20000000
N#define _FPE_INEXACT     0x40000000
N
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __FLOAT_DECLS */
N
N  #if defined(__cplusplus) && !defined(__FLOAT_NO_EXPORTS)
X  #if 1L && !1L
S    using ::std::_controlfp;
S    using ::std::_clearfp;
S    using ::std::_statusfp;
N  #endif
N
N#endif /* __float_h */
N
N/* end of float.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cfloat" 2
N  #undef __FLOAT_NO_EXPORTS
N
N  #undef __float_h  // later inclusion of float.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif
N
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N#include _RWSTD_CLIMITS
X#include <climits>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\climits" 1
N/*
N * C++ header for C header limits.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __climits
N#define __climits
N#define __ARMCLIB_VERSION 5060037
N
N#include <limits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060037
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 17 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\climits" 2
N
N#endif
N
L 40 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\limits" 2
N#include _RWSTD_IEEEFP
X#include <rw/_defs.h>
N
N
N/**************************************************************************
N *
N * Assumptions made in this implementation:
N *
N *   1) numeric_limits<T>::digits is 1 for bool and is computed as
N *      (CHAR_BIT * sizeof (T) - numeric_limits<T>::is_signed for
N *      all native integral T
N *
N *   2) numeric_limits<T>::radix is the same (2 by default) for all
N *      specializations of native integral T
N *
N *   3) numeric_limits<T>::is_modulo is true if numeric_limits<T>::max()
N *      + 1 == numeric_limits<T>::min for all specializations
N *      of native integral T
N *
N *   4) numeric_limts<T>::traps == false for all native integral T
N *
N *   5) OEM vendors are expected to provide correct values where supplied
N *      values (VENDOR) differ from those defined by the implementation
N *
N **************************************************************************/
N
N#define _RWSTD_HAS_INFINITY true  // VENDOR
N#define _RWSTD_HAS_QUIET_NAN true // VENDOR
N
N#ifdef __FP_IEEE
S  #define _RWSTD_IS_IEC559 true // VENDOR
S  #define _RWSTD_HAS_DENORM_LOSS true // VENDOR
S  #define _RWSTD_HAS_DENORM      denorm_present // VENDOR
S  #define _RWSTD_FLT_DENORM_MIN  1.4012984643248171e-45F   // VENDOR
S  #define _RWSTD_DBL_DENORM_MIN  4.9406564584124654e-324   // VENDOR
S  #define _RWSTD_LDBL_DENORM_MIN 4.9406564584124654e-324L  // VENDOR
N#else
N  #define _RWSTD_IS_IEC559 false // VENDOR
N  #define _RWSTD_HAS_DENORM_LOSS false // VENDOR
N  #define _RWSTD_HAS_DENORM      denorm_absent // VENDOR
N  #define _RWSTD_FLT_DENORM_MIN  FLT_MIN   // VENDOR
N  #define _RWSTD_DBL_DENORM_MIN  DBL_MIN    // VENDOR
N  #define _RWSTD_LDBL_DENORM_MIN LDBL_MIN  // VENDOR
N#endif
N
N#ifdef __FP_FENV_ROUNDING
S  /* We only include the relevant parts of fenv.h to avoid polluting the user's
S   * namespace.
S  #include <fenv.h>
S  */
S  extern "C" unsigned __ieee_status(unsigned, unsigned);
S  #define __FE_IEEE_ROUND_MASK         (0x00C00000)
S  #define __FE_IEEE_ROUND_TONEAREST    (0x00000000)
S  /* end of <fenv.h> */
S  // rounding can be changed at runtime
S  #define _RWSTD_ROUND_TONEAREST ((__ieee_status(0,0) & __FE_IEEE_ROUND_MASK) == __FE_IEEE_ROUND_TONEAREST)
S  #define _RWSTD_FLT_ROUND_ERROR  (_RWSTD_ROUND_TONEAREST ? 0.5F : 1.0F)
S  #define _RWSTD_DBL_ROUND_ERROR  (_RWSTD_ROUND_TONEAREST ? 0.5  : 1.0)
S  #define _RWSTD_LDBL_ROUND_ERROR (_RWSTD_ROUND_TONEAREST ? 0.5L : 1.0L)
N#else
N  // rounding is fixed to round to nearest
N  #define _RWSTD_FLT_ROUND_ERROR  0.5F
N  #define _RWSTD_DBL_ROUND_ERROR  0.5
N  #define _RWSTD_LDBL_ROUND_ERROR 0.5L
N#endif
N
N// signalling NAN
N#define _RWSTD_HAS_SIG_NAN true // VENDOR
N
N#undef _RWSTD_STATIC_INIT
N#undef _RWSTD_STATIC_DEF
N
N
N#ifndef _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N#  ifndef _RWSTD_DEFINE_EXPORTS
N#    define _RWSTD_STATIC_INIT(name, value)   name = (value)
N#  else
S#    define _RWSTD_STATIC_INIT(name, value)   name
N#  endif
N#else
S#  ifndef _RWSTD_DEFINE_EXPORTS
S#    define _RWSTD_STATIC_INIT(name, value)   name
S#  else
S#    define _RWSTD_STATIC_INIT(name, value)   name = (value)
S#  endif
N#endif   // _RWSTD_NO_STATIC_CONST_MEMBER_INIT
N
N
N#undef _RWSTD_CLASS_BEGIN
N#undef _RWSTD_CLASS_END
N#undef _RWSTD_TYPEDEF
N#undef _RWSTD_STATIC
N#undef _RWSTD_STATIC_ROUNDS
N#undef _RWSTD_STATIC_FUN
N
N
N#ifndef _RWSTD_DEFINE_EXPORTS
N
N// declarations - expanded in every translation unit
N// that #includes <limits>
N
N#  define _RWSTD_CLASS_BEGIN(name) name { public: 
N#  define _RWSTD_CLASS_END              };
N#  define _RWSTD_TYPEDEF(def)           typedef def;
N#  define _RWSTD_STATIC(ignore, type, name, value)            \
N          static const type            \
N              _RWSTD_STATIC_INIT (name, value)
X#  define _RWSTD_STATIC(ignore, type, name, value)                      static const type                          _RWSTD_STATIC_INIT (name, value)
N
N#  ifndef _RWSTD_NO_CONST_FLT_ROUNDS
S#    define _RWSTD_STATIC_ROUNDS(ignore, type, name, value)   \
S            _RWSTD_STATIC (ignore, type, name,                \
S                           _RWSTD_STATIC_CAST (float_round_style, value))
X#    define _RWSTD_STATIC_ROUNDS(ignore, type, name, value)               _RWSTD_STATIC (ignore, type, name,                                           _RWSTD_STATIC_CAST (float_round_style, value))
N#  else
N#    define _RWSTD_STATIC_ROUNDS(ign1, type, name, ign2)      \
N            static const type _RWSTD_EXPORT name
X#    define _RWSTD_STATIC_ROUNDS(ign1, type, name, ign2)                  static const type _RWSTD_EXPORT name
N#  endif   // _RWSTD_NO_CONST_FLT_ROUNDS
N
N#  define _RWSTD_STATIC_FUN(type, name, value)                \
N          static type name () _THROWS (()) { return value; }
X#  define _RWSTD_STATIC_FUN(type, name, value)                          static type name () _THROWS (()) { return value; }
N
N#else   // defined (_RWSTD_DEFINE_EXPORTS)
S
S// definitions - expanded in a single translation unit that defines
S// static const data members outside of each numeric_limits<> specialization
S
S#  define _RWSTD_CLASS_BEGIN(ignore)
S#  define _RWSTD_CLASS_END
S#  define _RWSTD_TYPEDEF(ignore)
S#  define _RWSTD_STATIC(limtype, type, name, value)           \
S          const type _RWSTD_STATIC_INIT (numeric_limits<limtype>::name, value)
X#  define _RWSTD_STATIC(limtype, type, name, value)                     const type _RWSTD_STATIC_INIT (numeric_limits<limtype>::name, value)
S
S#  ifndef _RWSTD_NO_CONST_FLT_ROUNDS
S#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)  \
S            _RWSTD_STATIC (limtype, type, name,               \
S                           _RWSTD_STATIC_CAST (float_round_style, value))
X#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)              _RWSTD_STATIC (limtype, type, name,                                          _RWSTD_STATIC_CAST (float_round_style, value))
S#  else
S#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)  \
S            const type numeric_limits<limtype>::name =        \
S                           _RWSTD_STATIC_CAST (float_round_style, value)
X#    define _RWSTD_STATIC_ROUNDS(limtype, type, name, value)              const type numeric_limits<limtype>::name =                                   _RWSTD_STATIC_CAST (float_round_style, value)
S#  endif   // _RWSTD_NO_CONST_FLT_ROUNDS
S
S#  define _RWSTD_STATIC_FUN(ign1, ign2, ign3)
S#  define _RWSTD_STATIC_FUN_HEXFLOAT(ign1, ign2, ign3)
S#  define _RWSTD_STATIC_FUN_HEXDOUBLE(ign1, ign2, ign3, ign4)
S
N#endif   // _RWSTD_DEFINE_EXPORTS
N
N
N// 18.2.1.2, p6 - 7
N#define _RWSTD_DIGITS(type, min, max) \
N        (1 == (max) ? 1 : (CHAR_BIT * sizeof (type) - ((min) != 0)))
X#define _RWSTD_DIGITS(type, min, max)         (1 == (max) ? 1 : (CHAR_BIT * sizeof (type) - ((min) != 0)))
N
N// 18.2.1.2, p9
N#define _RWSTD_DIGITS10(digits)   (((digits) * 301) / 1000)
N
N
N#undef max
N#undef min
N
N
N#undef _RWSTD_LIMITS_BODY
N
N#define _RWSTD_LIMITS_BODY(type, conv_type, cpfx)                           \
N    _RWSTD_STATIC (type, bool, is_specialized, true);                       \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, min, cpfx##_MIN)                               \
N    _RWSTD_STATIC_FUN (type, max, cpfx##_MAX)                               \
N                                                                            \
N    _RWSTD_STATIC (type, bool, is_signed,  cpfx##_MIN != 0);                \
N    _RWSTD_STATIC (type, bool, is_integer, true);                           \
N    _RWSTD_STATIC (type, bool, is_exact,   true);                           \
N                                                                            \
N    _RWSTD_STATIC (type, int, digits,                                       \
N                   _RWSTD_DIGITS (type, cpfx##_MIN, cpfx##_MAX));           \
N                                                                            \
N    /* spelled out to work around a bug in IBM xlC 5.0 */                   \
N    _RWSTD_STATIC (type, int, digits10,                                     \
N                   _RWSTD_DIGITS10 (_RWSTD_DIGITS (type, cpfx##_MIN,        \
N                                                         cpfx##_MAX)));     \
N                                                                            \
N    _RWSTD_STATIC (type, int, radix, 2);   /* VENDOR */                     \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, epsilon,     0)                                \
N    _RWSTD_STATIC_FUN (type, round_error, 0)                                \
N                                                                            \
N    _RWSTD_STATIC (type, int, min_exponent,   0);                           \
N    _RWSTD_STATIC (type, int, min_exponent10, 0);                           \
N    _RWSTD_STATIC (type, int, max_exponent,   0);                           \
N    _RWSTD_STATIC (type, int, max_exponent10, 0);                           \
N                                                                            \
N    _RWSTD_STATIC (type, bool, has_infinity,             false);            \
N    _RWSTD_STATIC (type, bool, has_quiet_NaN,            false);            \
N    _RWSTD_STATIC (type, bool, has_signaling_NaN,        false);            \
N    _RWSTD_STATIC (type, float_denorm_style, has_denorm, denorm_absent);    \
N    _RWSTD_STATIC (type, bool, has_denorm_loss,          false);            \
N                                                                            \
N    _RWSTD_STATIC_FUN (type, infinity,      0)                              \
N    _RWSTD_STATIC_FUN (type, quiet_NaN,     0)                              \
N    _RWSTD_STATIC_FUN (type, signaling_NaN, 0)                              \
N    _RWSTD_STATIC_FUN (type, denorm_min,    0)                              \
N                                                                            \
N    _RWSTD_STATIC (type, bool, is_iec559,  false);                          \
N    _RWSTD_STATIC (type, bool, is_bounded, true);                           \
N    _RWSTD_STATIC (type, bool, is_modulo,  1 != cpfx##_MAX);                \
N                                                                            \
N    _RWSTD_STATIC (type, bool, traps,           false);                     \
N    _RWSTD_STATIC (type, bool, tinyness_before, false);                     \
N    _RWSTD_STATIC (type, float_round_style, round_style, round_toward_zero);\
N                                                                            \
N    /* extension: type converts to without loss of data */                  \
N    _RWSTD_TYPEDEF (conv_type _C_convertible)
X#define _RWSTD_LIMITS_BODY(type, conv_type, cpfx)                               _RWSTD_STATIC (type, bool, is_specialized, true);                                                                                                       _RWSTD_STATIC_FUN (type, min, cpfx##_MIN)                                   _RWSTD_STATIC_FUN (type, max, cpfx##_MAX)                                                                                                               _RWSTD_STATIC (type, bool, is_signed,  cpfx##_MIN != 0);                    _RWSTD_STATIC (type, bool, is_integer, true);                               _RWSTD_STATIC (type, bool, is_exact,   true);                                                                                                           _RWSTD_STATIC (type, int, digits,                                                          _RWSTD_DIGITS (type, cpfx##_MIN, cpfx##_MAX));                                                                                                                   _RWSTD_STATIC (type, int, digits10,                                                        _RWSTD_DIGITS10 (_RWSTD_DIGITS (type, cpfx##_MIN,                                                                 cpfx##_MAX)));                                                                                     _RWSTD_STATIC (type, int, radix, 2);                                                                                                         _RWSTD_STATIC_FUN (type, epsilon,     0)                                    _RWSTD_STATIC_FUN (type, round_error, 0)                                                                                                                _RWSTD_STATIC (type, int, min_exponent,   0);                               _RWSTD_STATIC (type, int, min_exponent10, 0);                               _RWSTD_STATIC (type, int, max_exponent,   0);                               _RWSTD_STATIC (type, int, max_exponent10, 0);                                                                                                           _RWSTD_STATIC (type, bool, has_infinity,             false);                _RWSTD_STATIC (type, bool, has_quiet_NaN,            false);                _RWSTD_STATIC (type, bool, has_signaling_NaN,        false);                _RWSTD_STATIC (type, float_denorm_style, has_denorm, denorm_absent);        _RWSTD_STATIC (type, bool, has_denorm_loss,          false);                                                                                            _RWSTD_STATIC_FUN (type, infinity,      0)                                  _RWSTD_STATIC_FUN (type, quiet_NaN,     0)                                  _RWSTD_STATIC_FUN (type, signaling_NaN, 0)                                  _RWSTD_STATIC_FUN (type, denorm_min,    0)                                                                                                              _RWSTD_STATIC (type, bool, is_iec559,  false);                              _RWSTD_STATIC (type, bool, is_bounded, true);                               _RWSTD_STATIC (type, bool, is_modulo,  1 != cpfx##_MAX);                                                                                                _RWSTD_STATIC (type, bool, traps,           false);                         _RWSTD_STATIC (type, bool, tinyness_before, false);                         _RWSTD_STATIC (type, float_round_style, round_style, round_toward_zero);                                                                                                       _RWSTD_TYPEDEF (conv_type _C_convertible)
N
N
N#undef _RWSTD_SPECIALIZE_LIMITS
N
N#define _RWSTD_SPECIALIZE_LIMITS(type, conv_type, cpfx)      \
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS                 \
N                    class _RWSTD_EXPORT numeric_limits<type>) \
N    _RWSTD_LIMITS_BODY (type, conv_type, cpfx)               \
N_RWSTD_CLASS_END
X#define _RWSTD_SPECIALIZE_LIMITS(type, conv_type, cpfx)      _RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS                                     class _RWSTD_EXPORT numeric_limits<type>)     _RWSTD_LIMITS_BODY (type, conv_type, cpfx)               _RWSTD_CLASS_END
N
N
N#ifndef _RWSTD_LIMITS_TEMPLATE_DEFINED
N#define _RWSTD_LIMITS_TEMPLATE_DEFINED
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Nenum float_round_style
N{
N    round_indeterminate       = -1,
N    round_toward_zero         =  0,
N    round_to_nearest          =  1,
N    round_toward_infinity     =  2,
N    round_toward_neg_infinity =  3
N};
N
Nenum float_denorm_style
N{
N    denorm_indeterminate = -1,
N    denorm_absent        =  0,
N    denorm_present       =  1
N};
N
Ntemplate <class _TypeT>
Nclass numeric_limits
N{
Npublic:
N    // static consts below must be initialized in class so that
N    // they can be used where const expressions are required (such
N    // as in template parameters)
N
N    _RWSTD_STATIC_CONST (bool, is_specialized = false);
X    static const bool is_specialized = false;
N
N    static _TypeT min () _THROWS (()) { return 0; }
X    static _TypeT min ()  { return 0; }
N    static _TypeT max () _THROWS (()) { return 0; }
X    static _TypeT max ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (int, digits   = 0);
X    static const int digits = 0;
N    _RWSTD_STATIC_CONST (int, digits10 = 0);
X    static const int digits10 = 0;
N
N    _RWSTD_STATIC_CONST (bool, is_signed  = false);
X    static const bool is_signed = false;
N    _RWSTD_STATIC_CONST (bool, is_integer = false);
X    static const bool is_integer = false;
N    _RWSTD_STATIC_CONST (bool, is_exact   = false);
X    static const bool is_exact = false;
N
N    _RWSTD_STATIC_CONST (int, radix = 0);
X    static const int radix = 0;
N
N    static _TypeT epsilon () _THROWS (()) { return 0; }
X    static _TypeT epsilon ()  { return 0; }
N    static _TypeT round_error () _THROWS (()) { return 0; }
X    static _TypeT round_error ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (int, min_exponent   = 0);
X    static const int min_exponent = 0;
N    _RWSTD_STATIC_CONST (int, min_exponent10 = 0);
X    static const int min_exponent10 = 0;
N    _RWSTD_STATIC_CONST (int, max_exponent   = 0);
X    static const int max_exponent = 0;
N    _RWSTD_STATIC_CONST (int, max_exponent10 = 0);
X    static const int max_exponent10 = 0;
N
N    _RWSTD_STATIC_CONST (bool, has_infinity             = false);
X    static const bool has_infinity = false;
N    _RWSTD_STATIC_CONST (bool, has_quiet_NaN            = false);
X    static const bool has_quiet_NaN = false;
N    _RWSTD_STATIC_CONST (bool, has_signaling_NaN        = false);
X    static const bool has_signaling_NaN = false;
N    _RWSTD_STATIC_CONST (float_denorm_style, has_denorm = denorm_absent);
X    static const float_denorm_style has_denorm = denorm_absent;
N    _RWSTD_STATIC_CONST (bool, has_denorm_loss          = false);
X    static const bool has_denorm_loss = false;
N
N    static _TypeT infinity () _THROWS (()) { return 0; }
X    static _TypeT infinity ()  { return 0; }
N    static _TypeT quiet_NaN () _THROWS (()) { return 0; }
X    static _TypeT quiet_NaN ()  { return 0; }
N    static _TypeT signaling_NaN () _THROWS (()) { return 0; }
X    static _TypeT signaling_NaN ()  { return 0; }
N    static _TypeT denorm_min () _THROWS (()) { return 0; }
X    static _TypeT denorm_min ()  { return 0; }
N
N    _RWSTD_STATIC_CONST (bool, is_iec559        = false);
X    static const bool is_iec559 = false;
N    _RWSTD_STATIC_CONST (bool, is_bounded       = false);
X    static const bool is_bounded = false;
N    _RWSTD_STATIC_CONST (bool, is_modulo        = false);
X    static const bool is_modulo = false;
N    _RWSTD_STATIC_CONST (bool, traps            = false);
X    static const bool traps = false;
N    _RWSTD_STATIC_CONST (bool, tinyness_before  = false);
X    static const bool tinyness_before = false;
N    _RWSTD_STATIC_CONST (float_round_style, round_style = round_toward_zero);
X    static const float_round_style round_style = round_toward_zero;
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_LIMITS_TEMPLATE_DEFINED
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<float>)
Xtemplate< > class numeric_limits<float> { public:
N
N    _RWSTD_STATIC (float, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (float, min, FLT_MIN)
X    static float min ()  { return 1.175494351e-38F; }
N    _RWSTD_STATIC_FUN (float, max, FLT_MAX)
X    static float max ()  { return 3.40282347e+38F; }
N
N    _RWSTD_STATIC (float, int, digits,   FLT_MANT_DIG);
X    static const int digits = (24);
N    _RWSTD_STATIC (float, int, digits10, FLT_DIG);
X    static const int digits10 = (6);
N
N    _RWSTD_STATIC (float, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (float, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (float, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (float, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (float, epsilon,     FLT_EPSILON)
X    static float epsilon ()  { return 1.19209290e-7F; }
N    _RWSTD_STATIC_FUN (float, round_error, _RWSTD_FLT_ROUND_ERROR)
X    static float round_error ()  { return 0.5F; }
N
N    _RWSTD_STATIC (float, int, min_exponent,   FLT_MIN_EXP);
X    static const int min_exponent = ((-125));
N    _RWSTD_STATIC (float, int, min_exponent10, FLT_MIN_10_EXP);
X    static const int min_exponent10 = ((-37));
N    _RWSTD_STATIC (float, int, max_exponent,   FLT_MAX_EXP);
X    static const int max_exponent = (128);
N    _RWSTD_STATIC (float, int, max_exponent10, FLT_MAX_10_EXP);
X    static const int max_exponent10 = (38);
N
N    _RWSTD_STATIC (float, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (float, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (float, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (float, float_denorm_style, has_denorm,
N                   _RWSTD_HAS_DENORM);
X    static const float_denorm_style has_denorm = (denorm_absent);
N    _RWSTD_STATIC (float, bool, has_denorm_loss, _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#ifndef __has_builtin
S  #define __has_builtin(x) 0
N#endif
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (float, infinity,      __builtin_inff()) // VENDOR
S    _RWSTD_STATIC_FUN (float, quiet_NaN,     __builtin_nanf("")) // VENDOR
S    _RWSTD_STATIC_FUN (float, signaling_NaN, __builtin_nansf("")) // VENDOR
N#else
N    _RWSTD_STATIC_FUN (float, infinity,      __ESCAPE__(0f_7F800000)) // VENDOR
X    static float infinity ()  { return __ESCAPE__(0f_7F800000); } 
N    _RWSTD_STATIC_FUN (float, quiet_NaN,     __ESCAPE__(0f_7FC00000)) // VENDOR
X    static float quiet_NaN ()  { return __ESCAPE__(0f_7FC00000); } 
N    _RWSTD_STATIC_FUN (float, signaling_NaN, __ESCAPE__(0f_7F800001)) // VENDOR
X    static float signaling_NaN ()  { return __ESCAPE__(0f_7F800001); } 
N#endif
N    _RWSTD_STATIC_FUN (float, denorm_min,    _RWSTD_FLT_DENORM_MIN) // VENDOR
X    static float denorm_min ()  { return 1.175494351e-38F; } 
N
N    _RWSTD_STATIC (float, bool, is_iec559,  _RWSTD_IS_IEC559);    // VENDOR
X    static const bool is_iec559 = (false);    
N    _RWSTD_STATIC (float, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (float, bool, is_modulo,  false);               // VENDOR
X    static const bool is_modulo = (false);               
N
N    _RWSTD_STATIC (float, bool, traps, true);                    // VENDOR
X    static const bool traps = (true);                    
N    _RWSTD_STATIC (float, bool, tinyness_before, false);          // VENDOR
X    static const bool tinyness_before = (false);          
N
N    _RWSTD_STATIC_ROUNDS (float, float_round_style, round_style, FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (double _C_convertible)
X    typedef double _C_convertible;
N
N_RWSTD_CLASS_END   // numeric_limits<float>
X};   
N
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<double>)
Xtemplate< > class numeric_limits<double> { public:
N
N    _RWSTD_STATIC (double, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (double, min, DBL_MIN)
X    static double min ()  { return 2.22507385850720138e-308; }
N    _RWSTD_STATIC_FUN (double, max, DBL_MAX)
X    static double max ()  { return 1.79769313486231571e+308; }
N
N    _RWSTD_STATIC (double, int, digits,   DBL_MANT_DIG);
X    static const int digits = (53);
N    _RWSTD_STATIC (double, int, digits10, DBL_DIG);
X    static const int digits10 = (15);
N
N    _RWSTD_STATIC (double, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (double, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (double, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (double, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (double, epsilon,     DBL_EPSILON)
X    static double epsilon ()  { return 2.2204460492503131e-16; }
N    _RWSTD_STATIC_FUN (double, round_error, _RWSTD_DBL_ROUND_ERROR)
X    static double round_error ()  { return 0.5; }
N
N    _RWSTD_STATIC (double, int, min_exponent,   DBL_MIN_EXP);
X    static const int min_exponent = ((-1021));
N    _RWSTD_STATIC (double, int, min_exponent10, DBL_MIN_10_EXP);
X    static const int min_exponent10 = ((-307));
N    _RWSTD_STATIC (double, int, max_exponent,   DBL_MAX_EXP);
X    static const int max_exponent = (1024);
N    _RWSTD_STATIC (double, int, max_exponent10, DBL_MAX_10_EXP);
X    static const int max_exponent10 = (308);
N
N    _RWSTD_STATIC (double, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (double, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (double, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (double, float_denorm_style, has_denorm,
N                   _RWSTD_HAS_DENORM);
X    static const float_denorm_style has_denorm = (denorm_absent);
N    _RWSTD_STATIC (double, bool, has_denorm_loss,   _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (double, infinity,      __builtin_inf())   // VENDOR
S    _RWSTD_STATIC_FUN (double, quiet_NaN,     __builtin_nan(""))   // VENDOR
S    _RWSTD_STATIC_FUN (double, signaling_NaN, __builtin_nans(""))   // VENDOR
N#else
N    _RWSTD_STATIC_FUN (double, infinity,      __ESCAPE__(0d_7FF0000000000000))   // VENDOR
X    static double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
N    _RWSTD_STATIC_FUN (double, quiet_NaN,     __ESCAPE__(0d_7FF8000000000000))   // VENDOR
X    static double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
N    _RWSTD_STATIC_FUN (double, signaling_NaN, __ESCAPE__(0d_7FF0000000000001))   // VENDOR
X    static double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   
N#endif
N    _RWSTD_STATIC_FUN (double, denorm_min,    _RWSTD_DBL_DENORM_MIN)
X    static double denorm_min ()  { return 2.22507385850720138e-308; }
N
N    _RWSTD_STATIC (double, bool, is_iec559,  _RWSTD_IS_IEC559);
X    static const bool is_iec559 = (false);
N    _RWSTD_STATIC (double, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (double, bool, is_modulo,  false);              // VENDOR
X    static const bool is_modulo = (false);              
N
N    _RWSTD_STATIC (double, bool, traps, true);                   // VENDOR
X    static const bool traps = (true);                   
N    _RWSTD_STATIC (double, bool, tinyness_before, false);         // VENDOR
X    static const bool tinyness_before = (false);         
N
N    _RWSTD_STATIC_ROUNDS (double, float_round_style, round_style, FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (long double _C_convertible)
X    typedef long double _C_convertible;
N
N_RWSTD_CLASS_END   // numeric_limits<double>
X};   
N
N
N#ifndef _RWSTD_NO_LONG_DOUBLE
N
N_RWSTD_CLASS_BEGIN (_RWSTD_SPECIALIZED_CLASS
N                    class _RWSTD_EXPORT numeric_limits<long double>)
Xtemplate< > class numeric_limits<long double> { public:
N
N    _RWSTD_STATIC (long double, bool, is_specialized, true);
X    static const bool is_specialized = (true);
N
N    _RWSTD_STATIC_FUN (long double, min, LDBL_MIN) 
X    static long double min ()  { return 2.22507385850720138e-308L; } 
N    _RWSTD_STATIC_FUN (long double, max, LDBL_MAX) 
X    static long double max ()  { return 1.79769313486231571e+308L; } 
N
N    _RWSTD_STATIC (long double, int, digits,   LDBL_MANT_DIG);
X    static const int digits = (53);
N    _RWSTD_STATIC (long double, int, digits10, LDBL_DIG);
X    static const int digits10 = (15);
N
N    _RWSTD_STATIC (long double, bool, is_signed,  true);
X    static const bool is_signed = (true);
N    _RWSTD_STATIC (long double, bool, is_integer, false);
X    static const bool is_integer = (false);
N    _RWSTD_STATIC (long double, bool, is_exact,   false);
X    static const bool is_exact = (false);
N    _RWSTD_STATIC (long double, int,  radix,      FLT_RADIX);
X    static const int radix = (2);
N
N    _RWSTD_STATIC_FUN (long double, epsilon,     LDBL_EPSILON) 
X    static long double epsilon ()  { return 2.2204460492503131e-16L; } 
N    _RWSTD_STATIC_FUN (long double, round_error, _RWSTD_LDBL_ROUND_ERROR)
X    static long double round_error ()  { return 0.5L; }
N
N    _RWSTD_STATIC (long double, int, min_exponent,   LDBL_MIN_EXP);
X    static const int min_exponent = ((-1021));
N    _RWSTD_STATIC (long double, int, min_exponent10, LDBL_MIN_10_EXP);
X    static const int min_exponent10 = ((-307));
N    _RWSTD_STATIC (long double, int, max_exponent,   LDBL_MAX_EXP);
X    static const int max_exponent = (1024);
N    _RWSTD_STATIC (long double, int, max_exponent10, LDBL_MAX_10_EXP);
X    static const int max_exponent10 = (308);
N
N    _RWSTD_STATIC (long double, bool, has_infinity,      _RWSTD_HAS_INFINITY);
X    static const bool has_infinity = (true);
N    _RWSTD_STATIC (long double, bool, has_quiet_NaN,     _RWSTD_HAS_QUIET_NAN);
X    static const bool has_quiet_NaN = (true);
N    _RWSTD_STATIC (long double, bool, has_signaling_NaN, _RWSTD_HAS_SIG_NAN);
X    static const bool has_signaling_NaN = (true);
N    _RWSTD_STATIC (long double, float_denorm_style, has_denorm,
N                   denorm_indeterminate);
X    static const float_denorm_style has_denorm = (denorm_indeterminate);
N    _RWSTD_STATIC (long double, bool, has_denorm_loss, _RWSTD_HAS_DENORM_LOSS);
X    static const bool has_denorm_loss = (false);
N
N#if __has_builtin(__builtin_inf)
X#if 0
S    _RWSTD_STATIC_FUN (long double, infinity,      __builtin_inf())   // VENDOR
S    _RWSTD_STATIC_FUN (long double, quiet_NaN,     __builtin_nan(""))   // VENDOR
S    _RWSTD_STATIC_FUN (long double, signaling_NaN, __builtin_nans(""))   // VENDOR
N#else
N    _RWSTD_STATIC_FUN (long double, infinity,      __ESCAPE__(0d_7FF0000000000000))   // VENDOR
X    static long double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
N    _RWSTD_STATIC_FUN (long double, quiet_NaN,     __ESCAPE__(0d_7FF8000000000000))   // VENDOR
X    static long double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
N    _RWSTD_STATIC_FUN (long double, signaling_NaN, __ESCAPE__(0d_7FF0000000000001))   // VENDOR
X    static long double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   
N#endif
N    _RWSTD_STATIC_FUN (long double, denorm_min,    _RWSTD_LDBL_DENORM_MIN)
X    static long double denorm_min ()  { return 2.22507385850720138e-308L; }
N
N    _RWSTD_STATIC (long double, bool, is_iec559,  _RWSTD_IS_IEC559);
X    static const bool is_iec559 = (false);
N    _RWSTD_STATIC (long double, bool, is_bounded, true);
X    static const bool is_bounded = (true);
N    _RWSTD_STATIC (long double, bool, is_modulo,  false);         // VENDOR
X    static const bool is_modulo = (false);         
N
N    _RWSTD_STATIC (long double, bool, traps, true);              // VENDOR
X    static const bool traps = (true);              
N    _RWSTD_STATIC (long double, bool, tinyness_before, false);    // VENDOR
X    static const bool tinyness_before = (false);    
N
N    _RWSTD_STATIC_ROUNDS (long double, float_round_style, round_style,
N                          FLT_ROUNDS);
X    static const float_round_style  round_style;
N
N     // extension: type converts to without loss of data
N    _RWSTD_TYPEDEF (long double _C_convertible)
X    typedef long double _C_convertible;
N
N_RWSTD_CLASS_END    // numeric_limits<long double>
X};    
N
N#endif   // _RWSTD_NO_LONG_DOUBLE
N
N
N#define _RWSTD_UCHAR_MIN 0
N#define _RWSTD_USHRT_MIN 0
N#define _RWSTD_UINT_MIN  0
N#define _RWSTD_ULONG_MIN 0
N
N#define _RWSTD_UCHAR_MAX UCHAR_MAX
N#define _RWSTD_USHRT_MAX USHRT_MAX
N#define _RWSTD_UINT_MAX  UINT_MAX
N#define _RWSTD_ULONG_MAX ULONG_MAX
N
N
N// types each integral type converts to with no loss of precision (if possible)
N#ifdef _RWSTD_LONG_LONG
N#  if UINT_MAX < ULONG_MAX
X#  if 0xffffffffU < 0xffffffffUL
S#    define _RWSTD_INT_CONVERTIBLE long
N#  else
N#    define _RWSTD_INT_CONVERTIBLE _RWSTD_LONG_LONG
N#  endif
N#  define _RWSTD_LONG_CONVERTIBLE  _RWSTD_LONG_LONG
N#else   // if !defined (_RWSTD_LONG_LONG)
S#  define _RWSTD_INT_CONVERTIBLE  long
S#  define _RWSTD_LONG_CONVERTIBLE long
N#endif   // _RWSTD_LONG_LONG
N
N
N#if UCHAR_MAX < UINT_MAX
X#if 255 < 0xffffffffU
N#  define _RWSTD_CHAR_CONVERTIBLE int
N#else
S#  define _RWSTD_CHAR_CONVERTIBLE _RWSTD_INT_CONVERTIBLE
N#endif   // UCHAR_MAX < UINT_MAX
N
N
N#if USHRT_MAX < UINT_MAX
X#if 65535 < 0xffffffffU
N#  define _RWSTD_SHORT_CONVERTIBLE int
N#else
S#  define _RWSTD_SHORT_CONVERTIBLE _RWSTD_INT_CONVERTIBLE
N#endif   // USHRT_MAX < UINT_MAX
N
N
N// define numeric_limits<> integral specializations
N_RWSTD_SPECIALIZE_LIMITS (char, _RWSTD_CHAR_CONVERTIBLE, CHAR)
Xtemplate< > class numeric_limits<char> { public: static const bool is_specialized = (true); static char min ()  { return 0; } static char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static char epsilon ()  { return 0; } static char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static char infinity ()  { return 0; } static char quiet_NaN ()  { return 0; } static char signaling_NaN ()  { return 0; } static char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned char,
N                          unsigned _RWSTD_CHAR_CONVERTIBLE, _RWSTD_UCHAR)
Xtemplate< > class numeric_limits<unsigned char> { public: static const bool is_specialized = (true); static unsigned char min ()  { return 0; } static unsigned char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned char epsilon ()  { return 0; } static unsigned char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned char infinity ()  { return 0; } static unsigned char quiet_NaN ()  { return 0; } static unsigned char signaling_NaN ()  { return 0; } static unsigned char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (signed char, _RWSTD_CHAR_CONVERTIBLE, SCHAR)
Xtemplate< > class numeric_limits<signed char> { public: static const bool is_specialized = (true); static signed char min ()  { return (-128); } static signed char max ()  { return 127; } static const bool is_signed = ((-128) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))); static const int digits10 = (((((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))) * 301) / 1000)); static const int radix = (2); static signed char epsilon ()  { return 0; } static signed char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static signed char infinity ()  { return 0; } static signed char quiet_NaN ()  { return 0; } static signed char signaling_NaN ()  { return 0; } static signed char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 127); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (short int, _RWSTD_SHORT_CONVERTIBLE, SHRT)
Xtemplate< > class numeric_limits<short int> { public: static const bool is_specialized = (true); static short int min ()  { return (-0x8000); } static short int max ()  { return 0x7fff; } static const bool is_signed = ((-0x8000) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))); static const int digits10 = (((((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))) * 301) / 1000)); static const int radix = (2); static short int epsilon ()  { return 0; } static short int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static short int infinity ()  { return 0; } static short int quiet_NaN ()  { return 0; } static short int signaling_NaN ()  { return 0; } static short int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned short,
N                          unsigned _RWSTD_SHORT_CONVERTIBLE, _RWSTD_USHRT)
Xtemplate< > class numeric_limits<unsigned short> { public: static const bool is_specialized = (true); static unsigned short min ()  { return 0; } static unsigned short max ()  { return 65535; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))); static const int digits10 = (((((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned short epsilon ()  { return 0; } static unsigned short round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned short infinity ()  { return 0; } static unsigned short quiet_NaN ()  { return 0; } static unsigned short signaling_NaN ()  { return 0; } static unsigned short denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 65535); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (int, _RWSTD_INT_CONVERTIBLE, INT)
Xtemplate< > class numeric_limits<int> { public: static const bool is_specialized = (true); static int min ()  { return (~0x7fffffff); } static int max ()  { return 0x7fffffff; } static const bool is_signed = ((~0x7fffffff) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))); static const int digits10 = (((((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))) * 301) / 1000)); static const int radix = (2); static int epsilon ()  { return 0; } static int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static int infinity ()  { return 0; } static int quiet_NaN ()  { return 0; } static int signaling_NaN ()  { return 0; } static int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned int,
N                          unsigned _RWSTD_INT_CONVERTIBLE, _RWSTD_UINT)
Xtemplate< > class numeric_limits<unsigned int> { public: static const bool is_specialized = (true); static unsigned int min ()  { return 0; } static unsigned int max ()  { return 0xffffffffU; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned int epsilon ()  { return 0; } static unsigned int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned int infinity ()  { return 0; } static unsigned int quiet_NaN ()  { return 0; } static unsigned int signaling_NaN ()  { return 0; } static unsigned int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffU); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (long int, _RWSTD_LONG_CONVERTIBLE, LONG)
Xtemplate< > class numeric_limits<long int> { public: static const bool is_specialized = (true); static long int min ()  { return (~0x7fffffffL); } static long int max ()  { return 0x7fffffffL; } static const bool is_signed = ((~0x7fffffffL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))) * 301) / 1000)); static const int radix = (2); static long int epsilon ()  { return 0; } static long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static long int infinity ()  { return 0; } static long int quiet_NaN ()  { return 0; } static long int signaling_NaN ()  { return 0; } static long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned long int,
N                          unsigned _RWSTD_LONG_CONVERTIBLE, _RWSTD_ULONG)
Xtemplate< > class numeric_limits<unsigned long int> { public: static const bool is_specialized = (true); static unsigned long int min ()  { return 0; } static unsigned long int max ()  { return 0xffffffffUL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned long int epsilon ()  { return 0; } static unsigned long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned long int infinity ()  { return 0; } static unsigned long int quiet_NaN ()  { return 0; } static unsigned long int signaling_NaN ()  { return 0; } static unsigned long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffUL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N
N#undef _RWSTD_UCHAR_MIN
N#undef _RWSTD_USHRT_MIN
N#undef _RWSTD_UINT_MIN
N#undef _RWSTD_ULONG_MIN
N
N#undef _RWSTD_UCHAR_MAX
N#undef _RWSTD_USHRT_MAX
N#undef _RWSTD_UINT_MAX
N#undef _RWSTD_ULONG_MAX
N
N#ifndef _RWSTD_NO_NATIVE_WCHAR_T
N
N#  define _RWSTD_WCHAR_MIN                                   \
N          (  wchar_t (-1) > 0 ? 0                            \
N           : sizeof (wchar_t) == sizeof (short) ? SHRT_MIN   \
N           : sizeof (wchar_t) == sizeof (int)   ? INT_MIN    \
N           : sizeof (wchar_t) == sizeof (long)  ? LONG_MIN   \
N           : SCHAR_MIN)
X#  define _RWSTD_WCHAR_MIN                                             (  wchar_t (-1) > 0 ? 0                                       : sizeof (wchar_t) == sizeof (short) ? SHRT_MIN              : sizeof (wchar_t) == sizeof (int)   ? INT_MIN               : sizeof (wchar_t) == sizeof (long)  ? LONG_MIN              : SCHAR_MIN)
N                        
N#  define _RWSTD_WCHAR_MAX                                       \
N          (  wchar_t (-1) > 0 ?                                  \
N             (  sizeof (wchar_t) == sizeof (short) ? USHRT_MAX   \
N              : sizeof (wchar_t) == sizeof (int)   ? UINT_MAX    \
N              : sizeof (wchar_t) == sizeof (long)  ? ULONG_MAX   \
N              : SCHAR_MAX)                                       \
N           : (  sizeof (wchar_t) == sizeof (short) ? SHRT_MAX    \
N              : sizeof (wchar_t) == sizeof (int)   ? INT_MAX     \
N              : sizeof (wchar_t) == sizeof (long)  ? LONG_MAX    \
N              : UCHAR_MAX))
X#  define _RWSTD_WCHAR_MAX                                                 (  wchar_t (-1) > 0 ?                                               (  sizeof (wchar_t) == sizeof (short) ? USHRT_MAX                 : sizeof (wchar_t) == sizeof (int)   ? UINT_MAX                  : sizeof (wchar_t) == sizeof (long)  ? ULONG_MAX                 : SCHAR_MAX)                                                  : (  sizeof (wchar_t) == sizeof (short) ? SHRT_MAX                  : sizeof (wchar_t) == sizeof (int)   ? INT_MAX                   : sizeof (wchar_t) == sizeof (long)  ? LONG_MAX                  : UCHAR_MAX))
N
N
N_RWSTD_SPECIALIZE_LIMITS (wchar_t, _RWSTD_INT_CONVERTIBLE, _RWSTD_WCHAR)
Xtemplate< > class numeric_limits<wchar_t> { public: static const bool is_specialized = (true); static wchar_t min ()  { return ( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)); } static wchar_t max ()  { return ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255)); } static const bool is_signed = (( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))); static const int digits10 = (((((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))) * 301) / 1000)); static const int radix = (2); static wchar_t epsilon ()  { return 0; } static wchar_t round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static wchar_t infinity ()  { return 0; } static wchar_t quiet_NaN ()  { return 0; } static wchar_t signaling_NaN ()  { return 0; } static wchar_t denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N#  undef _RWSTD_WCHAR_MIN
N#  undef _RWSTD_WCHAR_MAX
N
N#endif   // _RWSTD_NO_NATIVE_WCHAR_T
N
N
N#ifndef _RWSTD_NO_BOOL
N
N#  define _RWSTD_BOOL_MIN   false
N#  define _RWSTD_BOOL_MAX   true
N
N_RWSTD_SPECIALIZE_LIMITS (bool, int, _RWSTD_BOOL)
Xtemplate< > class numeric_limits<bool> { public: static const bool is_specialized = (true); static bool min ()  { return false; } static bool max ()  { return true; } static const bool is_signed = (false != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))); static const int digits10 = (((((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))) * 301) / 1000)); static const int radix = (2); static bool epsilon ()  { return 0; } static bool round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static bool infinity ()  { return 0; } static bool quiet_NaN ()  { return 0; } static bool signaling_NaN ()  { return 0; } static bool denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != true); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
N
N#  undef _RWSTD_BOOL_MIN
N#  undef _RWSTD_BOOL_MAX
N
N#endif   // _RWSTD_NO_BOOL
N
N
N#ifdef _RWSTD_LONG_LONG                                             // VENDOR
N
N#  if defined (_WIN32) && defined (_MSC_VER)
X#  if 0L && 0L
S#    define LONG_LONG_MIN   _I64_MIN
S#    define LONG_LONG_MAX   _I64_MAX
S#    define ULONG_LONG_MAX  _UI64_MAX
N#  else   // if !(defined (_WIN32) && defined (_MSC_VER))
N
N#  ifndef LONG_LONG_MIN
N#    ifndef LLONG_MIN
S       // assuming modulo 2 representation and a working shift
S#      define LONG_LONG_MIN \
S          (((_RWSTD_LONG_LONG)1) << (sizeof (_RWSTD_LONG_LONG) * CHAR_BIT - 1))
X#      define LONG_LONG_MIN           (((_RWSTD_LONG_LONG)1) << (sizeof (_RWSTD_LONG_LONG) * CHAR_BIT - 1))
S#      define LONG_LONG_MAX   (~LONG_LONG_MIN)
S#      define ULONG_LONG_MAX  (~(unsigned _RWSTD_LONG_LONG)0)
N#    else   // if defined (LLONG_MIN)
N       // e.g., Sun libc 
N#      define LONG_LONG_MIN   LLONG_MIN
N#      define LONG_LONG_MAX   LLONG_MAX
N#      define ULONG_LONG_MAX  ULLONG_MAX
N#    endif   // LLONG_MIN
N#  endif   // LONG_LONG_MIN
N
N#endif   // _WIN32 && _MSC_VER
N
N#  define ULONG_LONG_MIN   0
N
N_RWSTD_SPECIALIZE_LIMITS (_RWSTD_LONG_LONG, _RWSTD_LONG_LONG, LONG_LONG)
Xtemplate< > class numeric_limits<__int64> { public: static const bool is_specialized = (true); static __int64 min ()  { return (~0x7fffffffffffffffLL); } static __int64 max ()  { return 0x7fffffffffffffffLL; } static const bool is_signed = ((~0x7fffffffffffffffLL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))) * 301) / 1000)); static const int radix = (2); static __int64 epsilon ()  { return 0; } static __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static __int64 infinity ()  { return 0; } static __int64 quiet_NaN ()  { return 0; } static __int64 signaling_NaN ()  { return 0; } static __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffffffffffLL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };
N
N_RWSTD_SPECIALIZE_LIMITS (unsigned _RWSTD_LONG_LONG,
N                          unsigned _RWSTD_LONG_LONG, ULONG_LONG)
Xtemplate< > class numeric_limits<unsigned __int64> { public: static const bool is_specialized = (true); static unsigned __int64 min ()  { return 0; } static unsigned __int64 max ()  { return 0xffffffffffffffffULL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned __int64 epsilon ()  { return 0; } static unsigned __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned __int64 infinity ()  { return 0; } static unsigned __int64 quiet_NaN ()  { return 0; } static unsigned __int64 signaling_NaN ()  { return 0; } static unsigned __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffffffffffULL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };
N
N#  undef ULONG_LONG_MIN 
N
N#endif   // _RWSTD_LONG_LONG
N
N
N#undef _RWSTD_CHAR_CONVERTIBLE
N#undef _RWSTD_SHORT_CONVERTIBLE
N#undef _RWSTD_INT_CONVERTIBLE
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <limits.cc>
N#endif
N
N#endif   // _RWSTD_LIMITS_INCLUDED
N
L 37 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N
N#include <rw/_algobase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_algobase.h" 1
N/***************************************************************************
N *
N * _algobase.h - Declarations and inline definitions of frequently used
N *               C++ Standard Library algorithms
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ALGOBASE_H_INCLUDED
N#define _RWSTD_ALGOBASE_H_INCLUDED
N
N#include <utility>   // for pair
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\utility" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * utility - Declarations for the Standard Library utility classes
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_UTILITY_INCLUDED
N#define _RWSTD_UTILITY_INCLUDED
N
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
N// rel_ops contents not available if namespaces are disabled
N// to avoid ambiguities with other overloaded operators
N
N_RWSTD_NAMESPACE_BEGIN (rel_ops)
Xnamespace rel_ops {
N
N
Ntemplate <class _TypeT>
Ninline bool operator!= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x == __y);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator> (const _TypeT& __x, const _TypeT& __y)
N{
N    return __y < __x;
N}
N
Ntemplate <class _TypeT>
Ninline bool operator<= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__y < __x);
N}
N
Ntemplate <class _TypeT>
Ninline bool operator>= (const _TypeT& __x, const _TypeT& __y)
N{
N    return !(__x < __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // rel_ops
X}   
N
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.2.2
Ntemplate <class _TypeT, class _TypeU>
Nstruct pair
N{
N    typedef _TypeT first_type;
N    typedef _TypeU second_type;
N
N    first_type  first;
N    second_type second;
N
N    pair (const first_type &__x, const second_type &__y)
N        : first (__x), second (__y) { }
N
N    pair ()
N#ifndef _RWSTD_NO_EMPTY_MEM_INITIALIZER
N        : first (/* lwg issue 265 */), second () { }
N#else
S        : first (first_type ()), second (second_type ()) { }
N#endif   // _RWSTD_NO_EMPTY_MEM_INITIALIZER
N
N    pair (const pair &__rhs): first (__rhs.first), second (__rhs.second) { }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeX, class _TypeY>
N    pair (const pair <_TypeX, _TypeY> &__rhs) 
N        : first (__rhs.first), second (__rhs.second) { }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N};
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __x.first == __y.first && __x.second == __y.second; 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x == __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator< (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return    __x.first < __y.first
N           || (!(__y.first < __x.first) && __x.second < __y.second); 
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator> (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return __y < __x;
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator>= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__x < __y);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator<= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
N{ 
N    return !(__y < __x);
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline pair<_TypeT, _TypeU>
Nmake_pair (const _TypeT &__x, const _TypeU &__y)
N{
N    return pair<_TypeT, _TypeU>(__x, __y);
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_UTILITY_INCLUDED
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_algobase.h" 2
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S#  include <rw/_iterbase.h>
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#undef max
N#undef min
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.3.7, p1
Ntemplate <class _TypeT>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b)
N{
N    return __b < __a ? __b : __a;
N}
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& min (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__b, __a) ? __b : __a;
N}
N
N
N// 25.3.7, p3
Ntemplate <class _TypeT>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b)
N{
N    return  __a < __b ? __b : __a;
N}
N
N
Ntemplate <class _TypeT, class _Compare>
Ninline const _TypeT& max (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
N{
N    return __cmp (__a, __b) ? __b : __a;
N}
N
N
N// 25.2.1, p1
Ntemplate <class _InputIter, class _OutputIter>
Ninline _OutputIter
Ncopy (_InputIter __first, _InputIter __last, _OutputIter __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (; __first != __last; ++__first,++__res)
N        *__res = *__first;
N    return __res;
N}
N
N
N// 25.2.1, p5
Ntemplate <class _BidirIter1, class _BidirIter2>
Ninline _BidirIter2
Ncopy_backward (_BidirIter1 __first, _BidirIter1 __last, _BidirIter2 __res)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    while (__first != __last)
N        *--__res = *--__last;
N    return __res;
N}
N
N
N// 25.2.5
Ntemplate <class _FwdIter, class _TypeT>
Ninline void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    for (;__first != __last; ++__first)
N        *__first = __value;
N}
N
N
Ntemplate <class _OutputIter, class _Size, class _TypeT>
Ninline void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value)
N{
N    for (;__n > 0;--__n, ++__first)
N        *__first = __value;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// `less than' qusi-function object - used by algorithms for code reuse
Ntemplate <class _TypeT>
Nstruct __rw_lt
N{
N    bool operator() (const _TypeT &__lhs, const _TypeT &__rhs) const {
N        return __lhs < __rhs;
N    }
N};
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N#  define _RWSTD_LESS(iterT) \
N     _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
X#  define _RWSTD_LESS(iterT)      _RW::__rw_lt<_TYPENAME _STD::iterator_traits< iterT >::value_type>()
N
N#else   // if defined (_RWSTD_NO_PARTIAL_CLASS_SPEC)
S
S#  define _RWSTD_LESS(iterT) \
S     _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
X#  define _RWSTD_LESS(iterT)      _RW::__rw_make_lt (_RWSTD_VALUE_TYPE (iterT))
S
Stemplate <class _TypeT>
S__rw_lt<_TypeT> __rw_make_lt (const _TypeT*)
S{
S    return __rw_lt<_TypeT>();
S}
S
N#endif   // _RWSTD_NO_PARTIAL_CLASS_SPEC
N
N
N// swaps values of 2 (possibly distinct) types
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_swap (_TypeT& __a, _TypeU& __b)
N{
N    // _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 25.2.2, p1
Ntemplate <class _TypeT>
Ninline void swap (_TypeT& __a, _TypeT& __b)
N{
N    // LWG issue 227 - _TypeT must satisfy Assignable and CopyConstructible
N    _TypeT __tmp = __a;
N    __a = __b;
N    __b = __tmp;
N}
N
N
N// 25.2.2, p7
Ntemplate <class _FwdIter1, class _FwdIter2>
Ninline void iter_swap (_FwdIter1 __a, _FwdIter2 __b)
N{
N    // std::iterator_traits<_FwdIter[12]>::value_type must satisfy
N    // both Assignable and CopyConstructible
N    _RW::__rw_swap (*__a, *__b);
X    __rw::__rw_swap (*__a, *__b);
N}
N
N
N// 25.1.7 - Mismatch
Ntemplate <class _InputIter1, class _InputIter2>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && *__first1 == *__first2) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline pair<_InputIter1, _InputIter2>
Nmismatch (_InputIter1 __first1, _InputIter1 __last1,
N          _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N
N    while (__first1 != __last1 && __pred (*__first1, *__first2)) {
N        ++__first1;
N        ++__first2;
N    }
N    return pair<_InputIter1, _InputIter2> (__first1, __first2);
N}
N
N
N// 25.1.8 - Equal
Ntemplate <class _InputIter1, class _InputIter2>
Ninline bool
Nequal (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
N{
N    return __last1 == _STD::mismatch (__first1, __last1, __first2).first;
X    return __last1 == std::mismatch (__first1, __last1, __first2).first;
N}
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _BinaryPredicate>
Ninline bool equal (_InputIter1 __first1, _InputIter1 __last1,
N                   _InputIter2 __first2, _BinaryPredicate __pred)
N{
N    return __last1 == _STD::mismatch (__first1, __last1,
X    return __last1 == std::mismatch (__first1, __last1,
N                                      __first2, __pred).first;
N}
N
N
N// 25.3.8 - Lexicographical Comparison
Ntemplate <class _InputIter1, class _InputIter2>
Nbool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
N                              _InputIter2 __first2, _InputIter2 __last2);
N
N
Ntemplate <class _InputIter1, class _InputIter2, class _Compare>
Nbool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
N                             _InputIter2 __first2, _InputIter2 __last2,
N                             _Compare __comp);
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <rw/_algobase.cc>
N#endif
N
N
N#endif   // _RWSTD_ALGOBASE_H_INCLUDED
N
L 39 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N#include <rw/_iterator.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterator.h" 1
N/***************************************************************************
N *
N * _iterator.h - Iterator declarations for the Standard Library
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ITERATOR_H_INCLUDED
N#define _RWSTD_ITERATOR_H_INCLUDED
N
N#include <rw/_iterbase.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterbase.h" 1
N/***************************************************************************
N *
N * _iterbase.h - Definitions of iterator primitives
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_ITERBASE_H_INCLUDED
N#define _RWSTD_ITERBASE_H_INCLUDED
N
N#include <rw/_defs.h>
N#include _RWSTD_CSTDDEF
X#include <cstddef>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstddef" 1
N/*
N * C++ header for C header stddef.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N
N#ifndef __cstddef
N#define __cstddef
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STDDEF_NO_EXPORTS 1
N  #include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS ::std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S  /* unconditional in non-strict C for consistency of debug info */
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
S  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 201112L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
N    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
N    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 19 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstddef" 2
N  #undef __STDDEF_NO_EXPORTS
N
N  #undef __stddef_h  // later inclusion of stddef.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstddef */
N
N
L 52 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterbase.h" 2
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 24.3.1 - Iterator traits
Ntemplate <class _Iterator>
Nstruct iterator_traits
N{
N    typedef _TYPENAME _Iterator::value_type        value_type;
X    typedef typename _Iterator::value_type        value_type;
N    typedef _TYPENAME _Iterator::difference_type   difference_type;
X    typedef typename _Iterator::difference_type   difference_type;
N    typedef _TYPENAME _Iterator::pointer           pointer;
X    typedef typename _Iterator::pointer           pointer;
N    typedef _TYPENAME _Iterator::reference         reference;
X    typedef typename _Iterator::reference         reference;
N    typedef _TYPENAME _Iterator::iterator_category iterator_category;
X    typedef typename _Iterator::iterator_category iterator_category;
N};
N
N
N// 24.3.3 - Standard iterator tags
Nstruct input_iterator_tag { };
Nstruct output_iterator_tag { };
Nstruct forward_iterator_tag : public input_iterator_tag { };
Nstruct bidirectional_iterator_tag : public forward_iterator_tag { };
Nstruct random_access_iterator_tag : public bidirectional_iterator_tag { };
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<_TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef value_type*                pointer;
N    typedef value_type&                reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N
Ntemplate <class _TypeT>
Nstruct iterator_traits<const _TypeT*>
N{
N    typedef _TypeT                     value_type;
N    typedef ptrdiff_t                  difference_type;
N    typedef const value_type*          pointer;
N    typedef const value_type&          reference;
N    typedef random_access_iterator_tag iterator_category;
N};
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.2 - Basic iterator
Ntemplate <class _Category, class _TypeT,  
N          class _Distance _RWSTD_SIMPLE_DEFAULT (ptrdiff_t), 
X          class _Distance = ptrdiff_t, 
N          class _Pointer _RWSTD_SIMPLE_DEFAULT (_TypeT*), 
X          class _Pointer = _TypeT*, 
N          class _Reference _RWSTD_SIMPLE_DEFAULT (_TypeT&)>
X          class _Reference = _TypeT& >
Nstruct iterator
N{
N    typedef _TypeT     value_type;
N    typedef _Distance  difference_type;
N    typedef _Pointer   pointer;
N    typedef _Reference reference;
N    typedef _Category  iterator_category;
N};
N
N
N// returns the category of an iterator
Ntemplate <class _TypeT>
Ninline random_access_iterator_tag __iterator_category (const _TypeT*)
N{
N    return random_access_iterator_tag ();
N}
N
N
Ntemplate <class _Category, class _TypeT, class _Distance, 
N          class _Pointer, class _Reference> 
Ninline _Category
N__iterator_category (const iterator<_Category, _TypeT,
N                                    _Distance, _Pointer, _Reference>&)
N{
N    typedef _TYPENAME iterator<_Category, _TypeT, _Distance, _TypeT*,
X    typedef typename iterator<_Category, _TypeT, _Distance, _TypeT*,
N                               _TypeT&>::iterator_category _IterCategory;
N
N    return _IterCategory ();
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_input_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_bidirectional_iterator (_Tag)
N{
N    return false;
N}
N
N
Ntemplate <class _Tag>
Ninline bool __is_random_access_iterator (_Tag)
N{
N    return false;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_input_iterator (input_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (bidirectional_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_bidirectional_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N_RWSTD_SPECIALIZED_FUNCTION 
Xtemplate< > 
Ninline bool __is_random_access_iterator (random_access_iterator_tag)
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::value_type*
Xinline typename iterator_traits<_Iterator>::value_type*
N__value_type (const _Iterator*)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _TypeT*
S__value_type (const iterator<_Category, _TypeT, _Distance,
S                             _Pointer, _Reference>*)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline _TypeT* __value_type (const _TypeT* const*)
S{
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
Ntemplate <class _Iterator>
Ninline _TYPENAME iterator_traits<_Iterator>::difference_type*
Xinline typename iterator_traits<_Iterator>::difference_type*
N__distance_type (_Iterator)
N{ 
N    return 0;
N}
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Category, class _TypeT, class _Distance, 
S          class _Pointer, class _Reference>
Sinline _Distance* 
S__distance_type (iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>)
S{
S    return 0;
S}
S
Stemplate <class _TypeT>
Sinline ptrdiff_t* __distance_type (const _TypeT*)
S{ 
S    return 0;
S}
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N// 24.3.4 - Iterator operations
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __advance (_InputIterator &__it, _Distance __n, input_iterator_tag)
N{
N    _RWSTD_ASSERT (__n == 0 || __n > 0);
X    ((void)0);
N
N    while (__n > 0) {
N        --__n;
N        ++__it;
N    }
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __advance (_ForwardIterator &__it, _Distance __n,
N                       forward_iterator_tag)
N{
N    __advance (__it, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __advance (_BidirectionalIterator &__it, _Distance __n, 
N                       bidirectional_iterator_tag)
N{
N    if (__n > 0)
N        __advance (__it, __n, input_iterator_tag ());
N    else
N        while (__n) {
N            ++__n;
N            --__it;
N        }
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __advance (_RandomAccessIterator& __it, _Distance __n, 
N                       random_access_iterator_tag)
N{
N    __it += __n;
N}
N
N
N// 24.3.4, p2
Ntemplate <class _InputIterator, class _Distance>
Ninline void advance (_InputIterator& __it, _Distance __n)
N{
N    __advance (__it, __n, _RWSTD_ITERATOR_CATEGORY (_InputIterator, __it));
X    __advance (__it, __n, typename std::iterator_traits< _InputIterator > ::iterator_category ());
N}
N
N
Ntemplate <class _InputIterator, class _Distance>
Ninline void __distance (const _InputIterator &__first,
N                        const _InputIterator &__last,
N                        _Distance            &__n,
N                        input_iterator_tag)
N{
N    for (_InputIterator __it = __first; __it != __last; ++__it)
N        ++__n;
N}
N
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void __distance (const _ForwardIterator &__first,
N                        const _ForwardIterator &__last,
N                        _Distance              &__n,
N                        forward_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
Ntemplate <class _BidirectionalIterator, class _Distance>
Ninline void __distance (const _BidirectionalIterator &__first,
N                        const _BidirectionalIterator &__last, 
N                        _Distance                    &__n,
N                        bidirectional_iterator_tag)
N{
N    __distance (__first, __last, __n, input_iterator_tag ());
N}
N
N
Ntemplate <class _RandomAccessIterator, class _Distance>
Ninline void __distance (const _RandomAccessIterator &__first,
N                        const _RandomAccessIterator &__last, 
N                        _Distance                   &__n,
N                        random_access_iterator_tag)
N{
N    __n = __last - __first;
N}
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N// 24.3.4, p4
Ntemplate <class _ForwardIterator>
Ninline _TYPENAME iterator_traits<_ForwardIterator>::difference_type
Xinline typename iterator_traits<_ForwardIterator>::difference_type
Ndistance (const _ForwardIterator &__first, const _ForwardIterator &__last)
N{
N    _TYPENAME iterator_traits<_ForwardIterator>::difference_type __n = 0;
X    typename iterator_traits<_ForwardIterator>::difference_type __n = 0;
N
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N
N    return __n;
N}
N
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_EXT_VOID_DISTANCE
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline void distance (const _ForwardIterator &__first,
N                      const _ForwardIterator &__last,
N                      _Distance              &__n)
N{
N    __distance (__first, __last, __n,
N                _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N}
N
N#endif   // _RWSTD_NO_EXT_VOID_DISTANCE
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_distance: Same purpose as 3-parameter distance function, but
N// with return value.
N
Ntemplate <class _ForwardIterator, class _Distance>
Ninline _Distance
N__rw_distance (const _ForwardIterator &__first,
N               const _ForwardIterator &__last,
N               _Distance               __n)
N{
N    _STD::__distance (__first, __last, __n,
X    std::__distance (__first, __last, __n,
N                      _RWSTD_ITERATOR_CATEGORY (_ForwardIterator, __first));
X                      typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
N    return __n;
N}
N
N
N_RWSTD_NAMESPACE_END // __rw
X} 
N
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// __rw_debug_iter - iterator adapter with debugging support
S// _Iterator is either iterator or const_iterator; if the latter,
S// _MutableIterator should be iterator to allow for implicit
S// conversions from non-const (mutable) to const_iterator objects
S
S
Stemplate <class _Container, class _Iterator, class _MutableIterator>
Sclass __rw_debug_iter
S{
S    typedef _Container                                container_type;
S    typedef _Iterator                                 iterator_type;
S    typedef _STD::iterator_traits<iterator_type>      traits_type;
S
Spublic:
S
S    typedef _TYPENAME traits_type::value_type         value_type;
S    typedef _TYPENAME traits_type::difference_type    difference_type;
S    typedef _TYPENAME traits_type::reference          reference;
S    typedef _TYPENAME traits_type::pointer            pointer;
S    typedef _TYPENAME traits_type::iterator_category  iterator_category;
S
S    typedef __rw_debug_iter <container_type, _MutableIterator,
S                             _MutableIterator>        _C_mutable_iterator;
S
S    __rw_debug_iter (): _C_cont (0) { }
S
S    __rw_debug_iter (const container_type &__cont, const iterator_type &__it)
S        : _C_iter (__it), _C_cont (&__cont) { }
S
S    // no copy ctor other than the one below is defined
S    // will use a compiler generated one if _Iterator != _MutableIterator
S    __rw_debug_iter (const _C_mutable_iterator &__rhs)
S        : _C_iter (__rhs._C_iter), _C_cont (__rhs._C_cont) { }
S
S    __rw_debug_iter& operator= (const __rw_debug_iter &__rhs) {
S        if (this != &__rhs) {
S            _C_iter = __rhs._C_iter;
S            _C_cont = __rhs._C_cont;
S        }
S        return *this;
S    }
S
S    reference operator* () const {
S        _RWSTD_ASSERT (_C_is_dereferenceable ());
S        return *_C_iter;
S    }
S
S    reference operator[] (difference_type __n) const {
S        _RWSTD_ASSERT ((*this + __n)._C_is_dereferenceable ());
S        return _C_iter [__n];
S    }
S
S    _RWSTD_OPERATOR_ARROW (pointer operator-> () const);
S
S    __rw_debug_iter& operator++ () {
S        _RWSTD_ASSERT (!_C_is_end ());
S        return ++_C_iter, *this;
S    }
S
S    __rw_debug_iter& operator-- () {
S        _RWSTD_ASSERT (!_C_is_begin ());
S        return --_C_iter, *this;
S    }
S
S    __rw_debug_iter operator++ (int) {
S        __rw_debug_iter __tmp = *this;
S        return ++*this, __tmp;
S    }
S
S    __rw_debug_iter operator-- (int) {
S        __rw_debug_iter __tmp = *this;
S        return --*this, __tmp;
S    }
S
S    __rw_debug_iter& operator+= (difference_type __n) {
S        _C_iter += __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter& operator-= (difference_type __n) {
S        _C_iter -= __n;
S        _RWSTD_ASSERT (   _C_iter >= _C_cont->begin ()._C_iter
S                       && _C_iter <= _C_cont->end ()._C_iter);
S        return *this;
S    }
S
S    __rw_debug_iter operator+ (difference_type __n) const {
S        return __rw_debug_iter (*this) += __n;
S    }
S
S    __rw_debug_iter operator- (difference_type __n) const {
S        return __rw_debug_iter (*this) -= __n;
S    }
S
S    bool _C_is_begin () const {
S        return _C_cont && _C_cont->begin () == *this;
S    }
S
S    bool _C_is_end () const {
S        return _C_cont && _C_cont->end () == *this;
S    }
S
S    bool _C_is_dereferenceable () const {
S        return !_C_is_end ();
S    }
S
S    bool _C_valid_range (const __rw_debug_iter &__it) const {
S        return _C_cont && _C_cont == __it._C_cont;
S    }
S
S    const iterator_type& base () const {
S        return _C_iter;
S    }
S
S    iterator_type& base () {
S        return _C_iter;
S    }
S
S#ifndef _RWSTD_NO_MEMBER_TEMPLATES
S
S    // operators are templatized to assure const/non-const symmetry
S
S    template <class _Iter>
S    difference_type
S    operator- (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        _RWSTD_ASSERT (_C_cont && _C_cont == __rhs._C_cont);
S        return _C_iter - __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator== (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter == __rhs._C_iter;
S    }
S    
S    template <class _Iter>
S    bool
S    operator< (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter < __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator!= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter != __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator<= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter <= __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator> (const __rw_debug_iter<container_type, _Iter,
S                                     _MutableIterator> &__rhs) const {
S        return _C_iter > __rhs._C_iter;
S    }
S
S    template <class _Iter>
S    bool
S    operator>= (const __rw_debug_iter<container_type, _Iter,
S                                      _MutableIterator> &__rhs) const {
S        return _C_iter >= __rhs._C_iter;
S    }
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S    iterator_type         _C_iter;   // wrapped iterator
S    const container_type *_C_cont;   // associated container
S};
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
S
S#ifndef _RWSTD_NO_NONDEDUCED_CONTEXT
S# define _RWSTD_CONT_DIFF_TYPE _TYPENAME _Cont::difference_type 
S#else
S# define _RWSTD_CONT_DIFF_TYPE ptrdiff_t 
S#endif
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> 
Soperator+ (_RWSTD_CONT_DIFF_TYPE                               __n,
S           const _RW::__rw_debug_iter<_Cont, _Iter, _MutIter> &__x)
S{
S    return __x + __n;
S}
S
S#undef _RWSTD_CONT_DIFF_TYPE 
S
S
S#ifdef _RWSTD_NO_MEMBER_TEMPLATES
S
S// with no support for member templates namespace-scope (non-member)
S// operators must be used - these will cause ambiguities with those
S// in std::rel_ops if the latter are found during lookup
S
S
S
S// _Iter1 may differ from _Iter2 if the function operands are const
S// and non-const iterators, respectively (allows symmetry)
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline _TYPENAME _Cont::difference_type
Soperator- (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter - __y._C_iter;
S}
S    
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator== (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __x._C_iter == __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator< (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    _RWSTD_ASSERT (__x._C_cont && __x._C_cont == __y._C_cont);
S    return __x._C_iter < __y._C_iter;
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator!= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x == __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator<= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__y < __x);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator>= (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S            const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return !(__x < __y);
S}
S
Stemplate <class _Cont, class _Iter1, class _Iter2, class _MutIter>
Sinline bool
Soperator> (const _RW::__rw_debug_iter<_Cont, _Iter1, _MutIter> &__x,
S           const _RW::__rw_debug_iter<_Cont, _Iter2, _MutIter> &__y)
S{
S    return __y < __x;
S}
S
S#endif   // _RWSTD_NO_MEMBER_TEMPLATES
S
S_RWSTD_NAMESPACE_END   // std
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S
S#define _RWSTD_DEBUG_ITER(cont, it, mutit) __rw_debug_iter< cont, it, mutit >
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_valid_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S                  const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return __first._C_cont && __first._C_cont == __last._C_cont;
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_valid_range (const _Iterator &, const _Iterator &)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_in_range (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__first,
S               const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__last)
S{
S    return    __rw_valid_range (__first, __it)
S           && __rw_valid_range (__it, __last);
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_in_range (const _Iterator&, const _Iterator&, const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _Cont, class _Iter, class _MutIter>
Sinline bool
S__rw_dereferenceable (const _RWSTD_DEBUG_ITER(_Cont, _Iter, _MutIter) &__it)
S{
S    return __it._C_is_dereferenceable ();
S}
S
S
Stemplate <class _Iterator>
Sinline bool
S__rw_dereferenceable (const _Iterator&)
S{
S    return true;
S}
S
S
Stemplate <class _TypeT>
Sinline bool
S__rw_dereferenceable (const _TypeT *__ptr)
S{
S    return 0 != __ptr;
S}
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#undef _RWSTD_DEBUG_ITER
S
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N#endif   // _RWSTD_ITERBASE_H_INCLUDED
N
L 51 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_iterator.h" 2
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// Reverse iterator.     
N
N//
N//  Macros for reverse iterators to accomodate non-standard compilers
N//
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N#  define _RWSTD_ITER_TEMPLATE template <class _Iterator>
N#  define _RWSTD_ITER_ID(i)    i <_Iterator>
N#  define _RWSTD_ITER_DIFF_TYPE(i, ignore)                             \
N          _TYPENAME iterator_traits<_Iterator>::difference_type
X#  define _RWSTD_ITER_DIFF_TYPE(i, ignore)                                       _TYPENAME iterator_traits<_Iterator>::difference_type
N#else
S#  define _RWSTD_ITER_TEMPLATE                                         \
S          template <class _Iterator, class _Category, class _TypeT,    \
S                    class _Reference, class _Pointer, class _Distance>
X#  define _RWSTD_ITER_TEMPLATE                                                   template <class _Iterator, class _Category, class _TypeT,                        class _Reference, class _Pointer, class _Distance>
S#  define _RWSTD_ITER_ID(i)                                            \
S          i <_Iterator, _Category, _TypeT, _Reference, _Pointer, _Distance>
X#  define _RWSTD_ITER_ID(i)                                                      i <_Iterator, _Category, _TypeT, _Reference, _Pointer, _Distance>
S#  define _RWSTD_ITER_DIFF_TYPE(ignore, distance) distance          
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
Ntemplate <class _Iterator>
Nclass reverse_iterator
N    : public iterator<_TYPENAME iterator_traits<_Iterator>::iterator_category, 
X    : public iterator<typename iterator_traits<_Iterator>::iterator_category, 
N                      _TYPENAME iterator_traits<_Iterator>::value_type, 
X                      typename iterator_traits<_Iterator>::value_type, 
N                      _TYPENAME iterator_traits<_Iterator>::difference_type,
X                      typename iterator_traits<_Iterator>::difference_type,
N                      _TYPENAME iterator_traits<_Iterator>::pointer, 
X                      typename iterator_traits<_Iterator>::pointer, 
N                      _TYPENAME iterator_traits<_Iterator>::reference>
X                      typename iterator_traits<_Iterator>::reference>
N{
N    typedef iterator_traits<_Iterator>  traits_type;
Npublic:
N    typedef _TYPENAME traits_type::difference_type difference_type;
X    typedef typename traits_type::difference_type difference_type;
N    typedef _TYPENAME traits_type::value_type value_type;
X    typedef typename traits_type::value_type value_type;
N    typedef _TYPENAME traits_type::pointer pointer;
X    typedef typename traits_type::pointer pointer;
N    typedef _TYPENAME traits_type::reference reference;
X    typedef typename traits_type::reference reference;
N
N#else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
Stemplate <class _Iterator, class _Category, class _TypeT,
S          class _Reference _RWSTD_COMPLEX_DEFAULT (_TypeT&), 
S          class _Pointer _RWSTD_COMPLEX_DEFAULT (_TypeT*), 
S          class _Distance _RWSTD_COMPLEX_DEFAULT (ptrdiff_t)>
Sclass reverse_iterator
S    : public iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>
S
S{
Spublic:
S    typedef _Distance  difference_type;
S    typedef _TypeT     value_type;
S    typedef _Reference reference;
S    typedef _Pointer   pointer;
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N    typedef _Iterator iterator_type;
N
N    reverse_iterator () { }
N
N    _EXPLICIT reverse_iterator (iterator_type __rhs) : current (__rhs) { }
X    explicit reverse_iterator (iterator_type __rhs) : current (__rhs) { }
N 
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N#  ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N
N      template <class _TypeU>
N      reverse_iterator (const reverse_iterator<_TypeU>& __rhs)
N          : current (__rhs.base ()) { }
N
N#  else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
S
S      template <class _Iterator2, class _Category2, class _TypeU,
S                class _Reference2, class _Pointer2, class _Distance2>
S      reverse_iterator (const reverse_iterator<_Iterator2, _Category2, _TypeU,
S                        _Reference2, _Pointer2, _Distance2>& __rhs)
S          : current (__rhs.base ()) { }
S
N#  endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC 
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    iterator_type base () const {
N        return current;
N    }
N
N    reference operator* () const {
N        iterator_type __tmp = base ();
N        return *--__tmp;
N    }
N
N    _RWSTD_OPERATOR_ARROW (pointer operator->() const);
X    pointer operator->() const { return & * *this; };
N
N    reverse_iterator& operator++ () {
N        return --current, *this;
N    }
N
N    reverse_iterator operator++ (int) {
N        reverse_iterator __tmp = *this;
N        ++*this;
N        return __tmp;
N    }
N
N    reverse_iterator& operator-- () {
N        return ++current, *this;
N    }
N
N    reverse_iterator operator-- (int) {
N        reverse_iterator __tmp = *this;
N        --*this;
N        return __tmp;
N    }
N
N    reverse_iterator& operator+= (difference_type __n) {
N        return current -= __n, *this;
N    }
N
N    reverse_iterator& operator-= (difference_type __n) {
N        return *this += -__n;
N    }
N
N    reverse_iterator operator+ (difference_type __n) const {
N        return reverse_iterator (*this) += __n;
N    }
N
N    reverse_iterator operator- (difference_type __n) const {
N        return reverse_iterator (*this) -= __n;
N    }
N
N    reference operator[] (difference_type __n) const {
N        return *(*this + __n);
N    }
N
Nprotected:
N
N    iterator_type current;
N};
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator== (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator== (const reverse_iterator <_Iterator> & __x,
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return __x.base () == __y.base ();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator< (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator< (const reverse_iterator <_Iterator> & __x,
N                       const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                       const reverse_iterator <_Iterator> & __y)
N{
N    return __y.base() < __x.base();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator!= (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator!= (const reverse_iterator <_Iterator> & __x, 
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__x == __y);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator> (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator> (const reverse_iterator <_Iterator> & __x, 
N                       const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                       const reverse_iterator <_Iterator> & __y)
N{
N    return __y < __x;
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator<= (const _RWSTD_ITER_ID (reverse_iterator)& __x,
Xinline bool operator<= (const reverse_iterator <_Iterator> & __x,
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__y < __x);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline bool operator>= (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xinline bool operator>= (const reverse_iterator <_Iterator> & __x, 
N                        const _RWSTD_ITER_ID (reverse_iterator)& __y)
X                        const reverse_iterator <_Iterator> & __y)
N{
N    return !(__x < __y);
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline _RWSTD_ITER_DIFF_TYPE (_Iterator, _Distance)
Xinline typename iterator_traits<_Iterator> ::difference_type
Noperator- (const _RWSTD_ITER_ID (reverse_iterator)& __x, 
Xoperator- (const reverse_iterator <_Iterator> & __x, 
N           const _RWSTD_ITER_ID (reverse_iterator)& __y)
X           const reverse_iterator <_Iterator> & __y)
N{
N    return __y.base () - __x.base ();
N}
N
N
N_RWSTD_ITER_TEMPLATE
Xtemplate <class _Iterator>
Ninline _RWSTD_ITER_ID (reverse_iterator)
Xinline reverse_iterator <_Iterator>
Noperator+ (_RWSTD_ITER_DIFF_TYPE (_Iterator, _Distance) __n, 
Xoperator+ (typename iterator_traits<_Iterator> ::difference_type __n, 
N           const _RWSTD_ITER_ID (reverse_iterator)&     __x)
X           const reverse_iterator <_Iterator> &     __x)
N{
N    return __x + __n;
N}
N
N#undef _RWSTD_ITER_DIFF_TYPE
N
N#ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC
S
S_RWSTD_NAMESPACE_END   // std
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// Reverse bidirectional iterator.       
S// This is needed to get around non-standard compilers that insist
S// on instantiating all members of a class whether they're used 
S// or not.
S
Stemplate <class _Iterator, class _Category, class _TypeT, 
S          class _Reference _RWSTD_COMPLEX_DEFAULT (_TypeT&), 
S          class _Pointer _RWSTD_COMPLEX_DEFAULT (_TypeT*), 
S          class _Distance _RWSTD_COMPLEX_DEFAULT (ptrdiff_t) >
Sclass __reverse_bi_iterator
S    : public _STD::iterator<_Category, _TypeT, _Distance, _Pointer, _Reference>
S{
Spublic:
S    typedef _Distance  difference_type;
S    typedef _TypeT     value_type;
S    typedef _Reference reference;
S    typedef _Pointer   pointer;
S    typedef _Iterator  iterator_type;
S
S    __reverse_bi_iterator () { }
S
S    _EXPLICIT __reverse_bi_iterator (const iterator_type &__rhs) 
S        : current (__rhs) { }
S
S
S#ifndef _RWSTD_NO_MEMBER_TEMPLATES
S#  ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
S
S      template <class _TypeU>
S      __reverse_bi_iterator (const __reverse_bi_iterator<_TypeU>& __rhs)
S          : current (__rhs.base ()) { }
S
S#  else   // if defined (_RWSTD_NO_CLASS_PARTIAL_SPEC )
S
S      template <class _Iterator2, class _Category2, class _TypeU,
S                class _Reference2, class _Pointer2, class _Distance2>
S      __reverse_bi_iterator (const __reverse_bi_iterator<_Iterator2,
S                                                         _Category2,
S                                                         _TypeU,
S                                                         _Reference2,
S                                                         _Pointer2,
S                                                         _Distance2>& __rhs)
S          : current (__rhs.base ()) { }
S#  endif
S#endif // _RWSTD_NO_MEMBER_TEMPLATES
S
S
S    iterator_type base () const {
S        return current;
S    }
S
S    reference operator* () const {
S        iterator_type __tmp = base ();
S        return *--__tmp;
S    }
S
S    _RWSTD_OPERATOR_ARROW (pointer operator->() const);
S
S    __reverse_bi_iterator& operator++ () {
S        return --current, *this;
S    }
S
S    __reverse_bi_iterator  operator++ (int) {
S        __reverse_bi_iterator __tmp (*this);
S        ++*this;
S        return __tmp;
S    }
S
S    __reverse_bi_iterator& operator-- () {
S        return ++current, *this;
S    }
S
S    __reverse_bi_iterator operator-- (int) {
S        __reverse_bi_iterator __tmp (*this);
S        --*this;
S        return __tmp;
S    }
S
Sprotected:
S
S    iterator_type current;
S};
S
S
S_RWSTD_ITER_TEMPLATE
Sinline bool operator== (const _RWSTD_ITER_ID (__reverse_bi_iterator)& __x, 
S                        const _RWSTD_ITER_ID (__reverse_bi_iterator)& __y)
S{
S    return __x.base () == __y.base ();
S}
S
S
S_RWSTD_ITER_TEMPLATE
Sinline bool operator!= (const _RWSTD_ITER_ID (__reverse_bi_iterator)& __x,
S                        const _RWSTD_ITER_ID (__reverse_bi_iterator)& __y)
S{
S    return !(__x == __y);
S}
S
S#undef _RWSTD_ITER_TEMPLATE
S#undef _RWSTD_ITER_ID
S
S_RWSTD_NAMESPACE_END   // __rw
S
S_RWSTD_NAMESPACE_BEGIN (std)
S
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC
N#  define _RWSTD_INSERT_ITERATOR_BASE(ignore)       \
N          iterator<output_iterator_tag, void, void, void, void>
X#  define _RWSTD_INSERT_ITERATOR_BASE(ignore)                 iterator<output_iterator_tag, void, void, void, void>
N#else
S   // necessary to allow __iterator_category, __value_type, etc. to work
S#  define _RWSTD_INSERT_ITERATOR_BASE(cont)         \
S          iterator<output_iterator_tag,             \
S                   _TYPENAME cont::value_type,      \
S                   _TYPENAME cont::difference_type, \
S                   _TYPENAME cont::pointer,         \
S                   _TYPENAME cont::reference>
X#  define _RWSTD_INSERT_ITERATOR_BASE(cont)                   iterator<output_iterator_tag,                                _TYPENAME cont::value_type,                         _TYPENAME cont::difference_type,                    _TYPENAME cont::pointer,                            _TYPENAME cont::reference>
N#endif   // _RWSTD_NO_CLASS_PARTIAL_SPEC
N
N
Ntemplate <class _Container>
Nclass back_insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass back_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    _EXPLICIT back_insert_iterator (container_type& __rhs)
X    explicit back_insert_iterator (container_type& __rhs)
N        : container (&__rhs) { }
N
N    back_insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) {
X    operator= (typename container_type::const_reference __x) {
N        return container->push_back (__x), *this;
N    }
N
N    back_insert_iterator& operator*  () {
N        return *this;
N    }
N
N    back_insert_iterator& operator++ () {
N        return *this;
N    }
N
N    back_insert_iterator operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    container_type* container;
N};
N
N
Ntemplate <class _Container>
Ninline back_insert_iterator<_Container> back_inserter (_Container& __x)
N{
N    return back_insert_iterator<_Container>(__x);
N}
N
N
Ntemplate <class _Container>
Nclass front_insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass front_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    _EXPLICIT front_insert_iterator (container_type& __rhs)
X    explicit front_insert_iterator (container_type& __rhs)
N        : container (&__rhs) { }
N
N    front_insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) { 
X    operator= (typename container_type::const_reference __x) { 
N        return container->push_front (__x), *this;
N    }
N
N    front_insert_iterator& operator* () {
N        return *this;
N    }
N
N    front_insert_iterator& operator++ () {
N        return *this;
N    }
N
N    front_insert_iterator operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    container_type* container;
N};
N
N
Ntemplate <class _Container>
Ninline front_insert_iterator<_Container> front_inserter (_Container& __x)
N{
N    return front_insert_iterator<_Container>(__x);
N}
N
N
Ntemplate <class _Container>
Nclass insert_iterator: public _RWSTD_INSERT_ITERATOR_BASE (_Container)
Xclass insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
N{
Npublic:
N    typedef _Container container_type;
N
N    insert_iterator (container_type                    &__x,
N                     _TYPENAME container_type::iterator __it)
X                     typename container_type::iterator __it)
N      : iter (__it), container (&__x) { }
N
N    insert_iterator&
N    operator= (_TYPENAME container_type::const_reference __x) { 
X    operator= (typename container_type::const_reference __x) { 
N        iter = container->insert (iter, __x);
N        return ++iter, *this;
N    }
N
N    insert_iterator& operator* () {
N        return *this;
N    }
N
N    insert_iterator& operator++ () {
N        return *this;
N    }
N
N    insert_iterator& operator++ (int) {
N        return *this;
N    }
N
Nprotected:
N
N    _TYPENAME container_type::iterator iter;
X    typename container_type::iterator iter;
N    container_type*                    container;
N};
N
N
Ntemplate <class _Container, class _Iterator>
Ninline insert_iterator<_Container> inserter (_Container& __x, _Iterator __it)
N{
N    typedef _TYPENAME _Container::iterator _Iter;
X    typedef typename _Container::iterator _Iter;
N
N    return insert_iterator<_Container> (__x, _Iter (__it));
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N#endif   // _RWSTD_ITERATOR_H_INCLUDED
N
L 40 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N#include <rw/_strref.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_strref.h" 1
N/***************************************************************************
N *
N * _strref.h - Declarations for the Standard Library string_ref classes
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_STRREF_H_INCLUDED
N#define _RWSTD_STRREF_H_INCLUDED
N
N#include <memory>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 1
N// -*- C++ -*-
N/***************************************************************************
N *
N * memory - declarations for the Standard Library memory implementation
N *
N * $Id$ 
N *
N ***************************************************************************
N *
N * Copyright (c) 1994
N * Hewlett-Packard Company
N *
N * Permission to use, copy, modify, distribute and sell this software
N * and its documentation for any purpose is hereby granted without fee,
N * provided that the above copyright notice appear in all copies and
N * that both that copyright notice and this permission notice appear
N * in supporting documentation.  Hewlett-Packard Company makes no
N * representations about the suitability of this software for any
N * purpose.  It is provided "as is" without express or implied warranty.
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/ 
N
N#ifndef _RWSTD_MEMORY_INCLUDED
N#define _RWSTD_MEMORY_INCLUDED
N
N#include <new>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 1
N/*
N * C++ Library file new
N * Copyright 1993-2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N/* Edison Design Group, 1992-2013. */
N/*
Nnew -- Include file for C++ default operator new (see ARM 12.5).
N*/
N
N#ifndef __NEW_STDH
N#define __NEW_STDH
N#ifndef __STDDEF_H
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
S  #define __STDDEF_DECLS
S    #undef __CLIBNS
S    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
S    #else
S      #define __CLIBNS
S    #endif  /* __cplusplus */
S
S#if __sizeof_ptr == 8
S  typedef signed long ptrdiff_t;
S#else
S  typedef signed int ptrdiff_t;
S#endif
S
S#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
S /* unconditional in C++ and non-strict C for consistency of debug info */
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
S#endif
S
S#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
S  #if !defined(__STRICT_ANSI__)
S  /* unconditional in non-strict C for consistency of debug info */
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
S  #endif
S#endif
S
S#undef NULL  /* others (e.g. <stdio.h>) also define */
S#define NULL 0
S   /* null pointer constant. */
S
S#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
S#else
S  /* EDG uses __INTADDR__ to avoid errors when strict */
S  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
S#endif
S
S#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S  typedef long double max_align_t;
S#endif
S
S    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
S    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
N    #ifndef __STDDEF_NO_EXPORTS
N      using ::std::size_t;
N      using ::std::ptrdiff_t;
N      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X      #if !0L || (1L && 201103L <= 199711L)
N        using ::std::max_align_t;
N      #endif
N    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 21 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 2
N#endif  /* ifndef __STDDEF_H */
N#ifndef __NEW
N#define __NEW
N#define __ARMCLIB_VERSION 5060037
N
N#ifndef __EXCEPTION_INCLUDED
N#include <exception>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\exception" 1
N/*
N * C++ Library file exception
N * Copyright 2001 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __EXCEPTION_INCLUDED
N#define __EXCEPTION_INCLUDED
N#define __ARMCLIB_VERSION 5060037
N
N/* Edison Design Group, 1995-2005. */
N/*
Nexception -- Include file for exception handling (see 18.6)
N*/
N
Nnamespace std {
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class exception {
N  public:
N    exception() throw();
N    exception(const exception&) throw();
N    exception& operator=(const exception&) throw();
N    virtual ~exception() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_exception : public exception {
N  public:
N    bad_exception() throw();
N    bad_exception(const bad_exception&) throw();
N    bad_exception& operator=(const bad_exception&) throw();
N    virtual ~bad_exception() throw();
N    virtual const char* what() const throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*terminate_handler)();
N  extern terminate_handler set_terminate(terminate_handler) throw();
N
N  typedef void (*unexpected_handler)();
N  extern unexpected_handler set_unexpected(unexpected_handler) throw();
N
N  void terminate();
N  void unexpected();
N
N  extern bool uncaught_exception() throw();
N
N}  /* namespace std */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __EXCEPTION_INCLUDED */
N
L 28 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\new" 2
N#endif /* __EXCEPTION_INCLUDED */
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
Nnamespace std {
N#endif /* if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__ */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef unsigned long size_t;   /* see <stddef.h> */
N#else
N  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N/* This lets users disable the EDG supplied exception classes. */
N#ifndef __NO_EDG_EXCEPTION_CLASSES
N
N  class bad_alloc : public exception {
N  public:
N    bad_alloc() throw();
N    bad_alloc(const bad_alloc&) throw();
N    bad_alloc& operator=(const bad_alloc&) throw();
N    virtual ~bad_alloc() throw();
N    virtual const char* what() const throw();
N  };
N
N  class bad_array_new_length : public bad_alloc {
N  public:
N    bad_array_new_length() throw();
N    virtual ~bad_array_new_length() throw();
N  };
N
N#endif /* ifndef __NO_EDG_EXCEPTION_CLASSES */
N
N  typedef void (*new_handler)();
N  new_handler set_new_handler(new_handler) throw();
N  struct nothrow_t { };
N  // Declaration of object nothrow to permit the use of the placement new
N  // syntax: new (nothrow) T;
N  extern const nothrow_t nothrow;
N
N#if defined(__EDG_RUNTIME_USES_NAMESPACES) || __clang__
X#if 1L || __clang__
N}  /* namespace std */
N#endif /* __EDG_RUNTIME_USES_NAMESPACES || __clang__ */
N
N#ifdef __EDG_IMPLICIT_USING_STD
S/* Implicitly include a using directive for the STD namespace when this
S   preprocessing flag is TRUE. */
Susing namespace ::std;
N#endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N/* Normal operator new. */
Nvoid *operator new(std::size_t) throw(std::bad_alloc);
N
N/* Normal operator delete. */
Nvoid operator delete(void*) throw ();
N
N/* Nothrow version of operator new. */
Nvoid *operator new(std::size_t, const std::nothrow_t&) throw();
N
N/* Nothrow version of operator delete. */
Nvoid operator delete(void*, const std::nothrow_t&) throw();
N
N/* Placement new. */
Ninline void *operator new(std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement delete. */
Ninline void operator delete(void*, void*) throw() { /* nothing */ }
N
N
N/* Array new. */
Nvoid *operator new[](std::size_t) throw(std::bad_alloc);
N
N/* Array delete. */
Nvoid operator delete[](void*) throw ();
N
N/* Placement array new. */
Ninline void *operator new[](std::size_t, void* __ptr) throw() { return __ptr; }
N
N/* Placement array delete. */
Ninline void operator delete[](void*, void*) throw() { /* nothing */ }
N
N/* Nothrow version of array new. */
Nvoid *operator new[](std::size_t,
N                     const std::nothrow_t&) throw();
N
N/* Nothrow version of array delete. */
Nvoid operator delete[](void*,
N                       const std::nothrow_t&) throw();
N
N#endif /*__NEW */
N/* End of new */
N
N#endif /*__NEW_STDH */
L 49 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <utility>
N
N#include <rw/_iterbase.h>
N#include <rw/_mutex.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_mutex.h" 1
N/***************************************************************************
N *
N * _mutex.h - Definitions of classes and inline functions providing MT safety
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************
N *
N * There are two mutex classes:
N *
N * __rw::__rw_mutex_base - a POD-type class with no ctor or dtor (POSIX
N * and Solaris threads only) suitable for mutex objects with static storage
N * duration. On POSIX threads, these objects are fully constructed at static
N * initialization time and initialized via assignment by 
N * PTHREAD_MUTEX_INITIALIZER, while on Solaris threads they do not need to be
N * initialized at all. On platforms such as Win32/64 that do not support static
N * initialization this class does define a ctor that initializes the object
N * by the appropriate thread library call.
N *
N * __rw::__rw_mutex - a non-POD-type class derived from __rw::__rw_mutex_base
N * with explicitly defined ctor and dtor suitable for mutex member variables.
N * On platforms such as Win32/64 that do not support static initialization this
N * class does not define its own ctor and dtor and simply defers the
N * initialization and destruction to its base.
N *
N * __rw::__rw_static_mutex<> - a POD-type class template, defined on
N * platforms such as POSIX or Solaris threads that support static
N * initialization of mutexes, containing a single public static data member
N * of the __rw::__rw_mutex_base class. The static member object is returned
N * from the factory function template __rw::__rw_get_static_mutex<>().
N *
N * On platforms such as Win32/64 that do not support static initialization
N * of mutex objects the factory template function
N * __rw::__rw_get_static_mutex<>() defines and dynamically initializes
N * a static local reference to an object of the __rw::__rw_mutex_base class.
N * The dynamic initialization is done in an MT-safe way (i.e., such that
N * exactly one initialization of the mutex object is guaranteed). On Win32/64
N * this is accomplished by making use of the InterlockedIncrement() API call,
N * everywhere else there exists a small potential for a race condition and
N * the risk of the object being initialized multiple times. The reference is
N * initialized to refer to a properly aligned static data buffer to prevent
N * the destruction of the actual object at program termination, and the object
N * itself is constructed in this buffer space via a call to placement new.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_MUTEX_H_INCLUDED
N#define _RWSTD_MUTEX_H_INCLUDED
N
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTRING
X#include <cstring>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 1
N/*
N * C++ header for C header string.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstring
N#define __cstring
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STRING_NO_EXPORTS 1
N  #include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N        namespace std {
N        #define __CLIBNS std::
N        extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 1L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
X#elif !0L
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Nextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
Nextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Nextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
N    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Sextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strchr(char * __s, int __c)
N    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
N    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) const char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
Nextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Nextern "C++" inline char *strrchr(char * __s, int __c)
N    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Sextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Nextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) const char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
Nextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Nextern "C++" inline char *strstr(char * __s1, const char * __s2)
N    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Sextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
N    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstring" 2
N  #undef __STRING_NO_EXPORTS
N
N  #undef __string_h  // later inclusion of string.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N  
N#endif /* __cstring */
N
L 78 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_mutex.h" 2
N
N#ifdef _RWSTD_MULTI_THREAD
S
S
S#include <rw/_exception.h>
S
S
S#if defined (_RWSTD_SOLARIS_THREADS)  // assuming Solaris 2.1 or greater
S
S// SunOS 5.7 Threads Library:
S//   "A statically  allocated  mutex does  not  need to be explicitly
S//   initialized; by default, a statically allocated mutex is initialized
S//   with  all  zeros and its scope is set to be within the calling
S//   process."
S
S#  include <synch.h>
S#  include <thread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      mutex_init (&mutex, USYNC_THREAD, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                mutex_t
S
S#elif defined (_RWSTD_POSIX_D10_THREADS)
S
S// LinuxThreads man page:
S//   "Variables of type pthread_mutex_t can also be initialized
S//    statically, using the constants  PTHREAD_MUTEX_INITIALIZER
S//    (for fast mutexes), PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
S//    (for recursive mutexes), and PTHREAD_ERRORCHECK_MUTEX_INI-
S//    TIALIZER_NP (for error checking mutexes)."
S//    ...
S//    "Attempting to initialize an already initialized mutex results
S//    in undefined behavior."
S
S#  include <pthread.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex)      pthread_mutex_init (&mutex, 0)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S#elif defined (_RWSTD_DCE_THREADS)
S
S#  if defined (_RWSTD_NO_DCE_PTHREAD_H)
S#    include <pthread.h>
S#  else
S#    include <dce/pthread.h>
S#  endif
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          pthread_mutex_init (&mutex, pthread_mutexattr_default)
X#  define _RWSTD_MUTEX_INIT(mutex)           pthread_mutex_init (&mutex, pthread_mutexattr_default)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   pthread_mutex_destroy (&mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex)      pthread_mutex_lock (&mutex)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    pthread_mutex_unlock (&mutex)
S#  define _RWSTD_MUTEX_T                pthread_mutex_t
S
S// DCE doesn't seem to support static mutex initialization
S#  include <new>
S
S#elif defined (_WIN32) || defined (_WIN64)
S
S#  ifdef _RWSTD_NO_FWD_DECLARATIONS
S
S#    include <windows.h>
S#    define _RWSTD_MUTEX_T _RTL_CRITICAL_SECTION
S
S#  else   // if defined (_RWSTD_NO_FWD_DECLARATIONS)
S
S   // avoid #including this header...
S   // #  include <windows.h>
S
Sextern "C" {
S
S// but rather declare these globals here
Sstruct _RTL_CRITICAL_SECTION;
S
S__declspec (dllimport) void __stdcall
SInitializeCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SEnterCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SLeaveCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) void __stdcall
SDeleteCriticalSection (_RTL_CRITICAL_SECTION*);
S
S__declspec (dllimport) long __stdcall
SInterlockedIncrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedDecrement (long*);
S
S__declspec (dllimport) long __stdcall
SInterlockedExchange (long*, long);
S
S}   // extern "C"
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// fake critical section type
Sunion __rw_critical_section {
S    long _C_pad;   // force alignment
S    char _C_buf [24 /* == sizeof (_RTL_CRITICAL_SECTION) */];
S};
S
S#    define _RWSTD_MUTEX_T _RW::__rw_critical_section
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
S#  endif   // _RWSTD_NO_FWD_DECLARATIONS
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// Win32/64 throws non-C++ exceptions rather than returning error status
S// from some system calls like most other operating systems do
S
Sinline int __rw_mutex_init (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        InitializeCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_destroy (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        DeleteCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_lock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        EnterCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
Sinline int __rw_mutex_unlock (_RTL_CRITICAL_SECTION *__mutex)
S{
S    __try {
S        LeaveCriticalSection (__mutex);
S    }
S    __except (1) {
S        return -1;
S    }
S    return 0;
S}
S
S#  define _RWSTD_MUTEX_INIT(mutex)      \
S   __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_INIT(mutex)         __rw_mutex_init (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_DESTROY(mutex)   \
S   __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_DESTROY(mutex)      __rw_mutex_destroy (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_LOCK(mutex)      \
S   __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_LOCK(mutex)         __rw_mutex_lock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    \
S   __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
X#  define _RWSTD_MUTEX_UNLOCK(mutex)       __rw_mutex_unlock (_RWSTD_REINTERPRET_CAST (_RTL_CRITICAL_SECTION*, &mutex))
S
S_RWSTD_NAMESPACE_END   // __rw
S
S#elif defined (__OS2__)
S
S#  define INCL_DOSSEMAPHORES
S
S#  include <os2.h>
S
S#  define _RWSTD_MUTEX_INIT(mutex) \
S          DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
X#  define _RWSTD_MUTEX_INIT(mutex)           DosCreateMutexSem (0, &mutex, DC_SEM_SHARED,FALSE)
S#  define _RWSTD_MUTEX_DESTROY(mutex)   DosCloseMutexSem (mutex)
S#  define _RWSTD_MUTEX_LOCK(mutex) \
S          DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
X#  define _RWSTD_MUTEX_LOCK(mutex)           DosRequestMutexSem (mutex, SEM_INDEFINITE_WAIT)
S#  define _RWSTD_MUTEX_UNLOCK(mutex)    DosReleaseMutexSem (mutex)
S#  define _RWSTD_MUTEX_T                HMTX
S
S#else
S#  error unknown thread environment
S#endif
S
S
S#if defined (__DECCXX)
S   // get declarations of __ATOMIC_XXX intrinsics
S
S#  include <machine/builtins.h>
S
S#endif   // __DECXX
S
S
S#if defined (__GNUG__) && defined (__osf__)
S   // prevent g++ warnings about missing initializers
S   // see <pthread.h> for explanation of _PTHREAD_NOMETER_STATIC
S#  ifndef _PTHREAD_NOMETER_STATIC
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER \
S            { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA, \
S              0, 0, 0, 0, 0, 0 }
X#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER             { _PTHREAD_MSTATE_SLOW, _PTHREAD_MVALID | _PTHREAD_MVF_STA,               0, 0, 0, 0, 0, 0 }
S#  else   // if defined (_PTHREAD_NOMETER_STATIC)
S#    define _RWSTD_PTHREAD_MUTEX_INITIALIZER
S            { 0, _PTHREAD_MVALID | _PTHREAD_MVF_STA, 0, 0, 0, 0, 0, 0 }
S#  endif   // _PTHREAD_NOMETER_STATIC
S#elif defined (__GNUG__) && defined (__sgi__)
S   // prevent g++ warnings about a partly bracketed initializer
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER }
S#else
S#  define _RWSTD_PTHREAD_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
S#endif
S
S
S_RWSTD_NAMESPACE_BEGIN (__rw)
S
S// a using declaration (rather than a directive)
S// used to work around yet another MSVC 6.0 bug
S_USING (std::exception);
S
Sclass __rw_thread_error : public exception
S{
Spublic:
S    __rw_thread_error () _THROWS (())
S    : exception () { }
S
S    virtual const char* what () const _THROWS (()) {
S        return "thread synchronization error";
S    }
S};                            
S
S
S// POD type with no user-defined ctor or dtor facilitates static
S// initialization of mutex objects with static storage duration
S// (important during library initialziation time)
Sclass _RWSTD_EXPORT __rw_mutex_base
S{
Spublic:
S
S    void _C_acquire () {
S#if !defined (__HP_aCC) || __HP_aCC > 32700
S        if (0 != _RWSTD_MUTEX_LOCK (_C_mutex))
S            _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR,
S                             "synchronization error");
S#else
S        // working around an HP aCC 3.27 bug JAGac88738
S        _RWSTD_MUTEX_LOCK (_C_mutex);
S#endif   // !defined (__HP_aCC) || __HP_aCC > 32700
S    }
S
S    void _C_release ();
S
S#ifdef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    // static initialization not an option, define ctor and dtor
S    // and make member mutex private
S
S    __rw_mutex_base ();
S
S    ~__rw_mutex_base ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex_base (const __rw_mutex_base&);
S    __rw_mutex_base& operator= (const __rw_mutex_base&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S    _RWSTD_MUTEX_T _C_mutex;   // the real thing
S};
S
S
Sinline void __rw_mutex_base::_C_release ()
S{
S    // we should NOT throw from here as _C_release will typically be called
S    // during the destruction of local objects such as __rw_guard (perhaps
S    // due to another exception)
S    _RWSTD_MUTEX_UNLOCK (_C_mutex);
S}
S
S
S// non-POD type, always initializes mutex data member via a function call
Sclass  _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
S{
Spublic:
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S    __rw_mutex ();
S
S    ~__rw_mutex ();
S
Sprivate:
S
S    // not defined
S    __rw_mutex (const __rw_mutex&);
S    __rw_mutex& operator= (const __rw_mutex&);
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S
S};
S
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
S// helper factory class - static member is guranteed to be constructed
S// during static initialization; objects of this POD class are not
S// destroyed during program termination (important to allow them
S// to be used in dtors of other objects with static storage duration)
Stemplate <class _TypeT>
Sstruct __rw_static_mutex
S{
S    static __rw_mutex_base _C_mutex;
S};
S
S
Stemplate <class _TypeT>
S__rw_mutex_base __rw_static_mutex<_TypeT>::_C_mutex
S
S#ifdef _RWSTD_POSIX_D10_THREADS
S
S    = { _RWSTD_PTHREAD_MUTEX_INITIALIZER }
S
S#endif   // _RWSTD_POSIX_D10_THREADS
S        ;
S
S// explicitly instantiated to work around a g++ 2.95.2 bug on COFF systems
S// (such as IBM AIX or DEC OSF1) where it "forgets" to do so implicitly for
S// explicitly initialized static data members
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<int>);
S_RWSTD_INSTANTIATE_1 (class _RWSTD_EXPORT __rw_static_mutex<size_t>);
S
S
Sinline __rw_mutex::__rw_mutex ()
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::__rw_mutex_base ()
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{ 
S    if (0 != _RWSTD_MUTEX_INIT (_C_mutex))
S        _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR, "synchronization error");
S}
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Sinline __rw_mutex::~__rw_mutex () 
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
Sinline __rw_mutex_base::~__rw_mutex_base () 
S
S#endif   // _RWSTD_NO_STATIC_MUTEX_INIT
S{
S    _RWSTD_MUTEX_DESTROY (_C_mutex);
S}
S
S
S// mutex factory function avoids problematic initialization dependencies
S// introduced by definitions of mutexes with static storage duration
S// instead of defining a static mutex member that may not be initialized
S// before first use, a non-local class may either declare a unique type
S// (enum or class) or use itself as this type, and call this template
S// function with a ptr to that type to obtain an initialized mutex object
S// that is the same for each unique type passed to the function
S
S#ifndef _RWSTD_NO_STATIC_MUTEX_INIT
S
Stemplate <class _TypeT>
Sinline
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S{
S    // POD mutex already initialized during static initialization
S    return __rw_static_mutex<_TypeT>::_C_mutex;
S}
S
S#else   // if defined (_RWSTD_NO_STATIC_MUTEX_INIT)
S
S#ifdef _INLINE_WITH_STATICS
S
Stemplate <class _TypeT>
S_INLINE_WITH_STATICS
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#else    // if !defined (_INLINE_WITH_STATICS)
S
Stemplate <class _TypeT>
S__rw_mutex_base& __rw_get_static_mutex (_TypeT*)
S
S#endif   // _INLINE_WITH_STATICS
S
S{
S    // allocate properly aligned memory for static mutex (necessary
S    // to prevent static local mutex from being destroyed during
S    // program termination)
S    union __mutex_buf_t {
S        long double __pad;   // force alignment (must be first)
S        char        __buf [sizeof (__rw_mutex_base)];
S    };
S
S    // using a named union to work around a bug in HP aCC 3.14.10 (JAGad03246)
S    static __mutex_buf_t __mutex_buf;
S
S    // initialize mutex reference to refer to the static buffer space
S    __rw_mutex_base &__mutex =
S        _RWSTD_REINTERPRET_CAST (__rw_mutex_base&, __mutex_buf);
S
S    // keep track of number of mutex initialization attempts
S    // although `init' may reach a value greater than 1, `mutex'
S    // will (should) never be multiply initialized
S
S    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
S    // sorry: semantics of inline function static data are wrong (you'll wind
S    // up with multiple copies)
S    static volatile long __cntr /* = 0 */;   // initialization counter
S
S#if defined (_WIN32) || defined (_WIN64)
S    // MT safe
S    if (0 == __cntr && 1 == InterlockedIncrement ((long*)&__cntr))
S#else
S    // not so safe (volatile should help)
S    if (0 == __cntr && 1 == ++__cntr)
S#endif   // _WIN32
S
S    {
S        // manually initialize `mutex' via a call to placement new
S        new (&__mutex) __rw_mutex_base ();
S
S        // indicate that `mutex' has been fully initialized
S        // (unlikely that we'll have more than 1000 threads)
S        __cntr += 1000;
S    }
S    else
S        // busywait until `mutex' has been completely initialized
S        while (__cntr < 1000);
S
S    return __mutex;
S}
S
S#endif   //_RWSTD_NO_STATIC_MUTEX_INIT
S
S
S// clean up
S#undef _RWSTD_MUTEX_LOCK
S#undef _RWSTD_MUTEX_UNLOCK
S#undef _RWSTD_MUTEX_T
S
S
S// allows safe use of a mutex in the presence of exceptions
Sclass __rw_guard
S{
S    __rw_mutex_base *_C_mutex;
S
S    // undefined
S    __rw_guard& operator= (const __rw_guard&);
S    
Spublic:
S
S    __rw_guard (__rw_guard &__rhs)
S        : _C_mutex (__rhs._C_mutex) {
S        __rhs._C_mutex = 0;
S    }
S
S    __rw_guard (__rw_mutex_base &__mutex): _C_mutex (&__mutex) {
S        _C_mutex->_C_acquire ();
S    }
S
S    __rw_guard (__rw_mutex_base *__mutex): _C_mutex (__mutex) {
S        if (_C_mutex)
S            _C_mutex->_C_acquire ();
S    }
S
S    ~__rw_guard () {
S        if (_C_mutex)
S            _C_mutex->_C_release ();
S    }
S
S    __rw_mutex_base* _C_set (__rw_mutex_base *__mutex) {
S        __rw_mutex_base *__tmp = _C_mutex;
S        return _C_mutex = __mutex, __tmp;
S    }
S};
S
S
S// base class for obects required to guarantee some degree of MT safety
Sstruct _RWSTD_EXPORT __rw_synchronized
S{
S    __rw_mutex _C_mutex;
S
S    void _C_lock () {
S        _C_mutex._C_acquire ();
S    }
S
S    void _C_unlock () {
S        _C_mutex._C_release ();
S    }
S
S    __rw_guard _C_guard () {
S        __rw_guard __guard (_C_mutex);
S        return __guard;
S    }
S};
S
S
S// helper functions for atomic value [in|de]crement and exchange
S// the functions are atomic with respect to each other as long as
S// they are passed the same mutex by the callers
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return ++__t;
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    return --__t;
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u,
S                             __rw_mutex_base &__mutex)
S{
S    _RWSTD_MT_GUARD (__mutex);
S
S    _TypeT __tmp = __t;
S    __t = __u;
S    return __tmp;
S}
S
S
S// for use on class statics or on namespace-scope variables
S// the unused argument is only here so that all functions can be
S// called from the same set of macros
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_preincrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_preincrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT>
Sinline
S_TypeT __rw_atomic_predecrement (_TypeT &__t, bool)
S{
S    return __rw_atomic_predecrement (__t,
S                                     __rw_get_static_mutex ((_TypeT*)0));
S}
S
S
Stemplate <class _TypeT, class _TypeU>
Sinline
S_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
S{
S    return __rw_atomic_exchange (__t, __u,
S                                 __rw_get_static_mutex ((_TypeT*)0));
S}
S
S/********************** DEC CXX **************************************/
S
S#if defined (__DECCXX) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// __ATOMIC_[DE|IN]CREMENT_[LONG|QUAD] and __ATOMIC_EXCH_[LONG|QUAD] are
S// intrinsic functions declared in <machine/builtins.h> that atomically
S// modify their argument and return its original value (__ATOMIC_XXX_LONG
S// is misnamed -- it actually operates on an int, not a long)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_LONG (&__x);
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return 1 + __ATOMIC_INCREMENT_QUAD (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    return __ATOMIC_DECREMENT_LONG (&__x) - 1;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return __ATOMIC_DECREMENT_QUAD (&__x) - 1;
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    return __ATOMIC_EXCH_LONG (&__x, __y);
S}
S
S
Sinline
Sunsigned __rw_atomic_exchange (unsigned &__x, unsigned __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned&, __x),
S                                 _RWSTD_STATIC_CAST (int, __y), false);
S}
S
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return __ATOMIC_EXCH_QUAD (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y, bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (unsigned long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S/********************** gcc/i86 **************************************/
S
S#elif defined (__i386__) && defined (__GNUG__)
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; addl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
S
Sinline
Sunsigned __rw_atomic_preincrement (unsigned &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    __asm__ __volatile__ ("lock; subl $1,%0" : : "m" (__x));
S
S    return __x;
S}
S
Sinline
Sunsigned __rw_atomic_predecrement (unsigned &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (int));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (int&, __x),
S                                     false);
S}
S
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S/********************** WIN 32/64 ************************************/
S
S#elif defined (_WIN32) && !defined (_RWSTD_NO_ATOMIC_OPERATIONS)
S
S// Interlocked[In|De]crement functions atomically modify their argument
S// and return the new value
S
S// InterlockedExchange atomically sets the value pointed to by the first
S// argument to that of the second argument and returns the original value
S
Sinline
Slong __rw_atomic_preincrement (long &__x, bool)
S{
S    return InterlockedIncrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_preincrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, bool)
S{
S    return InterlockedDecrement (&__x);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long &__x, bool)
S{
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                     false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_predecrement (_TypeT* &__x, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       false));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, bool)
S{
S    return InterlockedExchange (&__x, __y);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    bool)
S{
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                 _RWSTD_STATIC_CAST (long, __y), false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline _TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y, bool)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   false));
S}
S
S#endif   // _WIN64
S
S
Sinline
Slong __rw_atomic_preincrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_preincrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_preincrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_preincrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_preincrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_preincrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_preincrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_predecrement (long &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_predecrement (unsigned long   &__x,
S                                        __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sint __rw_atomic_predecrement (int &__x, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_predecrement (unsigned int    &__x,
S                                       __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_predecrement (__x, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_predecrement (_TypeT*         &__x,
S                                  __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_predecrement (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                       __mutex));
S}
S
S#endif   // _WIN64
S
Sinline
Slong __rw_atomic_exchange (long &__x, long __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned long __rw_atomic_exchange (unsigned long &__x, unsigned long __y,
S                                    __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sint __rw_atomic_exchange (int &__x, int __y, __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
Sinline
Sunsigned int __rw_atomic_exchange (unsigned int &__x, unsigned int __y,
S                                   __rw_mutex_base &__mutex)
S{
S    _RWSTD_UNUSED (__mutex);
S
S    return __rw_atomic_exchange (__x, __y, false);
S}
S
S
S#if !defined (_WIN64)
S
Stemplate <class _TypeT>
Sinline
S_TypeT* __rw_atomic_exchange (_TypeT* &__x, const _TypeT* __y,
S                              __rw_mutex_base &__mutex)
S{
S    _RWSTD_COMPILE_ASSERT (sizeof __x == sizeof (long));
S
S    return _RWSTD_REINTERPRET_CAST (_TypeT*,
S             __rw_atomic_exchange (_RWSTD_REINTERPRET_CAST (long&, __x),
S                                   _RWSTD_REINTERPRET_CAST (long,  __y),
S                                   __mutex));
S}
S
S#endif   // _WIN64
S
S#endif   // _WIN32
S
S
S_RWSTD_NAMESPACE_END   // __rw
S
S
N#else   // if !defined (_RWSTD_MULTI_THREAD)
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// atomic in a single-threaded environment
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N
N// dummy classes used as a base class in single-threaded environments
N
Nstruct __rw_mutex_base
N{
N    void _C_acquire () { }
N
N    void _C_release () { }
N};
N
N
Nstruct _RWSTD_EXPORT __rw_mutex: public __rw_mutex_base
Xstruct  __rw_mutex: public __rw_mutex_base
N{
N};
N
N
Nstruct __rw_guard
N{
N    __rw_guard (__rw_mutex_base&) { }
N
N    __rw_guard (__rw_mutex_base*) { }
N
N    __rw_mutex_base* _C_set (__rw_mutex_base*) {
N        return 0;
N    }
N};
N
N
Nstruct __rw_synchronized
N{
N    // static so that it takes up no room
N    static __rw_mutex _C_mutex;
N
N    void _C_lock () { }
N
N    void _C_unlock () { }
N
N    __rw_guard _C_guard () {
N        return __rw_guard (_C_mutex);
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MULTI_THREAD
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// available in all environments (ST and MT), used along with
N// __rw_atomic_exchange<>() from conditional expressions in iostreams
Ntemplate <class _TypeT, class _TypeU>
Ninline
N_TypeT __rw_ordinary_exchange (_TypeT &__t, const _TypeU &__u)
N{
N    _TypeT __tmp = __t;
N    __t = __u;
N    return __tmp;
N}
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_MUTEX_H_INCLUDED
N
L 53 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\memory" 2
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// [de]allocate storage (in bytes)
N_RWSTD_EXPORT void* __rw_allocate (_RWSTD_C::size_t, int = 0);
X void* __rw_allocate (std::size_t, int = 0);
N_RWSTD_EXPORT void  __rw_deallocate (void*, _RWSTD_C::size_t, int = 0);
X void  __rw_deallocate (void*, std::size_t, int = 0);
N
N// this function returns a suggested new capacity for a container needing
N// more room; see stddefs.h for an explanation of these macro parameters;
N// the _Container template parameter allows more specialized overloads
N// for customization
Ntemplate <class _Container>
Ninline _RWSTD_C::size_t __rw_new_capacity (_RWSTD_C::size_t __size, const _Container*)
Xinline std::size_t __rw_new_capacity (std::size_t __size, const _Container*)
N{
N    _RWSTD_C::size_t __cap = _RWSTD_STATIC_CAST (_RWSTD_C::size_t,
N                                       _RWSTD_INCREASE_CAPACITY(__size)
N                                       /*__size * _RWSTD_NEW_CAPACITY_RATIO*/);
X    std::size_t __cap = static_cast< std::size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));
N    return (__size += _RWSTD_MINIMUM_NEW_CAPACITY) > __cap ? __size : __cap;
X    return (__size += std::size_t (32)) > __cap ? __size : __cap;
N}
N
N
Ntemplate <class _TypeT>
Ninline void __rw_destroy (_TypeT &__ref)
N{
N    __ref.~_TypeT ();
N}
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline void __rw_construct (_TypeT* __p, const _TypeU& __val)
N{
N    new (__p) _TypeT (__val);
N}
N
N
Ntemplate <class _ForwardIterator> 
Nvoid __rw_destroy (_ForwardIterator __first, _ForwardIterator __last)
N{
N    for (; __first != __last; ++__first)
N        __rw_destroy (*__first);
N}
N
N
N#ifndef _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N// for compilers that don't optimize "empty" loops
Ntemplate <class _TypeT> 
Ninline void __rw_destroy (_TypeT**, _TypeT**)
N{ }
N
N#endif   // _RWSTD_NO_PTR_VALUE_TEMPLATE_OVERLOAD
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _TypeT> class
Nallocator;
N
N
N_RWSTD_SPECIALIZED_CLASS
Xtemplate< >
Nclass allocator<void>
N{
Npublic:
N    typedef void*       pointer;
N    typedef const void* const_pointer;
N    typedef void        value_type;
N   
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N#endif /* _RWSTD_ALLOCATOR */
N    
N};
N
N
Ntemplate <class _TypeT>
Nclass allocator
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef _TypeT              value_type;
N    typedef value_type*         pointer;
N    typedef const value_type*   const_pointer;
N    typedef value_type&         reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator&
N    operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N    pointer address (reference __x) const { 
N        return &__x; 
N    }
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    pointer allocate (size_type __n, allocator<void>::const_pointer = 0) {
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (pointer __p, size_type __n)
N#else
S    void deallocate (void* __p, size_type __n)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (__p, __n);
X        __rw::__rw_deallocate (__p, __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return size_type (~0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (pointer __p, const_reference __val) {
N        _RW::__rw_construct (__p, __val);
X        __rw::__rw_construct (__p, __val);
N    }
N    
N    void destroy (pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (*__p);
X        __rw::__rw_destroy (*__p);
N    }
N};
N
N
N#if    !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC) \
N    && !defined (_RWSTD_NO_EXT_CONST_ALLOCATOR)
X#if    !0L     && !0L
N
N// extension: allocates/constructs/destroys const elements
N
Ntemplate <class _TypeT>
Nclass allocator<const _TypeT>
N{
Npublic:
N    typedef _RWSTD_C::size_t    size_type;
X    typedef std::size_t    size_type;
N    typedef ptrdiff_t           difference_type;
N    typedef const _TypeT        value_type;
N    typedef const value_type*   pointer;
N    typedef const value_type*   const_pointer;
N    typedef const value_type&   reference;
N    typedef const value_type&   const_reference;
N
N    allocator () _THROWS (()) { }
X    allocator ()  { }
N
N    allocator (const allocator &__rhs) _THROWS (()) {
X    allocator (const allocator &__rhs)  {
N        // working around an HP aCC warning 431
N        _RWSTD_UNUSED (__rhs);
X        ((void)&__rhs);
N    }
N
N#ifdef _RWSTD_ALLOCATOR
N
N    template <class _TypeU> 
N    struct rebind {
N        typedef allocator<_TypeU> other;
N    };
N
N    template <class _TypeU>
N    allocator (const allocator<_TypeU>&) _THROWS (()) { }
X    allocator (const allocator<_TypeU>&)  { }
N
N    template <class _TypeU>
N    allocator& operator= (const allocator<_TypeU>&) _THROWS (()) { 
X    allocator& operator= (const allocator<_TypeU>&)  { 
N        return *this; 
N    }
N
N#endif   // _RWSTD_ALLOCATOR
N
N    const_pointer address (const_reference __x) const { 
N        return &__x;
N    }
N
N    const_pointer
N    allocate (size_type __n, allocator<void>::const_pointer = 0) { 
N
N#ifdef _RWSTD_ALLOCATOR
N        return _RWSTD_STATIC_CAST (const_pointer,
N                   _RW::__rw_allocate (__n * sizeof (value_type)));
X        return static_cast< const_pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));
N#else
S        return _RWSTD_STATIC_CAST (const_pointer, _RW::__rw_allocate (__n));
N#endif   // _RWSTD_ALLOCATOR
N
N    }
N
N#ifdef _RWSTD_ALLOCATOR        
N    void deallocate (const_pointer __p, size_type __n /* elements */)
N#else
S    void deallocate (const void* __p, size_type __n /* bytes */)
N#endif   // _RWSTD_ALLOCATOR
N    {
N        _RW::__rw_deallocate (_RWSTD_CONST_CAST (_TypeT*, __p), __n);
X        __rw::__rw_deallocate (const_cast< _TypeT* >(__p), __n);
N    }
N
N    // 20.4.1.1, p11 - the largest N for which allocate (N) might succeed
N    size_type max_size () const _THROWS (()) { 
X    size_type max_size () const  { 
N        return ~size_type (0) / sizeof (value_type) ?
N            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
N    }
N
N    void construct (const_pointer __p, const_reference __val) {
N        _RW::__rw_construct (_RWSTD_CONST_CAST (_TypeT*, __p), __val);
X        __rw::__rw_construct (const_cast< _TypeT* >(__p), __val);
N    }
N    
N    void destroy (const_pointer __p) {
N        _RWSTD_ASSERT (0 != __p);
X        ((void)0);
N        _RW::__rw_destroy (_RWSTD_CONST_CAST (_TypeT&, *__p));
X        __rw::__rw_destroy (const_cast< _TypeT& >(*__p));
N    }
N};
N
N#endif   // !_RWSTD_NO_CLASS_PARTIAL_SPEC && !_RWSTD_NO_EXT_CONST_ALLOCATOR)
N
N
N// allocator_interface provides all types and typed functions.  Memory
N// allocated as raw bytes using the class provided by the Allocator
N// template parameter.  allocator_interface casts appropriately.
N//
N// Multiple allocator_interface objects can attach to a single 
N// allocator, thus allowing one allocator to allocate all storage
N// for a container, regardless of how many types are involved.
N//
N// The only real restriction is that pointer and reference are
N// hard coded as _TypeT* and _TypeT&.  Partial specialization would 
N// get around this.
N//
N#ifndef _RWSTD_ALLOCATOR
S
Stemplate <class _Allocator, class _TypeT>
Sclass allocator_interface 
S{
Spublic:
S    typedef _Allocator                                allocator_type;
S    typedef _TypeT                                    value_type;
S    typedef value_type*                               pointer;
S    typedef const value_type*                         const_pointer;
S    typedef value_type&                               reference;
S    typedef const value_type&                         const_reference;
S    typedef _TYPENAME allocator_type::size_type       size_type;
S    typedef _TYPENAME allocator_type::difference_type difference_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface()  _THROWS (())  { }
S
S    allocator_interface (const allocator_type &__alloc)  _THROWS (())
S    : _C_alloc (__alloc) { }
S
S    operator allocator_type& () {
S        return _C_alloc;
S    }
S
S    pointer address (reference __x) { 
S        return &__x;
S    }
S  
S    size_type max_size () const { 
S        return _C_alloc.max_size () / sizeof (value_type);
S    }
S
S    pointer allocate (size_type __n, const void* __p = 0) {
S        //using c-style cast to perform reinterpret-cast & const-cast in 1 step
S        return (pointer)_C_alloc.allocate (__n * sizeof (value_type),
S                                           (pointer) __p );
S    }
S
S    void deallocate (pointer __p, size_type __n) {
S        _C_alloc.deallocate (__p, __n);
S    }
S
S    void construct (pointer __p, const_reference __val) const {
S        _RW::__rw_construct(__p, __val);
S    }
S
S    void destroy (pointer __p) const {
S        _RWSTD_ASSERT (0 != __p);
S        _RW::__rw_destroy (*__p);
S    }
S};
S
S
S_RWSTD_SPECIALIZED_CLASS
Sclass allocator_interface<allocator<void>, void> 
S{
Spublic:
S    typedef allocator<void> allocator_type;
S    typedef void*           pointer;
S    typedef const void*     const_pointer;      
S    typedef void            value_type;
S
Sprotected:
S    allocator_type _C_alloc;
S
Spublic:
S    allocator_interface () _THROWS (()) { }
S
S    allocator_interface (const allocator<void>& __rhs) _THROWS (())
S    : _C_alloc (__rhs) { }
S
S};
S
S
Stemplate <class _TypeT, class _TypeU, class _TypeV, class _TypeW>
Sinline bool
Soperator== (const allocator_interface<_TypeT, _TypeU>&, 
S            const allocator_interface<_TypeV, _TypeW>&) _THROWS (())
S{
S    return true;
S}
S
N#endif  // _RWSTD_ALLOCATOR
N
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  _THROWS (())
Xoperator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  
N{
N    return true;
N}
N
N
N#ifndef _RWSTD_NO_NAMESPACE
N
Ntemplate <class _TypeT, class _TypeU>
Ninline bool
Noperator!= (const allocator<_TypeT>& __x,
N            const allocator<_TypeU>& __y)  _THROWS (())
X            const allocator<_TypeU>& __y)  
N{
N    return !(__x == __y);
N}
N
N#endif   // _RWSTD_NO_NAMESPACE
N
N
N// 20.4.2
Ntemplate <class _OutputIterator, class _TypeT>
Nclass raw_storage_iterator
N    : public iterator<output_iterator_tag, void, void, void, void>
N{
N    _OutputIterator _C_iter;
Npublic:
N
N    // for completeness and genericity
N    typedef _OutputIterator iterator_type;
N
N    // 20.4.2, p2
N    _EXPLICIT raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
X    explicit raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }
N
N    // 20.4.2, p3
N    raw_storage_iterator& operator* () {
N        return *this;
N    }
N
N    // 20.4.2, p4
N    raw_storage_iterator& operator= (const _TypeT& __rhs) {
N        ::new (&(*_C_iter)) _TypeT (__rhs);
N        return *this;
N    }
N
N    // 20.4.2, p6
N    raw_storage_iterator& operator++ () {
N        ++_C_iter;
N        return *this;
N    }
N
N    // 20.4.2, p7
N    raw_storage_iterator operator++ (int) {
N        raw_storage_iterator __tmp = *this;
N        ++*this;
N        return __tmp;
N    }
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// __rw_indestructible specializations should be objects with static
N// storage duration that must "survive" all other static objects and that
N// do not need to be destroyed; this is a POD
Ntemplate <class _TypeT>
Nclass __rw_indestructible
N{
N    union _C_data_t {
N        char        _C_data;      // data to back _TypeT up with 
N        long double _C_padding;   // make sure data is suitably aligned
N    };
N
N    enum { _C_n = 1 + sizeof (_TypeT) / sizeof (_C_data_t) };
N
N    _C_data_t _C_data [_C_n];     // raw storage for an object of _TypeT
N
Npublic:
N    typedef _TypeT            value_type;
N    typedef value_type&       reference;
N    typedef const value_type& const_reference;
N    typedef value_type*       pointer;
N    typedef const value_type* const_pointer;
N
N    // no ctor to allow static POD initialization (3.6.2, p1)
N
N    // allow this to be used as a an obejct of another type
N    operator reference () {
N        return _RWSTD_REINTERPRET_CAST (reference, *_C_data);
X        return reinterpret_cast< reference >(*_C_data);
N    }
N
N    operator const_reference () const {
N        return _RWSTD_REINTERPRET_CAST (const_reference, *_C_data);
X        return reinterpret_cast< const_reference >(*_C_data);
N    }
N
N    // calls a conversion operator above
N    pointer operator& () {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (reference, *this);
N
N        return &(reference)*this;
N    }
N    
N    // calls a conversion operator above
N    const_pointer operator& () const {
N        // deprecated C-style cast used to make SunPro 5.0/T9 happy
N        // return &_RWSTD_STATIC_CAST (const_reference, *this);
N
N        return &(const_reference)*this;
N    }
N};
N
N
N#ifdef _INLINE_WITH_STATICS
N
N_INLINE_WITH_STATICS _RWSTD_EXPORT char* __rw_get_static_buf ()
Xinline  char* __rw_get_static_buf ()
N{
N    typedef char _CharBuf [_RWSTD_TMPBUF_SIZE + 1];
X    typedef char _CharBuf [4096 + 1];
N
N    // use `indestructible' to guarantee proper buffer alignment
N    static __rw_indestructible<_CharBuf> __buffer;
N
N    return _RWSTD_STATIC_CAST (char*, __buffer);
X    return static_cast< char* >(__buffer);
N}
N
N
N// [de]allocates a previously allocated temporary buffer
N// the constant _RWSTD_TMPBUF_SIZE controls the size of a static buffer
N// if request for area larger than _RWSTD_TMPBUF_SIZE comes in,
N// space is allocated dynamically, otherwise the static buffer is used
N// return value meaningful only if __n != 0
N_INLINE_WITH_STATICS _RWSTD_EXPORT _STD::pair<void*, _RWSTD_C::size_t>
Xinline  std::pair<void*, std::size_t>
N__rw_reallocate_temp_buffer (void *__p, _RWSTD_C::size_t __size)
X__rw_reallocate_temp_buffer (void *__p, std::size_t __size)
N{
N    // implicit initialization used to prevent a g++ 2.95.2 warning on Tru64
N    // sorry: semantics of inline function static data are wrong (you'll wind
N    // up with multiple copies)
N
N    static unsigned long __busy /* = 0 */;   // > 0 when buffer in use
N
N    unsigned long __cntr = _RWSTD_ATOMIC_PREINCREMENT (__busy, false);
X    unsigned long __cntr = ++(__busy);
N
N    static char *__buffer = __rw_get_static_buf ();
N
N    if (__p == (void*)__buffer) {
N        __p    = 0;
N        __size = 0;
N
N        // returning buffer, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else
N        ::operator delete (__p);
N
N    if (__size == 0) {
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else if (__size > _RWSTD_TMPBUF_SIZE || __cntr > 1) {
X    else if (__size > 4096 || __cntr > 1) {
N        _TRY {
X         {
N            __p = ::operator new (__size);
N        }
N        _CATCH (...) {
X        while (0) {
N            __p    = 0;
N            __size = 0;
N        }
N
N        // buffer not used, decrement usage counter
N        _RWSTD_ATOMIC_PREDECREMENT (__busy, false);
X        --(__busy);
N    }
N    else {
N        __p = __buffer;
N
N        // buffer used, usage counter stays non-zero
N    }
N
N    return _STD::pair<void*, _RWSTD_C::size_t>(__p, __size);
X    return std::pair<void*, std::size_t>(__p, __size);
N}
N
N#else   // if !defined (_INLINE_WITH_STATICS)
S
S_STD::pair<void*, _RWSTD_C::size_t> _RWSTD_EXPORT
S__rw_reallocate_temp_buffer (void*, _RWSTD_C::size_t);
S
N#endif   // _INLINE_WITH_STATICS
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// 20.4.3 only specifies a get_temporary_buffer<>() that takes a ptrdiff_t.
N// We overload on all types so that signed integral types other than ptrdiff_t
N// can be used. This is important in getting algorithms to compile with
N// user-defined iterators (not derived from iterator<...>) whose difference
N// type is something other than ptrdiff_t.
N
N// having this overload is important in some cases for compilers that
N// do not support partial class specialization (and where as a consequence
N// iterator_traits<> isn't available)
Ntemplate <class _TypeT, class _Distance>
Ninline pair<_TypeT*, _Distance> get_temporary_buffer (_Distance __n, _TypeT*)
N{
N    pair<void*, size_t> __pair =
N        _RW::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
X        __rw::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));
N
N    return make_pair (_RWSTD_STATIC_CAST (_TypeT*, __pair.first),
X    return make_pair (static_cast< _TypeT* >(__pair . first),
N                      _Distance (__pair.second / sizeof (_TypeT)));
N}
N
N
N#ifndef _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N// 20.4.3, p1
Ntemplate <class _TypeT>
Ninline pair<_TypeT*, ptrdiff_t> get_temporary_buffer (ptrdiff_t __n)
N{
N    return get_temporary_buffer (__n, (_TypeT*)0);
N}
N
N#endif   // _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N// 20.4.3, p3
Ntemplate <class _TypeT>
Ninline void return_temporary_buffer (_TypeT *__p)
N{
N    _RW::__rw_reallocate_temp_buffer (__p, 0);
X    __rw::__rw_reallocate_temp_buffer (__p, 0);
N}
N
N
N// 20.4.4.1
Ntemplate <class _InputIterator, class _ForwardIterator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            _RW::__rw_construct (&*__res, *__first);
X            __rw::__rw_construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __res);
X        __rw::__rw_destroy (__start, __res);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _InputIterator, class _ForwardIterator, class _Allocator>
Ninline
N_ForwardIterator uninitialized_copy (_InputIterator   __first,
N                                     _InputIterator   __last,
N                                     _ForwardIterator __res,
N                                     _Allocator&      __alloc)
N{
N    _ForwardIterator __start = __res;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first, ++__res)
N            __alloc.construct (&*__res, *__first);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __res; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N
N    return __res;
N}
N
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.4.2
Ntemplate <class _ForwardIterator, class _TypeT>
Ninline
Nvoid uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last,
N                         const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __first != __last; ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N// 20.4.4.3
Ntemplate <class _ForwardIterator, class _Size, class _TypeT>
Ninline
Nvoid uninitialized_fill_n (_ForwardIterator __first, _Size __n,
N                           const _TypeT& __x)
N{
N    _ForwardIterator __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            _RW::__rw_construct (&*__first, __x);
X            __rw::__rw_construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        _RW::__rw_destroy (__start, __first);
X        __rw::__rw_destroy (__start, __first);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N
N#ifdef _RWSTD_ALLOCATOR
N
N// extension
Ntemplate <class _ForwardIter, class _Size, class _TypeT, class _Allocator>
Ninline
Nvoid uninitialized_fill_n (_ForwardIter __first, _Size __n,
N                           const _TypeT& __x, _Allocator& __alloc)
N{
N    _ForwardIter __start = __first;
N
N    _TRY {
X     {
N        for (; __n; --__n, ++__first)
N            __alloc.construct (&*__first, __x);
N    }
N    _CATCH (...) {
X    while (0) {
N        for (; __start != __first; ++__start)
N            __alloc.destroy (&*__start);
N        _RETHROW;
X        ((void)0);
N    }
N}
N
N#else   // if !defined (_RWSTD_ALLOCATOR)
S
S// Specializations for non-standard allocators.  When vector calls
S// uninitialized_{copy,fill_n} with non-standard allocator, a temporary
S// instance of allocator_interface is passed to these functions.  Since
S// C++ forbids temporaries to be passed as non-const references, we
S// use these specializations to pass a const reference (and we can force
S// allocator_interface members construct & destroy to be const).
S
Stemplate <class _InputIterator, class _ForwardIterator,
S          class _Allocator, class _TypeT>
Sinline _ForwardIterator
Suninitialized_copy (_InputIterator   __first,
S                    _InputIterator   __last,
S                    _ForwardIterator __res,
S                    const allocator_interface<_Allocator, _TypeT>& __alloc)
S{
S    _ForwardIterator __start = __res;
S
S    _TRY {
S        for (; __first != __last; ++__first, ++__res)
S            __alloc.construct (&*__res, *__first);
S    }
S    _CATCH (...) {
S        for (; __start != __res; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S
S    return __res;
S}
S
Stemplate <class _ForwardIter, class _Size,
S          class _TypeT, class _Allocator, class _TypeU>
Sinline void
Suninitialized_fill_n (_ForwardIter __first, _Size __n,
S                      const _TypeT& __x,
S                      const allocator_interface<_Allocator, _TypeU>& __alloc)
S{
S    _ForwardIter __start = __first;
S
S    _TRY {
S        for (; __n; --__n, ++__first)
S            __alloc.construct (&*__first, __x);
S    }
S    _CATCH (...) {
S        for (; __start != __first; ++__start)
S            __alloc.destroy (&*__start);
S        _RETHROW;
S    }
S}
S
N#endif   // _RWSTD_ALLOCATOR
N
N
N// 20.4.5 - Template class auto_ptr
N
Ntemplate<class _TypeT>
Nclass auto_ptr;
N
N
N// 20.4.5, p2 (defined outside of auto_ptr<> according to the proposed
N// resolution of lwg issue 127)
Ntemplate <class _TypeT>
Nclass auto_ptr_ref 
N{
Npublic:
N    auto_ptr<_TypeT>& _C_ptr;
N
N    auto_ptr_ref (auto_ptr<_TypeT>& __rhs) : _C_ptr (__rhs) { }
N};
N
N
Ntemplate<class _TypeT>
Nclass auto_ptr
N{
Npublic:
N    typedef _TypeT element_type;
N
N    _EXPLICIT auto_ptr (element_type* __p = 0) _THROWS (())
X    explicit auto_ptr (element_type* __p = 0) 
N     : _C_ptr (__p) { }
N
N    auto_ptr (auto_ptr& __rhs) _THROWS (())
X    auto_ptr (auto_ptr& __rhs) 
N     : _C_ptr (__rhs.release ()) { }
N
N    auto_ptr& operator= (auto_ptr& __rhs) _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr& __rhs)  { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N    // follows lwg issue 127
N    auto_ptr&
N    operator= (auto_ptr_ref<element_type> __rhs) _THROWS (()) {
X    operator= (auto_ptr_ref<element_type> __rhs)  {
N        reset (__rhs._C_ptr.release ());
N        return *this;
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template <class _TypeU>
N    operator auto_ptr_ref<_TypeU>() _THROWS (()) {
X    operator auto_ptr_ref<_TypeU>()  {
N        return auto_ptr_ref<_TypeU>(*this);
N    }
N
N    template <class _TypeU> 
N    operator auto_ptr<_TypeU>() _THROWS (()) {
X    operator auto_ptr<_TypeU>()  {
N        return auto_ptr<_TypeU>(release ());
N    }
N
N    template <class _TypeU>
N    auto_ptr (auto_ptr<_TypeU>& __rhs) _THROWS (())
X    auto_ptr (auto_ptr<_TypeU>& __rhs) 
N    : _C_ptr (__rhs.release ()) { }
N
N    template <class _TypeU>
N    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)  _THROWS (()) { 
X    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)   { 
N        reset (__rhs.release ());
N        return *this;
N    }
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    ~auto_ptr () _THROWS (()) {
X    ~auto_ptr ()  {
N        delete _C_ptr;
N    }
N
N    element_type* get () const _THROWS (()) {
X    element_type* get () const  {
N        return _C_ptr;
N    }
N
N    element_type& operator* () const _THROWS (()) {
X    element_type& operator* () const  {
N        _RWSTD_ASSERT (0 != get ());
X        ((void)0);
N        return *get (); 
N    }
N
N    _RWSTD_OPERATOR_ARROW (
N        element_type* operator-> () const _THROWS (()))
X    element_type* operator-> () const { return & * *this; }
N
N    element_type* release () _THROWS (()) { 
X    element_type* release ()  { 
N        element_type* __tmp = _C_ptr;
N        _C_ptr = 0;
N        return __tmp; 
N    }
N
N    void reset (element_type* __p = 0) _THROWS (()) { 
X    void reset (element_type* __p = 0)  { 
N        if (_C_ptr != __p) {
N            delete _C_ptr;
N            _C_ptr = __p;
N        }
N    }
N
N    auto_ptr (auto_ptr_ref<element_type> __r) _THROWS (())
X    auto_ptr (auto_ptr_ref<element_type> __r) 
N    : _C_ptr (__r._C_ptr.release ()) { }
N
Nprivate:
N    element_type* _C_ptr;
N};
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_MEMORY_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_strref.h" 2
N#include <rw/_mutex.h>
N#include <rw/_traits.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_traits.h" 1
N/***************************************************************************
N *
N * _traits.h - Declarations for char_traits 
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N#ifndef _RWSTD_TRAITS_H_INCLUDED
N#define _RWSTD_TRAITS_H_INCLUDED
N
N#include <rw/_defs.h>
N
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N#include _RWSTD_CSTDIO
X#include <cstdio>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdio" 1
N/*
N * C++ header for C header stdio.h
N * Copyright 1997 ARM Limited. All rights reserved.
N */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author$
N */
N
N#ifndef __cstdio
N#define __cstdio
N#define __ARMCLIB_VERSION 5060037
N
N  #define __STDIO_NO_EXPORTS 1
N  #include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
N      namespace std {
N      #define __CLIBNS ::std::
N        extern "C" {
N    #else /* ndef __cplusplus */
S      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 1L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !1L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (1L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !1L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (0L && 199901L <= __STDC_VERSION__) || (1L && 201103L <= 199711L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
N    inline int getchar() { return getc(stdin); }
X    inline int getchar() { return getc((& ::std:: __stdin)); }
N#else
S    #define getchar() getc(stdin)
S    extern _ARMABI int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
N    inline int putchar(int __c) { return putc(__c, stdout); }
X    inline int putchar(int __c) { return putc(__c, (& ::std:: __stdout)); }
N#else
S    #define putchar(c) putc(c, stdout)
S    extern _ARMABI int (putchar)(int /*c*/);
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
N        }  /* extern "C" */
N      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 1L && !1L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 18 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\cstdio" 2
N  #undef __STDIO_NO_EXPORTS
N
N  #undef __stdio_h  // later inclusion of stdio.h must do using std::*
N  #ifdef __EDG_IMPLICIT_USING_STD
S    /* Implicitly include a using directive for the STD namespace when this
S       preprocessing flag is TRUE. */
S       using namespace ::std;
N  #endif /* ifdef __EDG_IMPLICIT_USING_STD */
N
N#endif /* __cstdio */
N
L 41 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_traits.h" 2
N#include _RWSTD_CSTRING
X#include <cstring>
N#include _RWSTD_CWCHAR
X#include <cwchar>
N
N#ifdef  _WIN64
S#   include _RWSTD_SYS_TYPES_H
N#endif
N
N#if defined (_RWSTD_STRICT_ANSI)
X#if 0L
S_RWSTD_USING_SNI (uid_t);
N#endif
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N
N// 27.4.1, p2
Ntypedef _RWSTD_SSIZE_T streamsize;
Xtypedef long streamsize;
Ntypedef _RWSTD_SSIZE_T streamoff;
Xtypedef long streamoff;
N
N
N/* fpos<> maintains all the information necessary to restore an arbitrary
N * sequence, controlled by the Standard C++ library, to a previous stream
N * position and conversion state.
N */
N
Ntemplate <class _StateT>
Nclass fpos
N{
Npublic:
N
N    typedef _StateT  state_type;
N
N    fpos (streamoff __off = 0) // allowing a default is an extension to the standard
N        : _C_pos (__off),
N          _C_state ()
N        {
N    }
N
N    fpos (streamoff __off, state_type __state) // allowing two arguments is an extension to the standard
N        : _C_pos (__off),
N          _C_state (__state)
N        { }
N
N    operator streamoff () const {
N        return _C_pos;
N    }
N
N    fpos (const fpos&);
N
N    fpos& operator= (const fpos&);
N
N    state_type state () const {
N        return _C_state;
N    }
N
N    void state (state_type __state) {
N        _C_state = __state;
N    }
N
N    // arithmetic operators
N    fpos operator- (const fpos &__off) const {
N        return fpos (*this) -= __off;
N    }
N
N    fpos operator+ (const fpos &__off) const {
N        return fpos (*this) += __off;
N    }
N
N    fpos& operator-= (const fpos &__off) {
N        return _C_pos -= __off._C_pos, *this;
N    }
N
N    fpos& operator+= (const fpos &__off) {
N        return _C_pos += __off._C_pos, *this;
N    }
N
N    fpos operator- (streamoff __off) const {
N        return fpos (*this) -= __off;
N    }
N
N    fpos operator+ (streamoff __off) const {
N        return fpos (*this) += __off;
N    }
N
N    fpos& operator-= (streamoff __off) {
N        return _C_pos -= __off, *this;
N    }
N
N    fpos& operator+= (streamoff __off) {
N        return _C_pos += __off, *this;
N    }
N
N    // relational operators
N    bool operator== (const fpos& __rhs) const; 
N
N    bool operator< (const fpos& __rhs) const {
N        return _C_pos < __rhs._C_pos;
N    }
N
N    bool operator<= (const fpos& __rhs) const {
N        return !(__rhs < *this);
N    }
N
N    bool operator>= (const fpos& __rhs) const {
N        return !(*this < __rhs);
N    }
N
N    bool operator!= (const fpos& __rhs) const {
N        return !(*this == __rhs);
N    }
N
N    bool operator> (const fpos& __rhs) const {
N        return __rhs < *this;
N    }
N
N    bool operator== (streamoff __rhs) const {
N        return _C_pos == __rhs;
N    }
N
N    bool operator< (streamoff __rhs) const {
N        return _C_pos < __rhs;
N    }
N
N    bool operator<= (streamoff __rhs) const {
N        return _C_pos <= __rhs;
N    }
N
N    bool operator>= (streamoff __rhs) const {
N        return _C_pos >= __rhs;
N    }
N
N    bool operator> (streamoff __rhs) const {
N        return _C_pos > __rhs;
N    }
N
N    bool operator!= (streamoff __rhs) const {
N        return !(_C_pos == __rhs);
N    }
N
Nprivate:
N
N    streamoff   _C_pos;     // signed displacement
N    state_type  _C_state;   // conversion state
N};
N
N
Ntemplate <class _StateT> 
Ninline
Nfpos<_StateT>::fpos(const fpos<_StateT>& __rhs)
N{
N    _C_pos    = __rhs._C_pos;
N    _C_state  = __rhs._C_state;
N}
N
N
Ntemplate <class _StateT>
Ninline fpos<_StateT>& 
Nfpos<_StateT>::operator= (const fpos<_StateT>& __rhs)
N{
N    if (&__rhs != this) {
N        _C_pos    = __rhs._C_pos;
N        _C_state  = __rhs._C_state;
N    }
N    return *this;
N}
N
N
Ntemplate <class _StateT>
Ninline bool 
Nfpos<_StateT>::operator== (const fpos<_StateT>& __rhs) const
N{ 
N    return    _C_pos == __rhs._C_pos
N#ifndef  _RWSTD_NO_MBSTATE_COMPARE
S           && _C_state == __rhs._C_state
N#endif
N    ;
N}
N
N
Ntemplate <class  _CharT> 
Nstruct char_traits 
N{
N    typedef _CharT                   char_type;
N    typedef int                      int_type;
N    typedef streamoff                off_type;
N    typedef mbstate_t                state_type;
N    typedef fpos<state_type>         pos_type;
N
N    static int_type eof () {
N        return EOF;
X        return (-1);
N    }
N
N    static void assign (char_type& __c1, const char_type& __c2) {
N        __c1 = __c2;
N    }
N
N    static bool eq (const char_type& __c1, const char_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static bool lt (const char_type& __c1, const char_type& __c2) {
N        return __c1 < __c2;
N    }
N
N    static int compare (const char_type* __s1, const char_type* __s2,
N                        _RWSTD_C::size_t __n) {
X                        std::size_t __n) {
N        _RWSTD_C::size_t __i = 0;
X        std::size_t __i = 0;
N        while (__i < __n) { 
N            if (!eq (__s1[__i], __s2[__i])) {
N                return lt (__s1[__i], __s2[__i]) ? -1 : 1;
N            }
N            ++__i;
N        }
N        return 0;
N    }
N        
N    static _RWSTD_C::size_t length (const char_type *__s) {
X    static std::size_t length (const char_type *__s) {
N        _RWSTD_C::size_t __len = 0;
X        std::size_t __len = 0;
N        while (!eq (*__s++, char_type ()))
N            ++__len;
N        return __len;
N    }
N 
N    static const char_type* 
N    find (const char_type* __s, _RWSTD_C::size_t __n, const char_type& __a) {
X    find (const char_type* __s, std::size_t __n, const char_type& __a) {
N        while (__n-- > 0 && !eq (*__s, __a) )
N            ++__s;
N        return  eq (*__s, __a) ? __s : 0;
N    }
N
N    static char_type* move (char_type* __s1, const char_type* __s2,
N                            _RWSTD_C::size_t __n) {
X                            std::size_t __n) {
N        if (__s1 < __s2)
N            copy (__s1, __s2, __n);
N        else if (__s1 > __s2) {
N            __s1 += __n;
N            __s2 += __n;
N            for (_RWSTD_C::size_t __i = 0; __i < __n; ++__i) 
X            for (std::size_t __i = 0; __i < __n; ++__i) 
N                assign (*--__s1, *--__s2);
N        }
N        return __s1;
N    }
N
N    static char_type* copy (char_type *__dst, const char_type *__src,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N        memcpy (__dst, __src, __n * sizeof (char_type));
N        return __dst;
N    }
N
N    static char_type*  assign (char_type* __s, _RWSTD_C::size_t __n, char_type __a) {
X    static char_type*  assign (char_type* __s, std::size_t __n, char_type __a) {
N        char_type* __tmp = __s;
N        while (__n-- > 0) 
N            assign (*__tmp++, __a);
N        return __s;
N    }
N
N    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static int_type not_eof (const int_type& __c) {
N        return eq_int_type (eof (), __c) ? 0 : __c;
N    }
N
N    static char_type to_char_type (const int_type& __c) {
N        return __c;
N    }
N      
N    static int_type to_int_type (const char_type& __c) {
N        return __c;
N    }
N};
N
N
N// 21.1.3.1
N_RWSTD_SPECIALIZED_CLASS  
Xtemplate< >  
Nstruct char_traits<char> 
N{
N    typedef char                      char_type;
N    typedef _RWSTD_INT_T              int_type;
X    typedef int              int_type;
N    typedef streamoff                 off_type; 
N    typedef mbstate_t                 state_type;
N    typedef fpos<state_type>          pos_type;
N
N    static int_type eof () {
N        return EOF;
X        return (-1);
N    }
N
N    static void assign (char_type& __c1, const char_type& __c2){
N        __c1 = __c2;
N    }
N
N    static bool eq (const char_type& __c1, const char_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static bool lt (const char_type& __c1, const char_type& __c2) {
N        return __c1 < __c2;
N    }
N
N    static int compare (const char_type* __s1, const char_type* __s2,
N                        _RWSTD_C::size_t __n) {
X                        std::size_t __n) {
N        return memcmp (__s1, __s2, __n);
N    }
N
N    static const char_type* find (const char_type* __s, 
N                                  _RWSTD_C::size_t __n, const char_type& __a) {
X                                  std::size_t __n, const char_type& __a) {
N        return (char_type*) memchr (__s, __a, __n);
N    }
N
N    static _RWSTD_C::size_t length (const char_type *__s) {
X    static std::size_t length (const char_type *__s) {
N        return strlen (__s);
N    }
N
N    static char_type * move (char_type* __s1, const char_type* __s2,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N#ifndef _RWSTD_NO_MEMMOVE
N        memmove (__s1, __s2, __n);
N#else
S        if (__s1 < __s2)
S            copy (__s1, __s2, __n);
S        else if (__s1 > __s2) {
S            __s1 += __n;
S            __s2 += __n;
S            for (_RWSTD_C::size_t __i = 0; __i < __n; ++__i)
S                assign (*--__s1, *--__s2);
S        }
N#endif
N        return __s1;
N    }
N
N    static char_type *copy (char_type *__dst, const char_type *__src,
N                             _RWSTD_C::size_t __n){
X                             std::size_t __n){
N        memcpy (__dst, __src, __n); 
N        return __dst;
N    }
N
N    static char_type* assign (char_type* __s, _RWSTD_C::size_t __n, char_type __a) {
X    static char_type* assign (char_type* __s, std::size_t __n, char_type __a) {
N        memset (__s, __a, __n);
N        return __s;
N    }
N
N    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static int_type not_eof (const int_type& __c) {
N        return eq_int_type (eof (), __c) ? 0 : __c;
N    }
N                        
N    static char_type to_char_type (const int_type& __c) {
N        return _RWSTD_STATIC_CAST (char_type, __c);
X        return static_cast< char_type >(__c);
N    }
N      
N    static int_type to_int_type (const char_type& __c) {
N        // make sure (signed char)'\xff' converts to 255 and not -1
N        return _RWSTD_STATIC_CAST (unsigned char, __c);
X        return static_cast< unsigned char >(__c);
N    }
N};
N
N
N#ifndef _RWSTD_NO_WCHAR_T
N
N// 21.1.3.2
N_RWSTD_SPECIALIZED_CLASS  
Xtemplate< >  
Nstruct char_traits<wchar_t> 
N{
N    typedef wchar_t                   char_type;
N    typedef _RWSTD_WINT_T             int_type;
X    typedef int             int_type;
N    typedef streamoff                 off_type;
N    typedef mbstate_t                 state_type;
N    typedef fpos<state_type>          pos_type;
N
N#ifndef WEOF
S#  define WEOF (-1)
N#endif
N
N    static int_type eof () {
N        return int_type (WEOF);
X        return int_type (((::std:: wint_t)-1));
N    }
N
N    static void assign (char_type& __c1, const char_type& __c2) {
N        __c1 = __c2;
N    }
N
N    static bool eq (const char_type& __c1, const char_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static bool lt (const char_type& __c1, const char_type& __c2) {
N        return __c1 < __c2;
N    }
N
N    static int compare (const char_type* __s1, const char_type* __s2,
N                        _RWSTD_C::size_t __n) {
X                        std::size_t __n) {
N#ifndef _RWSTD_NO_WMEMCMP
N        return wmemcmp (__s1, __s2, __n);
N#else
S        _RWSTD_C::size_t __i=0;
S        while (__i < __n) { 
S            if (!eq (__s1[__i], __s2[__i])) {
S                return lt (__s1[__i], __s2[__i]) ? -1 : 1;
S            }
S            ++__i;
S        }
S      return 0;
N#endif
N    }
N
N    static _RWSTD_C::size_t length (const char_type *__s) {
X    static std::size_t length (const char_type *__s) {
N#ifndef _RWSTD_NO_WCSLEN
N        // [harmless] cast necessary on CygWin
N        return wcslen (_RWSTD_CONST_CAST (char_type*, __s));
X        return wcslen (const_cast< char_type* >(__s));
N#else
S        _RWSTD_C::size_t __len = 0;
S        while (!eq (*__s++, char_type ()))
S            ++__len;
S        return __len;
N#endif
N    }
N      
N    static const char_type* find (const char_type* __s, _RWSTD_C::size_t __n, 
X    static const char_type* find (const char_type* __s, std::size_t __n, 
N                                  const char_type& __a)           {
N#ifndef _RWSTD_NO_WMEMCHR
N        return _RWSTD_STATIC_CAST (const char_type*, wmemchr (__s, __a, __n));
X        return static_cast< const char_type* >(wmemchr (__s, __a, __n));
N#else
S        while (__n-- > 0 && !eq (*__s, __a))
S            ++__s;
S        return  eq (*__s, __a) ? __s : 0;
N#endif   // _RWSTD_NO_WMEMCHR
N    }
N
N    static char_type * copy (char_type *__dst, const char_type *__src,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N        memcpy (__dst, __src, __n * sizeof (char_type));
N        return __dst;
N    }
N      
N    static char_type * move (char_type* __s1, const char_type* __s2,
N                             _RWSTD_C::size_t __n) {
X                             std::size_t __n) {
N#ifndef _RWSTD_NO_WMEMMOVE
N        wmemmove (__s1, __s2, __n);
N#else
S        if (__s1 < __s2)
S            copy (__s1, __s2, __n);
S        else if (__s1 > __s2) {
S            __s1 += __n;
S            __s2 += __n;
S            for (_RWSTD_C::size_t __i = 0; __i < __n; ++__i)
S                assign (*--__s1, *--__s2);
S        }
N#endif   // _RWSTD_NO_WMEMMOVE
N        return __s1;
N    }
N
N    static char_type* assign (char_type* __s, _RWSTD_C::size_t __n, char_type __a){
X    static char_type* assign (char_type* __s, std::size_t __n, char_type __a){
N#ifndef _RWSTD_NO_WMEMSET
N        wmemset (__s, __a, __n);
N#else
S        char_type* __tmp = __s;
S        while (__n-- > 0) 
S            assign (*__tmp++, __a);
N#endif   // _RWSTD_NO_WMEMSET
N        return __s;
N    }
N
N    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
N        return __c1 == __c2;
N    }
N
N    static int_type not_eof (const int_type& __c) {
N        return eq_int_type (eof (), __c) ? 0 : __c;
N    }
N
N    static char_type to_char_type (const int_type& __c) {
N        return __c;
N    }
N      
N    static int_type to_int_type (const char_type& __c) {
N        return __c;
N    }
N};
N
N#endif
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// Implementation _Traits class, rw_traits, provides specialized
N// algorithms to speed up find operations on char and wchar_t strings
N
Ntemplate <class _CharT, class _Traits> 
Nstruct rw_traits
N{
N    static const _CharT* find (const _CharT* __s, const _CharT* __v) { 
N        _RWSTD_C::size_t __slen = _Traits::length (__s);
X        std::size_t __slen = _Traits::length (__s);
N        _RWSTD_C::size_t __vlen = _Traits::length (__v);
X        std::size_t __vlen = _Traits::length (__v);
N        for (_RWSTD_C::size_t __j = 0; (__j + __vlen) <= __slen ; ++__j) {
X        for (std::size_t __j = 0; (__j + __vlen) <= __slen ; ++__j) {
N            bool __found = true;
N            for (_RWSTD_C::size_t __i = 0; __i < __vlen ; ++__i) {
X            for (std::size_t __i = 0; __i < __vlen ; ++__i) {
N                if (!_Traits::eq (__s[__j + __i], __v[__i])) {
N                    __found = false;
N                    break;
N                }
N            }
N            if (__found)
N                return &__s[__j];
N        }
N        return 0;
N    }
N
N    static const _CharT* rfind (const _CharT* __s, _CharT __v, _RWSTD_C::size_t __pos) {
X    static const _CharT* rfind (const _CharT* __s, _CharT __v, std::size_t __pos) {
N        for  (const _CharT* __p = __s + __pos; __p >= __s; --__p) {
N            if (_Traits::eq (*__p, __v))
N                return __p;
N        }
N        return 0;       
N    }
N
N    static _RWSTD_C::size_t find_first_of (const _CharT* __s, const _CharT* __v) {
X    static std::size_t find_first_of (const _CharT* __s, const _CharT* __v) {
N        const _CharT* __p = __s;
N        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
N            for (const _CharT* __q = __v; !_Traits::eq (*__q, _CharT ()); ++__q)
N                if (_Traits::eq (*__p, *__q))
N                    return __p - __s;
N        }
N        return  __p - __s;
N    }
N
N    static _RWSTD_C::size_t find_first_not_of (const _CharT* __s, const _CharT* __v) {
X    static std::size_t find_first_not_of (const _CharT* __s, const _CharT* __v) {
N        bool __found;
N        const _CharT* __p = __s;
N        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
N            __found = false;
N            for (const _CharT* __q = __v;
N                 !_Traits::eq (*__q, _CharT ()); ++__q){
N                if (_Traits::eq (*__p, *__q)){
N                    __found = true; 
N                    break;
N                }  
N            }
N            if (!__found)      
N                return __p - __s;
N        }
N        return  __p-__s;
N    }
N};
N
N
N_RWSTD_SPECIALIZED_CLASS 
Xtemplate< > 
Nstruct rw_traits<char, _STD::char_traits<char> >
Xstruct rw_traits<char, std::char_traits<char> >
N{
N    static const char* find (const char* __s, const char* __v) {
N        return _RWSTD_C::strstr (__s, __v);
X        return std::strstr (__s, __v);
N    }
N
N    static const char* rfind (const char* __s, char __v, _RWSTD_C::size_t __pos) { 
X    static const char* rfind (const char* __s, char __v, std::size_t __pos) { 
N        const char* __p = __s + __pos;
N        while (__p >= __s)
N        {
N            if (_STD::char_traits<char>::eq (*__p, __v))
X            if (std::char_traits<char>::eq (*__p, __v))
N                return __p;
N            __p--; 
N        }
N        return 0;       
N    }
N
N    static _RWSTD_C::size_t find_first_of (const char* __s, const char* __v) {
X    static std::size_t find_first_of (const char* __s, const char* __v) {
N        return _RWSTD_C::strcspn (__s, __v);
X        return std::strcspn (__s, __v);
N    }
N
N    static _RWSTD_C::size_t find_first_not_of (const char* __s, const char* __v) {
X    static std::size_t find_first_not_of (const char* __s, const char* __v) {
N        return _RWSTD_C::strspn (__s, __v);
X        return std::strspn (__s, __v);
N    }
N
N};
N
N#if !defined(_RWSTD_NO_WCSCHR)  && !defined(_RWSTD_NO_WCSSPN) && !defined(_RWSTD_NO_WCSSPN) && !defined(_RWSTD_NO_WCHAR_T)
X#if !0L  && !0L && !0L && !0L
N_RWSTD_SPECIALIZED_CLASS 
Xtemplate< > 
Nstruct rw_traits<wchar_t, _STD::char_traits<wchar_t> >
Xstruct rw_traits<wchar_t, std::char_traits<wchar_t> >
N{
N    static const wchar_t* find (const wchar_t* __s, const wchar_t* __v) {
N#ifndef _RWSTD_NO_WCSSTR
N        return _RWSTD_C::wcsstr (__s, __v);
X        return std::wcsstr (__s, __v);
N#elif defined (__hpux)
X#elif 0L
S        return wcswcs (__s, __v);
S#else
S        _RWSTD_C::size_t __len1 = _STD::char_traits<wchar_t>::length (__s);
S        _RWSTD_C::size_t __len2 = _STD::char_traits<wchar_t>::length (__v);
S
S        for (const wchar_t *__p = __s; (__p = _RWSTD_C::wcschr (__p, *__v));) {
S            _RWSTD_C::size_t __off = __p - __s;
S            if (__len1 - __off < __len2)
S                break;
S            if (0 == _RWSTD_C::memcmp (__p, __v, sizeof *__v * __len2))
S                return __p;
S            ++__p;
S        }
S        return 0;
S
N#endif   // _RWSTD_NO_WCSSTR
N    }
N
N    static const wchar_t* rfind (const wchar_t* __s, wchar_t __v, 
N                                _RWSTD_C::size_t __pos) { 
X                                std::size_t __pos) { 
N        const wchar_t* __p = __s + __pos;
N        while (__p >= __s) {
N            if (_STD::char_traits<wchar_t>::eq (*__p, __v))
X            if (std::char_traits<wchar_t>::eq (*__p, __v))
N                return __p;
N            __p--;
N        }
N        return 0;       
N    }
N
N    static _RWSTD_C::size_t find_first_of (const wchar_t* __s, const wchar_t* __v) {
X    static std::size_t find_first_of (const wchar_t* __s, const wchar_t* __v) {
N        return _RWSTD_C::wcscspn (__s, __v);
X        return std::wcscspn (__s, __v);
N    }
N
N    static _RWSTD_C::size_t find_first_not_of (const wchar_t* __s, const wchar_t* __v) {
X    static std::size_t find_first_not_of (const wchar_t* __s, const wchar_t* __v) {
N        return _RWSTD_C::wcsspn (__s, __v);
X        return std::wcsspn (__s, __v);
N    }
N
N};
N#endif /* !defined(_RWSTD_NO_WCSCHR)  && !defined(_RWSTD_NO_WCSSPN) && !defined(_RWSTD_NO_WCSSPN) */
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_TRAITS_H_INCLUDED
N
L 40 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_strref.h" 2
N#include <rw/_defs.h>
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N// chooses either a single global mutex or a mutex per string object
N// or no mutex at all when atomic test-and-set instruction is available
N#if !defined (_RWSTD_MULTI_THREAD) || !defined (_RWSTD_NO_TEST_AND_SET)
X#if !0L || !1L
N#  define _RWSTD_STRING_MUTEX(ignore)   false
N#elif defined (_RWSTD_ONE_STRING_MUTEX)
X#elif 0L
S#  define _RWSTD_STRING_MUTEX(ignore)   __rw_string_mutex
S#else
S#  define _RWSTD_STRING_MUTEX(pstr)     pstr->_C_mutex
N#endif
N
N
Ntemplate< class _CharT,
N          class _Traits _RWSTD_COMPLEX_DEFAULT (char_traits<_CharT>), 
X          class _Traits = char_traits<_CharT>, 
N          class _Allocator _RWSTD_COMPLEX_DEFAULT (allocator<_CharT>) >
X          class _Allocator = allocator<_CharT> >
Nclass basic_string;
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N
N#ifdef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
S
Sextern unsigned long _RWSTD_EXPORT __nullref [];
S#define _NULLREF _RW::__nullref
S
N#else
N
N#define _NULLREF string_type::__nullref
N
N#endif   // _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N
N#if    defined (_RWSTD_MULTI_THREAD)    \
N    && defined (_RWSTD_ONE_STRING_MUTEX) \
N    && defined (_RWSTD_NO_TEST_AND_SET)
X#if    0L        && 0L     && 1L
S
Sextern  __rw_mutex _RWSTD_EXPORT __rw_string_mutex;
S
N#endif   // _MULTI_THREAD && _ONE_STRING_MUTEX && _NO_TEST_AND_SET
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Nstruct __string_ref
N{
N    typedef _CharT                                            char_type;
N    typedef _Allocator                                        allocator_type;
N    typedef _TYPENAME allocator_type::size_type               size_type;
X    typedef typename allocator_type::size_type               size_type;
N    typedef _STD::basic_string<_CharT, _Traits, _Allocator>   string_type;
X    typedef std::basic_string<_CharT, _Traits, _Allocator>   string_type;
N
N#if     defined (_RWSTD_MULTI_THREAD)          \
N    && !defined (_RWSTD_ONE_STRING_MUTEX)      \
N    &&  defined (_RWSTD_NO_TEST_AND_SET)       \
N    && !defined (_RWSTD_NO_STATIC_MUTEX_INIT)
X#if     0L              && !0L          &&  1L           && !0L
S
S    void _C_init (size_type __ref, size_type __cap, size_type __size) {
S
S        _C_cap  = __cap;
S        _C_size = __size;
S
S#  ifndef _RWSTD_NO_STRING_REF_COUNT
S
S        _C_refs = __ref - 1;
S
S        if (0 != _RWSTD_MUTEX_INIT (this->_C_mutex._C_mutex))
S            _RW::__rw_throw (_RWSTD_ERROR_RUNTIME_ERROR,
S                             "synchronization error");
S#  else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S        _RWSTD_UNUSED (__ref);
S#  endif   // _RWSTD_NO_STRING_REF_COUNT
S
S    }
S
S    void _C_destroy () {
S#  ifndef _RWSTD_NO_STRING_REF_COUNT
S
S        _RWSTD_MUTEX_DESTROY (this->_C_mutex._C_mutex);
S
S#  endif   // _RWSTD_NO_STRING_REF_COUNT
S    }
S
N#else
N
N    void _C_init (size_type __ref, size_type __cap, size_type __size) {
N
N#  ifndef _RWSTD_NO_STRING_REF_COUNT
N        _C_refs = __ref - 1;
N#  else
S        _RWSTD_UNUSED (__ref);
N#  endif   // _RWSTD_NO_STRING_REF_COUNT
N
N        _C_cap  = __cap;
N        _C_size = __size;
N    }
N
N    void _C_destroy () { }
N
N#endif   // _MULTI_THREAD && !_ONE_STRING_MUTEX && _NO_TEST_AND_SET && ...
N
N    size_type _C_ref_count () const {
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N        return this->_C_refs + 1;
N#else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S        return 0;
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N    }
N
N    void _C_set_ref_count (size_type __ref) { 
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N        if (this != (void*)&_NULLREF)
X        if (this != (void*)&string_type::__nullref)
N            _RWSTD_ATOMIC_SWAP (this->_C_refs, __ref - 1,
N                                _RWSTD_STRING_MUTEX (this));
X            __rw::__rw_atomic_exchange ((this->_C_refs), (__ref - 1), false);
N#else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S        _RWSTD_UNUSED (__ref);
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    }
N
N    void _C_inc_ref () { 
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N        if (this != (void*)&_NULLREF)
X        if (this != (void*)&string_type::__nullref)
N            _RWSTD_ATOMIC_PREINCREMENT (this->_C_refs,
N                                        _RWSTD_STRING_MUTEX (this));
X            ++(this->_C_refs);
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    }
N
N    size_type _C_dec_ref () {
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N        if (this != (void*)&_NULLREF)
X        if (this != (void*)&string_type::__nullref)
N            return 1 + _RWSTD_ATOMIC_PREDECREMENT (this->_C_refs,
N                                                   _RWSTD_STRING_MUTEX (this));
X            return 1 + --(this->_C_refs);
N        return 1;
N#else
S        return 0;
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    }
N
N    size_type size () const {
N        return this->_C_size;
N    }
N
N    size_type capacity () const {
N        return this->_C_cap;
N    }
N
N    char_type* data () {
N        return _RWSTD_REINTERPRET_CAST (char_type*, this + 1);
X        return reinterpret_cast< char_type* >(this + 1);
N    }
N
N    const char_type* data () const {
N        return _RWSTD_REINTERPRET_CAST (const char_type*, this + 1);
X        return reinterpret_cast< const char_type* >(this + 1);
N    }
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N#  if     defined (_RWSTD_MULTI_THREAD)     \
N      && !defined (_RWSTD_ONE_STRING_MUTEX) \
N      &&  defined (_RWSTD_NO_TEST_AND_SET)
X#  if     0L           && !0L       &&  1L
S
S    __rw_mutex_base _C_mutex;
S
N#  endif   // _MULTI_THREAD && !_ONE_STRING_MUTEX && _NO_TEST_AND_SET
N
N    long      _C_refs;      // (1 less than) number of references
N                            // (-1 if reference counting is disabled)
N
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N    size_type _C_cap;       // Size of allocated memory
N
N    union {
N        size_type _C_size;  // number of actual data values stored
N        _CharT    _C_dummy; // force the alignment of the first char
N    };
N};
N
N
N// representation of the null string; will be a POD wherever possible
N// (will not be POD if the reference contains a mutex with a UD-ctor)
Ntemplate <class _CharT, class _Traits , class _Allocator>
Nstruct __null_ref
N    : __string_ref<_CharT, _Traits , _Allocator>
N{
N    // string reference immediately followed by a single terminating null
N    _CharT _C_eos;
N};
N
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#endif   // _RWSTD_STRREF_H_INCLUDED
N
L 41 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N#include <rw/_defs.h>
N#include <rw/_error.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\rw/_error.h" 1
N/**************************************************************************
N *
N * Definition of class except_msg_string
N *
N * This is an internal header file used to implement the C++ Standard
N * Library. It should never be #included directly by a program.
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N ***************************************************************************/
N
N#ifndef _RWSTD_ERROR_H_INCLUDED
N#define _RWSTD_ERROR_H_INCLUDED
N
N#ifndef _RWSTD_NO_INCLUDES
N   // prevent inclusion if compiling a .rc file with MSVC
N#  include <rw/_defs.h>
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// throws an exception identified by first argument, optional arguments
N// (if any) used to format the exception object's what() string
Nvoid _RWSTD_EXPORT __rw_throw (int, ...);
Xvoid  __rw_throw (int, ...);
N
Nextern "C" {
N
N// throws an exception identified by first argument with the second
N// argument containing the exception object's what() string, which
N// if non-zero and the first argument <= _RWSTD_ERROR_BAD_CAST, is
N// dynamically allocated and must be delete[]'d unless the function
N// returns or calls the original throw_proc
N// may be assigned to a user-defined handler (e.g., to prevent
N// the library from throwing exceptions or to implement logging)
Nextern void _RWSTD_EXPORT (*__rw_throw_proc)(int, char*);
Xextern void  (*__rw_throw_proc)(int, char*);
N
N}   // extern "C"
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N#endif   // _RWSTD_NO_INCLUDES
N
N
N#ifndef _RWSTD_ERROR_CATALOG
N   // name of catalog optionally followed by a colon and a set number
N   // catalog looked up according to rules of catopen(3)
N   // may be customized at lib build time (pathname okay)
N#  define _RWSTD_ERROR_CATALOG "rwstderr:1"
N#endif   // _RWSTD_ERROR_CATALOG
N
N#ifndef _RWSTD_ERROR_ENVVAR
N   // environment variable name - overrides _RWSTD_ERROR_CATALOG
N   // may be customized at lib build time
N#  define _RWSTD_ERROR_ENVVAR "RWSTDERR"
N#endif   // _RWSTD_ERROR_ENVVAR
N
N#ifndef _RWSTD_ERROR_FIRST
N   // id of first message - 1, may be customized at lib build time
N#  define _RWSTD_ERROR_FIRST 0
N#endif   // _RWSTD_ERROR_FIRST
N
N
N// these must be macros to accomodate MSVC's resource compiler, with values
N// expected to be consecutive starting with _RWSTD_ERROR_FIRST + 1
N
N// #  define _RWSTD_ERROR_EXCEPTION                   (_RWSTD_ERROR_FIRST +  1)
N// #  define _RWSTD_ERROR_BAD_EXCEPTION               (_RWSTD_ERROR_FIRST +  2)
N// #  define _RWSTD_ERROR_BAD_ALLOC                   (_RWSTD_ERROR_FIRST +  3)
N#  define _RWSTD_ERROR_BAD_CAST                    (_RWSTD_ERROR_FIRST +  4)
N#  define _RWSTD_ERROR_LOGIC_ERROR                 (_RWSTD_ERROR_FIRST +  5)
N#  define _RWSTD_ERROR_DOMAIN_ERROR                (_RWSTD_ERROR_FIRST +  6)
N#  define _RWSTD_ERROR_INVALID_ARGUMENT            (_RWSTD_ERROR_FIRST +  7)
N#  define _RWSTD_ERROR_LENGTH_ERROR                (_RWSTD_ERROR_FIRST +  8)
N#  define _RWSTD_ERROR_OUT_OF_RANGE                (_RWSTD_ERROR_FIRST +  9)
N#  define _RWSTD_ERROR_RUNTIME_ERROR               (_RWSTD_ERROR_FIRST + 10)
N#  define _RWSTD_ERROR_RANGE_ERROR                 (_RWSTD_ERROR_FIRST + 11)
N#  define _RWSTD_ERROR_OVERFLOW_ERROR              (_RWSTD_ERROR_FIRST + 12)
N#  define _RWSTD_ERROR_UNDERFLOW_ERROR             (_RWSTD_ERROR_FIRST + 13)
N
N#  define _RWSTD_ERROR_FAILBIT_SET                 (_RWSTD_ERROR_FIRST + 14)
N#  define _RWSTD_ERROR_BADBIT_SET                  (_RWSTD_ERROR_FIRST + 15)
N#  define _RWSTD_ERROR_EOFBIT_SET                  (_RWSTD_ERROR_FIRST + 16)
N#  define _RWSTD_ERROR_IOSTATE_BIT_SET             (_RWSTD_ERROR_FIRST + 17)
N
N#  define _RWSTD_ERROR_FACET_NOT_FOUND             (_RWSTD_ERROR_FIRST + 18)
N#  define _RWSTD_ERROR_LOCALE_BAD_NAME             (_RWSTD_ERROR_FIRST + 20)
N#  define _RWSTD_ERROR_LOCALE_ERROR_NAME           (_RWSTD_ERROR_FIRST + 21)
N#  define _RWSTD_ERROR_CODECVT                     (_RWSTD_ERROR_FIRST + 22)
N
N#  define _RWSTD_ERROR_BAD_POINTER                 (_RWSTD_ERROR_FIRST + 23)
N
N#  define _RWSTD_ERROR_STRINGS                          \
N          "%s: unspecified error",                      \
N          "%s: exception",                              \
N          "%s: unexpected exception",                   \
N          "%s: bad_alloc: out of memory",               \
N          "%s: bad cast",                               \
N          "%s: logic error",                            \
N          "%s: out of memory",                          \
N          "%s: bad cast",                               \
N          "%s: length error: %u > %u",                  \
N          "%s: argument value %u out of range [0, %u)", \
N          "%s: runtime error",                          \
N          "%s: range error: invalid range [%d, %d)",    \
N          "%s: overflow error",                         \
N          "%s: underflow error",                        \
N          "%s: stream object has set ios::failbit",     \
N          "%s: stream object has set ios::badbit",      \
N          "%s: stream object has set ios::eofbit",      \
N          "%s: stream object has set %s",               \
N          "%s: facet %u not found in \"%s\" locale",    \
N          "%s: bad locale name: \"%s\"",                \
N          "%s: failed to construct locale name",        \
N          "%s: conversion failed",                      \
N          "%s: invalid pointer %p"
X#  define _RWSTD_ERROR_STRINGS                                    "%s: unspecified error",                                "%s: exception",                                        "%s: unexpected exception",                             "%s: bad_alloc: out of memory",                         "%s: bad cast",                                         "%s: logic error",                                      "%s: out of memory",                                    "%s: bad cast",                                         "%s: length error: %u > %u",                            "%s: argument value %u out of range [0, %u)",           "%s: runtime error",                                    "%s: range error: invalid range [%d, %d)",              "%s: overflow error",                                   "%s: underflow error",                                  "%s: stream object has set ios::failbit",               "%s: stream object has set ios::badbit",                "%s: stream object has set ios::eofbit",                "%s: stream object has set %s",                         "%s: facet %u not found in \"%s\" locale",              "%s: bad locale name: \"%s\"",                          "%s: failed to construct locale name",                  "%s: conversion failed",                                "%s: invalid pointer %p"
N
N#define _RWSTD_ERROR_EXCEPTION     "exception"
N#define _RWSTD_ERROR_BAD_EXCEPTION "unexpected exception"
N#define _RWSTD_ERROR_BAD_ALLOC     "bad_alloc: out of memory"
N
N
N#endif   // _RWSTD_ERROR_H_INCLUDED
N
L 43 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string" 2
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nclass basic_string: private _Allocator
N{
Npublic:
N
N    typedef _Traits                               traits_type;
N    typedef _TYPENAME traits_type::char_type      value_type;
X    typedef typename traits_type::char_type      value_type;
N    typedef _Allocator                            allocator_type;
N
Nprivate:
N
N    typedef _RW::__string_ref<value_type, traits_type, allocator_type>
X    typedef __rw::__string_ref<value_type, traits_type, allocator_type>
N     _C_string_ref_type;
N
N    typedef  _RWSTD_ALLOC_TYPE(allocator_type, value_type)          
X    typedef  allocator_type          
N        _C_value_alloc_type;
N    typedef  _RWSTD_REBIND(allocator_type, _C_string_ref_type)  
X    typedef  typename allocator_type::template rebind < _C_string_ref_type > ::other  
N        _C_ref_alloc_type;
N      
Npublic:
N
N    typedef _TYPENAME allocator_type::size_type       size_type;
X    typedef typename allocator_type::size_type       size_type;
N    typedef _TYPENAME allocator_type::difference_type difference_type;
X    typedef typename allocator_type::difference_type difference_type;
N    typedef _TYPENAME allocator_type::reference       reference;
X    typedef typename allocator_type::reference       reference;
N    typedef _TYPENAME allocator_type::const_reference const_reference;
X    typedef typename allocator_type::const_reference const_reference;
N    typedef _TYPENAME allocator_type::pointer         pointer;
X    typedef typename allocator_type::pointer         pointer;
N    typedef _TYPENAME allocator_type::const_pointer   const_pointer;
X    typedef typename allocator_type::const_pointer   const_pointer;
N
N#ifndef _RWSTD_NO_DEBUG_ITER
S
S    typedef _RW::__rw_debug_iter <basic_string, pointer, pointer>
S        iterator;
S    
S    typedef _RW::__rw_debug_iter <basic_string, const_pointer, pointer>
S        const_iterator;
S
S    iterator _C_make_iter (const pointer& __ptr) {
S        return iterator (*this, __ptr);
S    }
S
S    const_iterator _C_make_iter (const const_pointer& __ptr) const {
S        return const_iterator (*this, __ptr);
S    }
S
N#else   // if defined (_RWSTD_NO_DEBUG_ITER)
N
N    typedef pointer                        iterator;
N    typedef const_pointer                  const_iterator;
N
N    iterator _C_make_iter (pointer __ptr) {
N        return __ptr;
N    }
N
N    const_iterator _C_make_iter (const_pointer __ptr) const {
N        return __ptr;
N    }
N
N#endif   // _RWSTD_NO_DEBUG_ITER
N
N
N
N#ifndef _RWSTD_NO_CLASS_PARTIAL_SPEC 
N    typedef _STD::reverse_iterator<const_iterator> const_reverse_iterator;
X    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
N    typedef _STD::reverse_iterator<iterator>       reverse_iterator;
X    typedef std::reverse_iterator<iterator>       reverse_iterator;
N#else
S    typedef _STD::reverse_iterator<const_iterator, 
S      random_access_iterator_tag, value_type, 
S      const_reference, const_pointer, difference_type>
S      const_reverse_iterator;
S    typedef _STD::reverse_iterator<iterator, 
S      random_access_iterator_tag, value_type, 
S      reference, pointer, difference_type>
S      reverse_iterator;
N#endif
N
N#if defined(_RWSTD_LLP64_ARCHITECTURE) && defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT)
X#if 0L && 0L
S    static const size_type npos;
N#else
N    _RWSTD_STATIC_CONST (size_type, npos = size_type(-1));
X    static const size_type npos = size_type(-1);
N#endif    
N
N    _EXPLICIT
X    explicit
N    basic_string (const allocator_type &__alloc = allocator_type ())
N        : allocator_type (__alloc), _C_data (_C_null ()) { }
N
N    // LWG Issue #42.
N    basic_string (const basic_string&);
N
N    basic_string (const basic_string&, size_type, size_type = npos, 
N                  const allocator_type& = allocator_type ());
N
N    basic_string (const_pointer, size_type, 
N                  const allocator_type& = allocator_type ());
N
N    basic_string (const_pointer, const allocator_type& = allocator_type ());
N
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    // pointers to the incomplete types declared below are used
N    // to disambiguate calls to template member functions
N    // requires: member function and class templates
N    //           and partial specialization
N
N    template <class _InputIterator>
N    basic_string (_InputIterator, _InputIterator, 
N                  const allocator_type& = allocator_type ());
N
N    basic_string (int __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned int __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N      : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (long __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned long __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (short __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned short __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (char __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N    basic_string (unsigned char __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {  
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);  
X        _C_initn (static_cast< size_type >(__n), __c);  
N    }
N
N
N#ifndef _RWSTD_NO_NATIVE_WCHAR_T
N
N    basic_string (wchar_t __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N#endif   // _RWSTD_NO_NATIVE_WCHAR_T
N
N
N#ifndef _RWSTD_NO_BOOL
N
N    basic_string (bool __n, value_type __c, 
N                  const allocator_type& __alloc = allocator_type ())
N        : allocator_type (__alloc) {
N        _C_initn (_RWSTD_STATIC_CAST (size_type, __n), __c);
X        _C_initn (static_cast< size_type >(__n), __c);
N    }
N
N#endif   // _RWSTD_NO_BOOL
N
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string (size_type __n, value_type __c, 
S                  const allocator_type& __alloc = allocator_type ())
S      : allocator_type (__alloc) {
S        _C_initn (__n, __c);
S    }
S
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    basic_string (const_pointer, const_pointer, 
N                  const allocator_type& = allocator_type ());
N
N    ~basic_string () {
N        _C_unlink();
N    }
N
N    basic_string& operator= (const basic_string&);
N    basic_string& operator= (const_pointer __s);
N
N    basic_string& operator= (value_type __c) {
N        return replace (0, size(), 1, __c);
N    }
N
N    iterator begin () {
N        _C_cow ();
N        _C_pref ()->_C_set_ref_count (0);   // disable ref counting
N        return _C_make_iter (_C_data);
N    }
N
N    const_iterator begin () const {
N        return _C_make_iter (_C_data);
N    }
N
N    iterator end () {
N        // disable reference counting
N        return begin () + size ();
N    }
N
N    const_iterator end () const {
N        return _C_make_iter (_C_data + size ());
N    }
N
N    reverse_iterator rbegin () {
N        return reverse_iterator (end ());
N    }
N
N    const_reverse_iterator rbegin () const {
N        return const_reverse_iterator (end ());
N    }
N
N    reverse_iterator rend () {
N        return reverse_iterator (begin ());
N    }
N
N    const_reverse_iterator rend () const {
N        return const_reverse_iterator (begin ());
N    }
N
N    size_type size () const {
N        return _C_pref()->_C_size;
N    }
N
N    size_type length () const {
N        return size ();
N    }
N
N    size_type max_size () const {
N        return size_type (npos) - sizeof (_C_string_ref_type) - 2U;
N    }
N
N    void resize (size_type, value_type);
N
N    void resize (size_type __n) {
N        resize (__n, value_type ()); 
N    }
N
N    size_type capacity () const {
N        return _C_pref ()->capacity ();
N    }
N
N    void reserve (size_type = 0);
N
N    void clear () {
N        erase ();
N    }
N
N    bool empty () const  {
N        return size () == 0;
N    }
N
N    const_reference operator[] (size_type) const;
N    reference       operator[] (size_type);
N
N    const_reference at (size_type) const;
N    reference       at (size_type);
N
N    basic_string& operator+= (const basic_string &__s) {
N        return append (__s);
N    }
N
N    basic_string& operator+= (const_pointer __s) {
N        return append (__s);
N    }
N
N    basic_string& operator+= (value_type __c) {
N        return append (size_type (1), __c);
N    }
N
N    basic_string& append (const basic_string&, size_type, size_type);
N
N    basic_string& append (const basic_string &__str);
N
N    basic_string& append (const_pointer __s, size_type __n) {
N        return replace (size (), 0, __s, __n, 0, __n), *this;
N    }
N
N    basic_string& append (const_pointer __s) {
N        return replace (size (), 0, __s);
N    }
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    basic_string& append (_InputIterator __first, _InputIterator __last) {
N        // resolves to append (size_type, value_type) if _InputIterator
N        // is any integral type (even not an exact match, such as char)
N        // the cast to int is necessary to prevent an exact match
N        return append (__first, __last, _RWSTD_DISPATCH (_InputIterator));
X        return append (__first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N    template<class _InputIterator>
N    basic_string& append (_InputIterator __first, _InputIterator __last,
N                          _RWSTD_DISPATCH_INT (false)) {
X                          const __rw::__rw_select < false > *) {
N        return replace (_C_make_iter (_C_data + size ()),
N                        _C_make_iter (_C_data + size ()),
N                        __first, __last), *this;
N    }
N
N    basic_string& append (size_type __n, value_type __c,
N                          _RWSTD_DISPATCH_INT (true)) {
X                          const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        return replace (size (), 0, __n, __c);
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string& append (const_pointer __first, const_pointer __last) {
S        replace (size (), 0, __first, __last - __first, 0, __last - __first);
S        return *this;
S    }
S
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N    basic_string& append (size_type __n, value_type __c) {
N        return replace (size (), 0, __n, __c);
N    }
N
N    void push_back (value_type __c) {
N        append (size_type (1), __c);
N    }
N
N    basic_string& assign (const basic_string &__str) {
N        return *this = __str;
N    }
N
N    basic_string& assign (const basic_string&, size_type, size_type);
N
N    basic_string& assign (const_pointer __s, size_type __n) {
N        return replace (0, size (), __s, __n, 0, __n), *this;
N    }
N
N    basic_string& assign (const_pointer __s) {
N        return *this = __s;
N    }
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    basic_string& assign (_InputIterator __first, _InputIterator __last) {
N        // resolves to assign (size_type, value_type) if _InputIterator
N        // is any integral type (even not an exact match, such as char)
N        // the cast to int is necessary to prevent an exact match
N        return assign (__first, __last, _RWSTD_DISPATCH (_InputIterator));
X        return assign (__first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N    template<class _InputIterator>
N    basic_string& assign (_InputIterator __first, _InputIterator __last,
N                          _RWSTD_DISPATCH_INT (false)) {
X                          const __rw::__rw_select < false > *) {
N        // unnamed arg is used for overload resolution
N        // _RWSTD_COMPILE_ASSERT (sizeof (*__first));
N        return replace (_C_make_iter (_C_data),
N                        _C_make_iter (_C_data + size ()), __first, __last);
N    }
N
N    basic_string& assign (size_type __n, value_type __c,
N                          _RWSTD_DISPATCH_INT (true)) {
X                          const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        return replace (0, size (), __n, __c);
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string& assign (const_pointer __first, const_pointer __last) {
S        replace (size_type (), size (), __first,
S                 __last - __first, size_type (), __last - __first);
S        return *this;
S    }
S
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N
N    basic_string& assign (size_type __n, value_type __c) {
N        return replace (0, size (), __n, __c);
N    }
N
N    basic_string& insert (size_type, const basic_string&);
N    basic_string& insert (size_type, const basic_string&,
N                          size_type, size_type);
N
N    basic_string& insert (size_type __pos, const_pointer __s, size_type __n) {
N        return replace (__pos, 0, __s, __n, 0, __n), *this;
N    }
N
N    basic_string& insert (size_type __pos, const_pointer __s) {
N        return insert (__pos, __s, traits_type::length (__s));
N    }
N
N    // 21.3.5.4, p10
N    iterator insert (iterator __pos, value_type __c) {
N        _RWSTD_ASSERT_RANGE (_C_make_iter (_C_data), __pos);
X        ((void)0);
N        size_type __inx = __pos - _C_make_iter (_C_data);
N        return insert (__inx, &__c, 1), begin () + __inx;
N    }
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    void insert (iterator __p,
N                 _InputIterator __first, _InputIterator __last) {
N        // resolves to insert (iterator, size_type, value_type)
N        // if _InputIterator is any integral type (even not an exact match,
N        // such as char)
N        // the cast to int is necessary to avoid an exact match
N        insert (__p, __first, __last, _RWSTD_DISPATCH (_InputIterator));
X        insert (__p, __first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N    void insert (iterator __p, const_iterator __first, const_iterator __last) {
N        iterator __begin = _C_make_iter (_C_data);
N        iterator __end   = _C_make_iter (_C_data + size ());
N        _RWSTD_ASSERT_RANGE (__begin, __p);
X        ((void)0);
N        if (__first >= __begin && __first <= __end)
N            insert (__p - __begin, basic_string (__first, __last));
N        else
N            replace (__p, __p, __first, __last);
N    }
N
N    void insert (iterator __p, iterator __first, iterator __last) {
N        insert (__p, const_iterator (__first), const_iterator (__last));
N    }
N
N    template <class _InputIterator>
N    void insert (iterator __p, _InputIterator __first, _InputIterator __last,
N                 _RWSTD_DISPATCH_INT (false)) {
X                 const __rw::__rw_select < false > *) {
N        // unnamed arg is used for overload resolution
N        // _RWSTD_COMPILE_ASSERT (sizeof (*__first));
N        replace (__p, __p, __first, __last);
N    }
N
N    void insert (iterator __p, size_type __n, value_type __c,
N                 _RWSTD_DISPATCH_INT (true)) {
X                 const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        replace (__p - _C_make_iter (_C_data), 0, __n, __c);
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    void insert (iterator __p, const_pointer __first, const_pointer __last) {
S        replace (__p - _C_make_iter (_C_data), 0, __first,
S                 __last - __first, 0, __last - __first);
S    }
S
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N    
N
N    void insert (iterator __p, size_type __n, value_type __c) {
N        replace (__p - _C_make_iter (_C_data), 0, __n, __c);
N    }
N
N    basic_string& insert (size_type __pos, size_type __n, value_type __c) {
N        return replace (__pos, 0, __n, __c);
N    }
N
N    basic_string& erase (size_type = 0, size_type = npos);
N
N    iterator erase (iterator __it) { 
N        return replace (__it - _C_make_iter (_C_data), 1,
N                        const_pointer (0), 0, 0, 0);
N    }
N
N    iterator erase (iterator __first, iterator __last) {  
N        return replace (__first - _C_make_iter (_C_data), __last - __first,
N                        const_pointer (0), 0, 0, 0);
N    }
N
Nprivate:  
N
N    iterator replace (size_type, size_type, const_pointer,
N                      size_type, size_type, size_type);
N
N    iterator __replace_aux (size_type pos1, size_type __n1,
N                            const basic_string &__str,
N                            size_type pos2 = 0,
N                            size_type __n2   = npos) {
N        return replace (pos1, __n1, __str.c_str(), __str.size(), pos2, __n2);
N    }
N
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    template<class _InputIterator>
N    basic_string& __replace_aux (iterator       first1,
N                                 iterator       last1, 
N                                 _InputIterator first2,
N                                 _InputIterator last2);
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N  public:
N
N    basic_string& replace (size_type pos1, size_type __n1,
N                           const basic_string &__s,
N                           size_type pos2, size_type __n2) {
N        replace (pos1, __n1, __s.c_str (), __s.size (), pos2, __n2);
N        return *this;
N    }
N
N    basic_string& replace (size_type __pos, size_type __n,
N                           const basic_string &__s) {
N        return replace (__pos, __n, __s, 0, __s.size ());
N    }
N
N
N    basic_string& replace (size_type __pos, size_type __n1, const_pointer __s,
N                           size_type __n2) {
N        return replace (__pos, __n1, __s, __n2, 0, __n2), *this;
N    }
N
N    basic_string& replace (size_type __pos, size_type __n, const_pointer __s) {
N        return replace (__pos, __n, __s, traits_type::length (__s));
N    }
N
N    basic_string& replace (size_type, size_type, size_type, value_type);
N
N    basic_string& replace (iterator __first, iterator __last,
N                           const basic_string &__str) {
N        return replace (__first - _C_make_iter (_C_data),
N                        __last - __first, __str);
N    }
N
N    basic_string& replace (iterator __first, iterator __last,
N                           const_pointer __s, size_type __n) {
N        replace (__first - _C_make_iter (_C_data), __last - __first,
N                 __s, __n, 0, __n);
N        return *this;;
N    }
N
N    basic_string&
N    replace (iterator __first, iterator __last, const_pointer __s) {
N        return replace (__first, __last, __s, traits_type::length(__s));
N    }
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
N    template<class _InputIterator>
N    basic_string& replace (iterator, iterator,
N                           _InputIterator, _InputIterator,
N                           _RWSTD_DISPATCH_INT (false));
X                           const __rw::__rw_select < false > *);
N
N
N    basic_string& replace (iterator __first, iterator __last,
N                           size_type __n, value_type __c,
N                           _RWSTD_DISPATCH_INT (true)) {
X                           const __rw::__rw_select < true > *) {
N        // unnamed arg is used for overload resolution
N        return replace (__first - _C_make_iter (_C_data), __last - __first,
N                        __n, __c);
N    }
N
N    template<class _InputIterator>
N    basic_string& replace (iterator __first1, iterator __last1,
N                           _InputIterator __first2, _InputIterator __last2) {
N        // resolves to replace (iterator, iterator, size_type, value_type)
N        // if _InputIterator is any integral type (even not an exact match,
N        // Such as char)
N        // the cast to int is necessary to prevent an exact match
N        return replace (__first1, __last1, __first2, __last2,
N                        _RWSTD_DISPATCH (_InputIterator));
X                        ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
N    }
N
N#else   // if defined (_RWSTD_NO_MEMBER_TEMPLATES)
S
S    basic_string& replace (iterator first1, iterator last1,
S                           const_pointer first2, const_pointer last2) {
S        return replace (first1 - _C_make_iter (_C_data), last1 - first1,
S                        first2, last2 - first2, 0, last2 - first2), *this;
S    }
S
N#endif  // _RWSTD_NO_MEMBER_TEMPLATES
N
N    basic_string& replace (iterator __first, iterator __last,
N        size_type __n, value_type __c) {
N
N        // unnamed arg is used for overload resolution
N        return replace (__first - _C_make_iter (_C_data), __last - __first,
N                        __n, __c);
N    }
N
N    size_type copy (pointer, size_type, size_type = 0) const;
N
N#ifndef _RWSTD_NO_EXT_DEEP_STRING_COPY
N
N    basic_string copy () const {
N        return basic_string (data (), data () + size ());
N    }
N
N#endif   //_RWSTD_NO_EXT_DEEP_STRING_COPY
N
N    void swap (basic_string &__s) {
N        if (get_allocator () == __s.get_allocator ()) {
N            pointer __temp = _C_data;
N            _C_data = __s._C_data;
N            __s._C_data = __temp;
N        }
N        else {
N            basic_string __tmp = *this;
N            *this = __s;
N            __s = __tmp;
N        }
N    }
N
N    //
N    // string operations
N    //
N    const_pointer c_str () const {
N        return _C_data;
N    }
N
N    const_pointer data () const {
N        return _C_data;
N    }
N
N    allocator_type get_allocator() const {
N        return *this;
N    }
N
N    // 21.3.6.1, p1
N    size_type find (const basic_string &__str, size_type __pos = 0) const {
N        return find (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.1, p4
N    size_type find (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.1, p5
N    size_type find (const_pointer, size_type = 0) const;
N
N    // 21.3.6.1, p7
N    size_type find (value_type, size_type = 0) const;
N
N    // 21.3.6.2, p1
N    size_type rfind (const basic_string &__str, size_type __pos = npos) const {
N        return rfind (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.2, p4
N    size_type rfind (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.2, p5
N    size_type rfind (const_pointer __s, size_type __pos = npos) const {
N        return rfind (__s, __pos, traits_type::length (__s));
N    }
N
N    // 21.3.6.2, p7
N    size_type rfind (value_type, size_type = npos) const;
N
N    // 21.3.6.3, p1
N    size_type find_first_of (const basic_string &__str,
N                             size_type __pos = 0) const {
N        return find_first_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.3, p4
N    size_type find_first_of (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.3, p5
N    size_type find_first_of (const_pointer, size_type = 0) const;
N
N    // 21.3.6.3, p6
N    size_type find_first_of (value_type __c, size_type __pos = 0) const {
N        return find (__c, __pos);
N    }
N
N    // 21.3.6.4, p1
N    size_type find_last_of (const basic_string &__str,
N                            size_type __pos = npos) const {
N        return find_last_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.4, p4
N    size_type find_last_of (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.4, p5
N    size_type find_last_of (const_pointer __s, size_type __pos = npos) const {
N        return find_last_of (__s, __pos, traits_type::length (__s));
N    }
N
N    // 21.3.6.4, p7
N    size_type find_last_of (value_type __c, size_type __pos = npos) const {
N        return rfind (__c, __pos);
N    }
N
N    // 21.3.6.5, p1
N    size_type find_first_not_of (const basic_string &__str, 
N                                 size_type __pos = 0) const {
N        return find_first_not_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.5, p4
N    size_type find_first_not_of (const_pointer, size_type,
N                                 size_type) const;
N
N    // 21.3.6.5, p5
N    size_type find_first_not_of (const_pointer, size_type = 0) const;
N
N    // 21.3.6.5, p7
N    size_type find_first_not_of (value_type, size_type = 0) const;
N
N    // 21.3.6.6, p1
N    size_type find_last_not_of (const basic_string &__str, 
N                                size_type __pos = npos) const {
N        return find_last_not_of (__str.c_str (), __pos, __str.size ());
N    }
N
N    // 21.3.6.6, p4
N    size_type find_last_not_of (const_pointer, size_type, size_type) const;
N
N    // 21.3.6.6, p6
N    size_type find_last_not_of (const_pointer __s,
N                                size_type __pos = npos) const {
N        return find_last_not_of (__s, __pos, traits_type::length (__s));
N    }
N
N    // 21.3.6.6, p7
N    size_type find_last_not_of (value_type, size_type = npos) const;
N  
N    // 21.3.6.7
N    basic_string substr (size_type = 0, size_type = npos) const;
N  
N    int compare (const basic_string &__str) const;
N
N    int compare (size_type __pos, size_type __n, const basic_string &__str) const {
N        return compare (__pos, __n, __str.c_str(), __str.size());
N    }
N
N    int compare (size_type, size_type, const basic_string&, 
N                size_type, size_type) const;
N
N    int compare (const_pointer __s) const {
N        return compare (0, size (), __s, traits_type::length(__s));
N    }
N
N    // LWG Issue #5.
N    int compare (size_type __pos, size_type __n, const_pointer __s) const {
N        return compare(__pos, __n, __s, traits_type::length (__s));
N    }
N
N    int compare (size_type, size_type, const_pointer, size_type) const;
N
Nprotected:
N
N    void _C_cow () {             // Do copy on write as necessary
N        if (_C_pref ()->_C_ref_count() > 1) 
N            _C_clone ();
N    }
N
N    void _C_cow (size_type __nc) {   // Do copy on write w/ new capacity
N        if (_C_pref ()->_C_ref_count () > 1 || capacity () < __nc)
N            _C_clone (__nc);
N    }
N
Nprivate:
N
N    void _C_initn (size_type, value_type);
N
N    void _C_clone (size_type __nc = npos);
N
N    _C_string_ref_type* _C_pref () const { 
N        return _RWSTD_REINTERPRET_CAST (_C_string_ref_type*, _C_data) - 1; 
X        return reinterpret_cast< _C_string_ref_type* >(_C_data) - 1; 
N    }
N
N    void _C_unlink ();   
N
N    friend struct _RW::__string_ref<value_type, traits_type, allocator_type>;
X    friend struct __rw::__string_ref<value_type, traits_type, allocator_type>;
N
N#ifndef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N    static _RW::__null_ref<_CharT, _Traits, _Allocator> __nullref;
X    static __rw::__null_ref<_CharT, _Traits, _Allocator> __nullref;
N
N    static pointer _C_null () {
N        return __nullref.data ();
N    }
N
N#else   // if defined (_RWSTD_NO_COLLAPSE_TEMPLATE_STATICS)
S
S    static pointer _C_null () {
S        typedef _RW::__null_ref<_CharT, _Traits, _Allocator> _NullRef;
S
S        return _RWSTD_REINTERPRET_CAST (_NullRef*, &_RW::__nullref)->data ();
S    }
S
N#endif   // _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N    _C_string_ref_type * _C_getRep (size_type, size_type);
N
N    // for convenience
N    pointer _C_allocate (size_type __cur, size_type __cap, size_type __size) {
N        return _C_getRep (max (size_type (_RW::__rw_new_capacity (__cur, this)),
X        return _C_getRep (max (size_type (__rw::__rw_new_capacity (__cur, this)),
N                               __cap), __size)->data ();
N    }
N
N    pointer _C_data;
N};
N
N
Ntypedef basic_string<char, char_traits<char>, allocator<char> > string;
N
N#ifndef _RWSTD_NO_WCHAR_T
N
Ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
Nwstring;
N
N#endif   // _RWSTD_NO_WCHAR_T
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline void basic_string<_CharT, _Traits, _Allocator>::_C_unlink()
N{
N    _RWSTD_ASSERT (0 != _C_data);
X    ((void)0);
N
N    if (data () == _C_null ())
N        return;
N
N    if (_C_pref ()->_C_ref_count () == 0 || _C_pref ()->_C_dec_ref () == 0) {
N        // Required to pass same size to deallocate as allocate (see string.cc).
N        // Also note that we cannot call capacity() after the destroy() call.
N        size_type __size =
N            capacity () + sizeof (_C_string_ref_type) / sizeof (value_type) + 2;
N
N        // explicitly destroy POD
N        _C_pref ()->_C_destroy ();
N        
N        _C_ref_alloc_type (*this).destroy (_C_pref ());
N        _RWSTD_VALUE_ALLOC (_C_value_alloc_type,
N                            deallocate (_RWSTD_REINTERPRET_CAST (pointer,
N                                                                 _C_pref()),
N                                        __size));
X        allocator_type::deallocate (reinterpret_cast< pointer >(_C_pref()), __size);
N    }
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const basic_string<_CharT, _Traits, _Allocator> &__s)
N    : allocator_type (__s.get_allocator ())
N{
N    if (__s._C_pref()->_C_ref_count () > 0) {
N        _C_data = __s._C_data;
N        _C_pref()->_C_inc_ref ();
N    }
N    else {
N        size_type __n = __s.size();
N        _C_data  = _C_getRep (__n, __n)->data ();
N        traits_type::copy (_C_data, __s.c_str (), __n);
N    }
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::erase (size_type __pos,
N                                                  size_type __n)
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::erase(size_type, size_type)"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    const value_type __tmp =  value_type () ;
N    size_type __len = size () - __pos;
N    return replace (__pos, __n < __len ? __n : __len, &__tmp, 0);
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::const_reference 
Xinline typename basic_string<_CharT, _Traits, _Allocator>::const_reference 
Nbasic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos) const
N{
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S    _RWSTD_REQUIRES (__pos <= size (),
S                     (_RWSTD_ERROR_OUT_OF_RANGE,
S                     _RWSTD_FUNC ("basic_string::operator[](size_type) const"),
S                     __pos, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N    // reference counting still enabled
N    return _C_data [__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::reference
Xinline typename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos)
N{
N#ifdef _RWSTD_BOUNDS_CHECKING
S
S    // 21.3.4, p1 - behavior is undefined if __pos == size ()
S    _RWSTD_REQUIRES (__pos < size (),
S                     (_RWSTD_ERROR_OUT_OF_RANGE,
S                     _RWSTD_FUNC ("basic_string::operator[](size_type)"),
S                     __pos, size ()));
S
N#endif   // _RWSTD_BOUNDS_CHECKING
N
N    // prevent reference counting
N    return begin ()[__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::const_reference
Xinline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
Nbasic_string<_CharT, _Traits, _Allocator>::at (size_type __pos) const
N{
N    _RWSTD_REQUIRES (__pos < size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                     _RWSTD_FUNC ("basic_string::at (size_type) const"),
N                     __pos, size ()));
X    (__pos < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    // reference counting still enabled
N    return _C_data [__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::reference
Xinline typename basic_string<_CharT, _Traits, _Allocator>::reference
Nbasic_string<_CharT, _Traits, _Allocator>::at (size_type __pos)
N{
N    _RWSTD_REQUIRES (__pos < size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                     _RWSTD_FUNC ("basic_string::at (size_type)"),
N                     __pos, size ()));
X    (__pos < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    // prevent reference counting
N    return begin ()[__pos];
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline void
Nbasic_string<_CharT, _Traits, _Allocator>::
Nresize (size_type __n, value_type __c)
N{
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::resize(size_type, "
N                                   "value_type)"), __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (__n < size())
N        erase (__n, size () - __n);
N    else
N        replace (size (), 0, __n - size (), __c);
N}
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline void basic_string<_CharT, _Traits, _Allocator>::
Nreserve (size_type __n)
N{
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::reserve(size_type)"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (__n > capacity ())
N        _C_clone (__n);
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind (const_pointer __s, size_type __pos) const
N{
N    _RWSTD_ASSERT (__s != 0);
X    ((void)0);
N
N    // 21.3.6.1, p1, bullet 1
N    if (__pos > size ())
N        return npos;
N
N    const_pointer __where =
N        _RW::rw_traits<value_type, traits_type>::find (_C_data + __pos, __s);
X        __rw::rw_traits<value_type, traits_type>::find (_C_data + __pos, __s);
N 
N   return __where ? __where - _C_data : npos;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind (value_type __c, size_type __pos) const
N{
N    if (__pos > size())
N        return npos;
N
N    const_pointer __where =  traits_type::find (_C_data + __pos,
N                                                size() - __pos, __c);
N    return __where ? __where  - _C_data : npos;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nrfind (value_type __c, size_type __pos) const
N{
N    if (!size ())
N        return npos;
N
N    if (__pos >= size ())
N        __pos = size () - 1;   // start at the last valid position
N
N    const_pointer __where =
N        _RW::rw_traits<value_type, traits_type>::rfind (_C_data,
X        __rw::rw_traits<value_type, traits_type>::rfind (_C_data,
N                                                        __c, __pos);
N    return __where ? __where - _C_data : npos;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_of (const_pointer __s, size_type __pos) const
N{
N    _RWSTD_ASSERT (__s != 0);
X    ((void)0);
N
N    if (__pos > size())
N        return npos;
N
N    typedef _RW::rw_traits<_CharT, _Traits> __rw_traits;
X    typedef __rw::rw_traits<_CharT, _Traits> __rw_traits;
N
N    size_type __i = __rw_traits::find_first_of (_C_data + __pos, __s) + __pos;
N
N    return __i >= size () ? npos : __i;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_not_of (const_pointer __s, size_type __pos) const
N{
N    _RWSTD_ASSERT (__s != 0);
X    ((void)0);
N
N    if (__pos > size())
N        return npos;
N
N    typedef _RW::rw_traits<_CharT, _Traits> __rw_traits;
X    typedef __rw::rw_traits<_CharT, _Traits> __rw_traits;
N    
N    size_type __i = __rw_traits::find_first_not_of(_C_data + __pos, __s)+ __pos;
N
N    return __i >= size () ? npos : __i;
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_not_of (value_type __c, size_type __pos) const
N{
N    return find_first_not_of (&__c, __pos, 1);
N}
N
N
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xinline typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_last_not_of (value_type __c, size_type __pos) const
N{
N#if 0
S    // disabled to work around a bug in several compilers
S    const value_type __tmp [] = { __c, value_type () };
N#else
N    value_type __tmp [2];
N    traits_type::assign (__tmp [0], __c);
N    traits_type::assign (__tmp [1], value_type ());
N#endif   // 0/1
N
N    return find_last_not_of (__tmp, __pos);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline void
Nbasic_string<_CharT, _Traits, _Allocator>::
N_C_clone (size_type __nc /* = npos */)
N{
N    size_type __len = size();
N    _C_string_ref_type * __temp = _C_getRep (npos == __nc ? size () : __nc,
N                                             __len > __nc ? __nc : __len);
N    traits_type::copy (__temp->data(), _C_data, size());
N    _C_unlink ();
N    _C_data = __temp->data ();
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline int
Nbasic_string<_CharT, _Traits, _Allocator>::
Ncompare (const basic_string &__str) const
N{
N    int __res = traits_type::compare (data (), __str.data (),
N                                      _STD::min (size (), __str.size ()));
X                                      std::min (size (), __str.size ()));
N
N    if (0 == __res)
N        __res = size () < __str.size () ? -1 : size () != __str.size ();
N
N    return __res;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::append (const basic_string &__str)
N{
N    size_type __len = size () + __str.size ();
N    if (__len > capacity () || _C_pref ()->_C_ref_count () > 1)
N        return append (__str, 0, __str.size ());
N
N    traits_type::copy (_C_data + size (), __str.data (), __str.size () + 1);
N    _C_pref ()->_C_size = __len;
N    return *this;
N}
N
N
N// 21.3.7.1, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const basic_string<_CharT, _Traits, _Allocator> &__lhs, 
N           const basic_string<_CharT, _Traits, _Allocator> &__rhs)
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> string_type;
N
N    // prevent reference counting while creating a copy of lhs
N    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
N}
N
N
N// 21.3.7.1, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const _CharT*                                    __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
N}
N
N
N// 21.3.7.1, p4
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (_CharT                                           __lhs,
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return basic_string<_CharT, _Traits, _Allocator>(1, __lhs) += __rhs;
N}
N
N
N// 21.3.7.1, p5
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const _CharT*                                    __rhs)
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> string_type;
N
N    // prevent reference counting while creating a copy of lhs
N    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
N}
N
N
N// 21.3.7.1, p7
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Noperator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           _CharT                                           __rhs)
N{
N    typedef basic_string<_CharT, _Traits, _Allocator> string_type;
N
N    // prevent reference counting while creating a copy of lhs
N    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
N}
N
N
N// 21.3.7.2, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return __lhs.size () == __rhs.size () && 0 == __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.2, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator== (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return 0 == __rhs.compare (__lhs);
N}
N
N
N// 21.3.7.2, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return 0 == __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.4, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return 0 > __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.4, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator< (const _CharT*                                    __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return 0 < __rhs.compare (__lhs);
N}
N
N
N// 21.3.7.4, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
N           const _CharT*                                    __rhs)
N{
N    return 0 > __lhs.compare (__rhs);
N}
N
N
N// 21.3.7.3, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N
N// 21.3.7.5, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return __rhs < __lhs;
N}
N
N
N// 21.3.7.6, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N
N// 21.3.7.7, p1
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N// 21.3.7.8, p1
N#ifndef _RWSTD_NO_PART_SPEC_OVERLOAD
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline void swap (basic_string<_CharT, _Traits, _Allocator>& __a, 
N                  basic_string<_CharT, _Traits, _Allocator>& __b)
N{
N    __a.swap (__b);
N}
N
N#endif   // _RWSTD_NO_PART_SPEC_OVERLOAD
N
N
N// 21.3.7.3, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator!= (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N
N// 21.3.7.3, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return !(__lhs == __rhs);
N}
N
N
N// 21.3.7.5, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator> (const _CharT*                                    __lhs, 
N           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return __rhs < __lhs;
N}
N
N
N// 21.3.7.5, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N           const _CharT*                                    __rhs)
N{
N    return __rhs < __lhs;
N}
N
N
N// 21.3.7.6, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator<= (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N
N// 21.3.7.6, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return !(__rhs < __lhs);
N}
N
N
N// 21.3.7.7, p2
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator>= (const _CharT*                                    __lhs, 
N            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N
N// 21.3.7.7, p3
Ntemplate <class _CharT, class _Traits , class _Allocator>
Ninline bool
Noperator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
N            const _CharT*                                    __rhs)
N{
N    return !(__lhs < __rhs);
N}
N
N
N// 21.3.7.9, p3 - declared here, defined inline in <ostream>
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ninline basic_ostream<_CharT, _Traits>&
Noperator<< (basic_ostream<_CharT, _Traits>&,
N            const basic_string<_CharT, _Traits, _Allocator>&);
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N_USING (namespace std);
Xusing namespace std;
N
N
N#ifndef _RWSTD_NO_FUNC_PARTIAL_SPEC
N
N// more specialized version for basic_string<>; may be further specialized
N// in user code for example on a user-defined allocator
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline size_t
N__rw_new_capacity (size_t __size,
N                   const basic_string<_CharT, _Traits, _Allocator>*)
N{
N    size_t __cap =
N        _RWSTD_STATIC_CAST (size_t, _RWSTD_INCREASE_STRING_CAPACITY(__size)
N                                    /*__size * _RWSTD_STRING_CAPACITY_RATIO*/);
X        static_cast< size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));
N    return (__size += _RWSTD_MINIMUM_STRING_CAPACITY) > __cap ? __size : __cap;
X    return (__size += std::size_t (128)) > __cap ? __size : __cap;
N}
N
N#else   // if defined (_RWSTD_NO_FUNC_PARTIAL_SPEC)
S
S// the following specializations of the __rw_new_capacity<> function template
S// are provided for char and wchar_t; the general case is given in the <memory>
S
S_RWSTD_SPECIALIZED_FUNCTION
Sinline size_t __rw_new_capacity (size_t __size, const string*)
S{
S    size_t __cap =
S        _RWSTD_STATIC_CAST (size_t, _RWSTD_INCREASE_STRING_CAPACITY(__size)
S                                    /*__size * _RWSTD_STRING_CAPACITY_RATIO*/);
S    return (__size += _RWSTD_MINIMUM_STRING_CAPACITY) > __cap ? __size : __cap;
S}
S
S_RWSTD_SPECIALIZED_FUNCTION
Sinline size_t __rw_new_capacity (size_t __size, const wstring*)
S{
S    size_t __cap =
S        _RWSTD_STATIC_CAST (size_t, _RWSTD_INCREASE_STRING_CAPACITY(__size)
S                                    /*__size * _RWSTD_STRING_CAPACITY_RATIO*/);
S    return (__size += _RWSTD_MINIMUM_STRING_CAPACITY) > __cap  ? __size : __cap;
S}
S
N#endif   // _RWSTD_NO_FUNC_PARTIAL_SPEC
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N#if _RWSTD_DEFINE_TEMPLATE (BASIC_STRING)
X#if 0
S#  include <string.cc>
N#endif
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N_RWSTD_INSTANTIATE_3 (class _RWSTD_EXPORT
N                      basic_string<char, char_traits<char>, allocator<char> >);
Xtypedef void __rw_unused_typedef;
N
N#ifndef _RWSTD_NO_WCHAR_T
N_RWSTD_INSTANTIATE_3 (class _RWSTD_EXPORT
N                      basic_string<wchar_t, char_traits<wchar_t>,
N                                   allocator<wchar_t> >);
Xtypedef void __rw_unused_typedef;
N#endif   // _RWSTD_NO_WCHAR_T
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#endif   // _RWSTD_STRING_INCLUDED
N
L 38 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\bitset" 2
N
N#include <rw/_defs.h>
N#include <rw/_error.h>
N
N#include _RWSTD_CLIMITS
X#include <climits>
N#include _RWSTD_CSTDDEF
X#include <cstddef>
N
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
N// helper, implements bitset<>::count()
N_RWSTD_C::size_t
Xstd::size_t
N__rw_bit_count (const unsigned long*, _RWSTD_C::size_t) _THROWS (());
X__rw_bit_count (const unsigned long*, std::size_t) ;
N
N// helpers, implement bitset<>::operator<<=() and operator>>=()
Nvoid __rw_shl (unsigned long*, _RWSTD_C::size_t, _RWSTD_C::size_t) _THROWS (());
Xvoid __rw_shl (unsigned long*, std::size_t, std::size_t) ;
Nvoid __rw_shr (unsigned long*, _RWSTD_C::size_t, _RWSTD_C::size_t) _THROWS (());
Xvoid __rw_shr (unsigned long*, std::size_t, std::size_t) ;
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
Ntemplate <size_t _Size>
Nclass bitset
N{
N    enum { _C_elembits = CHAR_BIT * sizeof (unsigned long) };
X    enum { _C_elembits = 8 * sizeof (unsigned long) };
N    enum { _C_nelems   = _Size ? 1 + (_Size - 1) / _C_elembits : 0 };
N
N    // must have at least one element even if size is 0
N    unsigned long _C_bits [_C_nelems ? _C_nelems : 1];
N
N    bool _C_valid_pos (size_t __pos) const _THROWS (()) {
X    bool _C_valid_pos (size_t __pos) const  {
N        // prevent warnings if _Size == 0
N        return _Size + 1 > __pos + 1;
N    }
N
Npublic:
N
N    class reference {
N        friend class bitset<_Size>;
N
N        bitset<_Size>& _C_ref;
N        size_t         _C_pos;
N
N        reference (bitset<_Size> &__r, size_t __p) _THROWS (())
X        reference (bitset<_Size> &__r, size_t __p) 
N            : _C_ref (__r), _C_pos (__p) { }
N    public:
N
N        reference& operator= (bool __val) _THROWS (()) {
X        reference& operator= (bool __val)  {
N            return _C_ref.set (_C_pos, __val), *this;
N        }
N
N        reference& operator= (const reference &__rhs) _THROWS (()) {
X        reference& operator= (const reference &__rhs)  {
N            return *this = bool (__rhs);
N        }
N
N        bool operator~ () const _THROWS (()) {
X        bool operator~ () const  {
N            return !bool (*this);
N        }
N
N        operator bool () const _THROWS (()) {
X        operator bool () const  {
N            return _RWSTD_CONST_CAST (const bitset<_Size>&, _C_ref)[_C_pos];
X            return const_cast< const bitset<_Size> & >(_C_ref)[_C_pos];
N        }
N
N        reference& flip () _THROWS (()) { 
X        reference& flip ()  { 
N            return _C_ref.flip (_C_pos), *this;
N        }
N    };
N
N    // 23.3.5.1, p1
N    bitset () _THROWS (()) {
X    bitset ()  {
N        reset ();
N    }
N
N    // 23.3.5.1, p2
N    bitset (unsigned long __n) _THROWS (()) {
X    bitset (unsigned long __n)  {
N        reset ();
N        _C_bits [0] =
N            __n & (~0UL >> ((_Size > _C_elembits ? 0 :
N                             _C_elembits - _Size % _C_elembits) % _C_elembits));
N    }
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
N    // using string::npos below rather than basic_string<...>::npos
N    // to work around a bug in g++ 2.95.2
N
N    // 23.3.5.1, p3
N    template <class _CharT, class _Traits, class _Allocator>
N    _EXPLICIT
X    explicit
N    bitset (const basic_string<_CharT, _Traits, _Allocator>&,
N            _TYPENAME basic_string<_CharT, _Traits,
X            typename basic_string<_CharT, _Traits,
N                                   _Allocator>::size_type = 0,
N            _TYPENAME basic_string<_CharT, _Traits,
X            typename basic_string<_CharT, _Traits,
N                                   _Allocator>::size_type = string::npos);
N#else
S
S    // 23.3.5.1, p3
S    _EXPLICIT bitset (const string&, size_t = 0, size_t = (size_t (-1)));
S
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N
N    // 23.3.5.2, p1
N    bitset& operator&= (const bitset &__rhs) _THROWS (()) {
X    bitset& operator&= (const bitset &__rhs)  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            _C_bits [__i] &= __rhs._C_bits [__i];
N        return *this;
N    }
N
N    // 23.3.5.2, p3
N    bitset& operator|= (const bitset &__rhs) _THROWS (()) {
X    bitset& operator|= (const bitset &__rhs)  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            _C_bits[__i] |= __rhs._C_bits [__i];
N        return *this;
N    }
N
N    // 23.3.5.2, p5
N    bitset& operator^= (const bitset& __rhs) _THROWS (()) {
X    bitset& operator^= (const bitset& __rhs)  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            _C_bits [__i] ^= __rhs._C_bits [__i];
N        return *this;
N    }
N
N    // 23.3.5.2, p7
N    bitset& operator<<= (size_t) _THROWS (());
X    bitset& operator<<= (size_t) ;
N
N    // 23.3.5.2, p9
N    bitset& operator>>= (size_t) _THROWS (());
X    bitset& operator>>= (size_t) ;
N
N    // 23.3.5.2, p11
N    bitset& set () _THROWS (());
X    bitset& set () ;
N
N    // 23.3.5.2, p13: follows proposed resolution of lwg issue 186
N    bitset& set (size_t, bool = true);
N
N    // 23.3.5.2, p17
N    bitset& reset () _THROWS (()) {
X    bitset& reset ()  {
N        return 1 == _C_nelems ? (void)(_C_bits [0] = 0)
N            : (void)memset (_C_bits, 0, sizeof (_C_bits)), *this;
N    }
N
N    // 23.3.5.2, p19
N    bitset& reset (size_t __pos) {
N        return set (__pos, false);
N    }
N
N    // 23.3.5.2, p23
N    bitset operator~ () const _THROWS (()) {
X    bitset operator~ () const  {
N        return bitset (*this).flip ();
N    }
N
N    // 23.3.5.2, p25
N    bitset& flip () _THROWS (()) {
X    bitset& flip ()  {
N        for (size_t __i = 0; __i != _C_nelems; __i++) 
N            _C_bits [__i] = ~_C_bits [__i];
N        _C_bits [_C_nelems - !!_C_nelems] &=
N            ~0UL >> (_C_elembits - _Size % _C_elembits) % _C_elembits;
N        return *this;
N    }
N
N    // 23.3.5.2, p27
N    bitset& flip (size_t __pos) {
N        _RWSTD_REQUIRES (_C_valid_pos (__pos),
N                         (_RWSTD_ERROR_OUT_OF_RANGE,
N                          _RWSTD_FUNC ("bitset::flip(size_t)"),
N                          __pos, _C_nelems));
X        (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);
N
N        _C_bits [__pos / _C_elembits] ^= 1UL << __pos % _C_elembits;
N        return *this;
N    }
N
N    // 23.3.5.2, p??
N    bool operator[] (size_t __pos) const _THROWS (()) {
X    bool operator[] (size_t __pos) const  {
N        _RWSTD_ASSERT (_C_valid_pos (__pos));
X        ((void)0);
N        return !!(_C_bits [__pos / _C_elembits] & (1UL << __pos % _C_elembits));
N    }
N
N    // 23.3.5.2, p??
N    reference operator[] (size_t __pos) _THROWS (()) {
X    reference operator[] (size_t __pos)  {
N        _RWSTD_ASSERT (_C_valid_pos (__pos));
X        ((void)0);
N        return reference (*this, __pos); 
N    }
N
N    // 23.3.5.2, p31
N    unsigned long to_ulong () const;
N
N#if    !defined (_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
X#if    !0L     && !0L
N
N    // 23.3.5.2, p33
N    template <class _CharT, class _Traits, class _Allocator>
N    basic_string<_CharT, _Traits, _Allocator> to_string () const;
N
N# define _RWSTD_BITSET_TO_STRING(char_type) \
N    template to_string<char_type, _Traits, allocator <char_type> > ()
X# define _RWSTD_BITSET_TO_STRING(char_type)     template to_string<char_type, _Traits, allocator <char_type> > ()
N
N#else
S
S    // 23.3.5.2, p33
S    string to_string () const;
S
S# define _RWSTD_BITSET_TO_STRING(ignore)  to_string ()
S
N#endif   // !_RWSTD_NO_MEMBER_TEMPLATES && !_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N    // 23.3.5.2, p35
N    size_t count () const _THROWS (()) {
X    size_t count () const  {
N        return _Size ? _RW::__rw_bit_count (_C_bits, _C_nelems) : 0;
X        return _Size ? __rw::__rw_bit_count (_C_bits, _C_nelems) : 0;
N    }
N
N    // 23.3.5.2, p36
N    size_t size () const _THROWS (()) {
X    size_t size () const  {
N        return _Size;
N    }
N
N    // 23.3.5.2, p37
N    bool operator== (const bitset& __rhs) const _THROWS (()) {
X    bool operator== (const bitset& __rhs) const  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            if (_C_bits [__i] != __rhs._C_bits [__i])
N                return false;
N        return true;
N    }
N
N    // 23.3.5.2, p38
N    bool operator!= (const bitset& __rhs) const _THROWS (()) {
X    bool operator!= (const bitset& __rhs) const  {
N        return !(*this == __rhs);
N    }
N
N    // 23.3.5.2, p39
N    bool test (size_t __pos) const {
N        _RWSTD_REQUIRES (_C_valid_pos (__pos),
N                         (_RWSTD_ERROR_OUT_OF_RANGE,
N                          _RWSTD_FUNC ("bitset::test(size_t) const"),
N                          __pos, _C_nelems));
X        (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);
N
N        return !!(_C_bits [__pos / _C_elembits] & (1UL << __pos % _C_elembits));
N    }
N
N    // 23.3.5.2, p42
N    bool any () const _THROWS (()) {
X    bool any () const  {
N        for (size_t __i = 0; __i != _C_nelems; ++__i)
N            if (_C_bits [__i])
N                return true;
N        return false;
N    }
N
N    // 23.3.5.2, p43
N    bool none () const _THROWS (()) {
X    bool none () const  {
N        return !any ();
N    }
N
N    // 23.3.5.2, p44
N    bitset operator<< (size_t __pos) const _THROWS (()) {
X    bitset operator<< (size_t __pos) const  {
N        return bitset (*this) <<= __pos;
N    }
N
N    // 23.3.5.2, p45
N    bitset operator>> (size_t __pos) const _THROWS (()) {
X    bitset operator>> (size_t __pos) const  {
N        return bitset (*this) >>= __pos;
N    }
N};
N
N
N// 23.3.5.2, p11
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::set () _THROWS (())
Xbitset<_Size>::set () 
N{
N    if (_C_nelems == 1)
N        _C_bits [0] = ~0;
N    else
N        memset (_C_bits, ~0, sizeof _C_bits);
N
N    _C_bits [_C_nelems - !!_C_nelems] >>=
N        (_C_elembits - _Size % _C_elembits) % _C_elembits;
N
N    return *this;
N}
N
N
N// 23.3.5.2, p13
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::set (size_t __pos, bool __val)
N{
N    _RWSTD_REQUIRES (_C_valid_pos (__pos),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("bitset::set(size_t, bool)"),
N                      __pos, _C_nelems));
X    (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);
N
N    if (__val)
N        _C_bits [__pos / _C_elembits] |=  (1UL << __pos % _C_elembits);
N    else
N        _C_bits [__pos / _C_elembits] &= ~(1UL << __pos % _C_elembits);
N    return *this;
N}
N
N
N// 23.3.5.2, p7
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::operator<<= (size_t __n) _THROWS (())
Xbitset<_Size>::operator<<= (size_t __n) 
N{
N    if (_Size > _C_elembits)
N        _RW::__rw_shl (_C_bits, _C_nelems, __n);
X        __rw::__rw_shl (_C_bits, _C_nelems, __n);
N    else
N        _C_bits [0] <<= __n;
N
N    // clear bits shifted past the MSB
N    if (_Size % _C_elembits) {
N        // prevent warnings about shifting too far
N        _C_bits [_C_nelems - 1] &=
N            ~0UL >> (_C_elembits - _Size % _C_elembits) % _C_elembits;
N    }
N    return *this;
N}
N
N
N// 23.3.5.2, p9
Ntemplate <size_t _Size>
Ninline bitset<_Size>&
Nbitset<_Size>::operator>>= (size_t __n) _THROWS (())
Xbitset<_Size>::operator>>= (size_t __n) 
N{
N    if (_Size > _C_elembits)
N        _RW::__rw_shr (_C_bits, _C_nelems, __n);
X        __rw::__rw_shr (_C_bits, _C_nelems, __n);
N    else
N        _C_bits [0] >>= __n;
N    return *this;
N}
N
N
N// 23.3.5.2, p31
Ntemplate <size_t _Size>
Ninline unsigned long
Nbitset<_Size>::to_ulong () const
N{
N    // add 1 to prevent warnings about pointless comparison with 0
N    for (size_t __i = 1; __i + 1 < _C_nelems + 1; ++__i)
N        _RWSTD_REQUIRES (!_C_bits[__i],
N                         (_RWSTD_ERROR_OVERFLOW_ERROR,
N                          _RWSTD_FUNC ("bitset::to_ulong() const")));
X        (!_C_bits[__i]) ? (void)0 : __rw::__rw_throw ((0 + 12), "", "");
N
N    return _C_bits [0];
N} 
N
N
N#if    !defined (_RWSTD_NO_MEMBER_TEMPLATES) \
N    && !defined (_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE)
X#if    !0L     && !0L
N
N// 23.3.5.2, p33
Ntemplate <size_t _Size>
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ninline basic_string<_CharT, _Traits, _Allocator>
Nbitset<_Size>::to_string () const 
N{
N    // extension: allocate but do not initialize
N    basic_string<_CharT, _Traits, _Allocator> __s ((_CharT*)0, _Size);
N
N    for (size_t __i = 0; __i != _Size; ++__i)
N        _Traits::assign (__s [_Size - 1 - __i], (*this)[__i] ? '1' : '0');
N
N    return __s;
N}
N
N#else   // _RWSTD_NO_MEMBER_TEMPLATES || _RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
S
S// 23.3.5.2, p33
Stemplate <size_t _Size>
Sinline string bitset<_Size>::to_string () const 
S{
S    // extension: allocate but do not initialize
S    string __s ((char*)0, _Size);
S
S    for (size_t __i = 0; __i != _Size; ++__i)
S        __s [_Size - 1 - __i] = (*this)[__i] ? '1' : '0';
S
S    return __s;
S}
S
N#endif   // !_RWSTD_NO_MEMBER_TEMPLATES && !_RWSTD_NO_TEMPLATE_ON_RETURN_TYPE
N
N
N// 23.3.5.3, p1
Ntemplate <size_t _Size>
Ninline bitset<_Size>
Noperator& (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) _THROWS (())
Xoperator& (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
N{
N    return bitset<_Size>(__lhs) &= __rhs;
N}
N
N
N// 23.3.5.3, p2
Ntemplate <size_t _Size>
Ninline bitset<_Size>
Noperator| (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) _THROWS (())
Xoperator| (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
N{
N    return bitset<_Size>(__lhs) |= __rhs;
N}
N
N
N// 23.3.5.3, p3
Ntemplate <size_t _Size>
Ninline bitset<_Size> 
Noperator^ (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) _THROWS (())
Xoperator^ (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
N{
N    return bitset<_Size>(__lhs) ^= __rhs;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N_RWSTD_NAMESPACE_BEGIN (__rw)
Xnamespace __rw {
N
Ntemplate <class _CharT, class _Traits, size_t _Size> 
N_STD::basic_istream<_CharT, _Traits>&  
Xstd::basic_istream<_CharT, _Traits>&  
N__rw_extract_bitset (_STD::basic_istream<_CharT, _Traits>&,
X__rw_extract_bitset (std::basic_istream<_CharT, _Traits>&,
N                     _STD::bitset<_Size>&);
X                     std::bitset<_Size>&);
N
N_RWSTD_NAMESPACE_END   // __rw
X}   
N
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N#if !defined (_MSC_VER) || _MSC_VER > 1300
X#if !0L || _MSC_VER > 1300
N
N// 23.3.5.3, p8
Ntemplate <class _CharT, class _Traits, size_t _Size> 
Ninline basic_ostream<_CharT,_Traits>&  
Noperator<< (basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
N{
N    return __os << __x._RWSTD_BITSET_TO_STRING (_CharT);
X    return __os << __x. template to_string<_CharT, _Traits, allocator <_CharT> > ();
N}
N
N
N// 23.3.5.3, p4
Ntemplate <class _CharT, class _Traits, size_t _Size> 
Ninline basic_istream<_CharT,_Traits>&  
Noperator>> (basic_istream<_CharT, _Traits>& __strm, bitset<_Size>& __x)
N{
N    return _RW::__rw_extract_bitset (__strm, __x);
X    return __rw::__rw_extract_bitset (__strm, __x);
N}
N
N#else   // if defined (_MSC_VER) && _MSC_VER <= 1300
S
Stemplate <size_t _Size> 
Sinline ostream& operator<< (ostream &__strm, const bitset<_Size>& __x)
S{
S    return __strm << __x._RWSTD_BITSET_TO_STRING (char);
S}
S
Stemplate <size_t _Size> 
Sinline istream& operator>> (istream &__strm, bitset<_Size>& __x)
S{
S    // working around three (yes, 3) MSVC 6.0 bugs
S    istream *__tmp = 0;
S    __tmp = &_RW::__rw_extract_bitset (__strm, __x);
S    return *__tmp;
S}
S
Stemplate <size_t _Size> 
Sinline wostream& operator<< (wostream &__strm, const bitset<_Size>& __x)
S{
S    string __s = __x.to_string ();
S    wstring __tmp (0, __s.length ());   // extension: allocate uninitialzed
S    for (string::size_type __i = 0; __i != __tmp.size (); ++__i)
S        __tmp [__i] = __s [__i];
S    return __strm << __tmp;
S}
S
Stemplate <size_t _Size> 
Sinline wistream& operator>> (wistream &__strm, bitset<_Size>& __x)
S{
S    return _RW::__rw_extract (__strm, __x);
S}
S
N#endif   // !defined (_MSC_VER) || _MSC_VER > 1300
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
N
N#ifdef _RWSTD_COMPILE_INSTANTIATE
S#  include <bitset.cc>
N#endif
N
N
N#endif   // _RWSTD_BITSET_INCLUDED
N
L 5 "MixerController.h" 2
N#include <stdint.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
N      namespace std {
N          #define __CLIBNS std::
N          extern "C" {
N    #else
S      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.2.1 */
S
S    /* minimum values of exact-width signed integer types */
S#define INT8_MIN                   -128
S#define INT16_MIN                -32768
S#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
S#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
S
S    /* maximum values of exact-width signed integer types */
S#define INT8_MAX                    127
S#define INT16_MAX                 32767
S#define INT32_MAX            2147483647
S#define INT64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of exact-width unsigned integer types */
S#define UINT8_MAX                   255
S#define UINT16_MAX                65535
S#define UINT32_MAX           4294967295u
S#define UINT64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.2 */
S
S    /* minimum values of minimum-width signed integer types */
S#define INT_LEAST8_MIN                   -128
S#define INT_LEAST16_MIN                -32768
S#define INT_LEAST32_MIN          (~0x7fffffff)
S#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of minimum-width signed integer types */
S#define INT_LEAST8_MAX                    127
S#define INT_LEAST16_MAX                 32767
S#define INT_LEAST32_MAX            2147483647
S#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of minimum-width unsigned integer types */
S#define UINT_LEAST8_MAX                   255
S#define UINT_LEAST16_MAX                65535
S#define UINT_LEAST32_MAX           4294967295u
S#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.3 */
S
S    /* minimum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MIN           (~0x7fffffff)
S#define INT_FAST16_MIN          (~0x7fffffff)
S#define INT_FAST32_MIN          (~0x7fffffff)
S#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
S
S    /* maximum values of fastest minimum-width signed integer types */
S#define INT_FAST8_MAX             2147483647
S#define INT_FAST16_MAX            2147483647
S#define INT_FAST32_MAX            2147483647
S#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
S
S    /* maximum values of fastest minimum-width unsigned integer types */
S#define UINT_FAST8_MAX            4294967295u
S#define UINT_FAST16_MAX           4294967295u
S#define UINT_FAST32_MAX           4294967295u
S#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
S
S    /* 7.18.2.4 */
S
S    /* minimum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MIN INT64_MIN
S#else
S#define INTPTR_MIN INT32_MIN
S#endif
S
S    /* maximum value of pointer-holding signed integer type */
S#if __sizeof_ptr == 8
S#define INTPTR_MAX INT64_MAX
S#else
S#define INTPTR_MAX INT32_MAX
S#endif
S
S    /* maximum value of pointer-holding unsigned integer type */
S#if __sizeof_ptr == 8
S#define UINTPTR_MAX UINT64_MAX
S#else
S#define UINTPTR_MAX UINT32_MAX
S#endif
S
S    /* 7.18.2.5 */
S
S    /* minimum value of greatest-width signed integer type */
S#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
S
S    /* maximum value of greatest-width signed integer type */
S#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
S
S    /* maximum value of greatest-width unsigned integer type */
S#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
S
S    /* 7.18.3 */
S
S    /* limits of ptrdiff_t */
S#if __sizeof_ptr == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
S#else
S#define PTRDIFF_MIN INT32_MIN
S#define PTRDIFF_MAX INT32_MAX
S#endif
S
S    /* limits of sig_atomic_t */
S#define SIG_ATOMIC_MIN (~0x7fffffff)
S#define SIG_ATOMIC_MAX   2147483647
S
S    /* limit of size_t */
S#if __sizeof_ptr == 8
S#define SIZE_MAX UINT64_MAX
S#else
S#define SIZE_MAX UINT32_MAX
S#endif
S
S    /* limits of wchar_t */
S    /* NB we have to undef and redef because they're defined in both
S     * stdint.h and wchar.h */
S#undef WCHAR_MIN
S#undef WCHAR_MAX
S
S#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
S#else
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   65535
S#endif
S
S    /* limits of wint_t */
S#define WINT_MIN (~0x7fffffff)
S#define WINT_MAX 2147483647
S
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !1L || 0L
S
S    /* 7.18.4.1 macros for minimum-width integer constants */
S#define INT8_C(x)   (x)
S#define INT16_C(x)  (x)
S#define INT32_C(x)  (x)
S#define INT64_C(x)  __INT64_C(x)
S
S#define UINT8_C(x)  (x ## u)
S#define UINT16_C(x) (x ## u)
S#define UINT32_C(x) (x ## u)
S#define UINT64_C(x) __UINT64_C(x)
S
S    /* 7.18.4.2 macros for greatest-width integer constants */
S#define INTMAX_C(x)  __ESCAPE__(x ## ll)
S#define UINTMAX_C(x) __ESCAPE__(x ## ull)
S
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
N         }  /* extern "C" */
N      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
N    #ifndef __STDINT_NO_EXPORTS
N      using ::std::int8_t;
N      using ::std::int16_t;
N      using ::std::int32_t;
N      using ::std::int64_t;
N      using ::std::uint8_t;
N      using ::std::uint16_t;
N      using ::std::uint32_t;
N      using ::std::uint64_t;
N      using ::std::int_least8_t;
N      using ::std::int_least16_t;
N      using ::std::int_least32_t;
N      using ::std::int_least64_t;
N      using ::std::uint_least8_t;
N      using ::std::uint_least16_t;
N      using ::std::uint_least32_t;
N      using ::std::uint_least64_t;
N      using ::std::int_fast8_t;
N      using ::std::int_fast16_t;
N      using ::std::int_fast32_t;
N      using ::std::int_fast64_t;
N      using ::std::uint_fast8_t;
N      using ::std::uint_fast16_t;
N      using ::std::uint_fast32_t;
N      using ::std::uint_fast64_t;
N      using ::std::intptr_t;
N      using ::std::uintptr_t;
N      using ::std::intmax_t;
N      using ::std::uintmax_t;
N    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 6 "MixerController.h" 2
N
Nclass MixerController {
N	public:
N		///Correspondencia entre los bits y botones. LSB a MSB
N		enum ButtonIndices {
N			BUTTON_INDEX_PROGRAM0,
N			BUTTON_INDEX_PROGRAM1,
N			BUTTON_INDEX_PROGRAM2,
N			BUTTON_INDEX_PROGRAM3,
N			BUTTON_INDEX_PROGRAM4,
N			BUTTON_INDEX_PROGRAM5,
N			BUTTON_INDEX_PROGRAM6,
N			BUTTON_INDEX_PROGRAM7,
N			
N			BUTTON_INDEX_PREVIEW0,
N			BUTTON_INDEX_PREVIEW1,
N			BUTTON_INDEX_PREVIEW2,
N			BUTTON_INDEX_PREVIEW3,
N			BUTTON_INDEX_PREVIEW4,
N			BUTTON_INDEX_PREVIEW5,
N			BUTTON_INDEX_PREVIEW6,
N			BUTTON_INDEX_PREVIEW7,
N			
N			BUTTON_INDEX_RESERVED0,
N			BUTTON_INDEX_RESERVED1,
N			BUTTON_INDEX_TRANSITION,
N			BUTTON_INDEX_CUT,
N			BUTTON_INDEX_RESERVED4,
N			BUTTON_INDEX_RESERVED5,
N			BUTTON_INDEX_RESERVED6,
N			BUTTON_INDEX_RESERVED7,
N			
N			//Add here
N			
N			BUTTON_INDEX_COUNT
N		};
N		
N		///Correspondencia entre los bits y leds. LSB a MSB
N		enum LedIndices {
N			LED_INDEX_PREVIEW0,
N			LED_INDEX_PREVIEW1,
N			LED_INDEX_PREVIEW2,
N			LED_INDEX_PREVIEW3,
N			LED_INDEX_PREVIEW4,
N			LED_INDEX_PREVIEW5,
N			LED_INDEX_PREVIEW6,
N			LED_INDEX_PREVIEW7,
N			
N			LED_INDEX_PROGRAM0,
N			LED_INDEX_PROGRAM1,
N			LED_INDEX_PROGRAM2,
N			LED_INDEX_PROGRAM3,
N			LED_INDEX_PROGRAM4,
N			LED_INDEX_PROGRAM5,
N			LED_INDEX_PROGRAM6,
N			LED_INDEX_PROGRAM7,
N			
N			//Add here
N			
N			LED_INDEX_COUNT
N		};
N		
N		static const size_t PROGRAM_CNT = BUTTON_INDEX_PROGRAM7 - BUTTON_INDEX_PROGRAM0 + 1; //8
N		static const size_t PREVIEW_CNT = BUTTON_INDEX_PREVIEW7 - BUTTON_INDEX_PREVIEW0 + 1; //8
N		static const size_t NO_SIGNAL = 0xFFFF;
N		
N		typedef std::bitset<BUTTON_INDEX_COUNT> ButtonState; ///<Tipo que representa el estado ede los botones
N		typedef std::bitset<LED_INDEX_COUNT> LedState; ///<Tipo que representa el estado ede los leds
N		
N		typedef void (*LedStateCallback)(void*, LedState); ///<Prototipo de la funcion a llamar cuando cambie el estado de los leds
N		typedef void (*BusCallback)(void*, size_t); ///<Prototipo de la funcion a llamar cuando cambie el estado de uno de los buses
N		typedef void (*ActionCallback)(void*); ///<Prototipo de la funcion a llamar cuando haya un evento
N	
N		/**
N		 * \brief Constructor
N		 */
N		MixerController(	void* ledUsrPtr = NULL,
X		MixerController(	void* ledUsrPtr = 0,
N											LedStateCallback ledCbk = NULL,
X											LedStateCallback ledCbk = 0,
N											void*	pgmUsrPtr = NULL,
X											void*	pgmUsrPtr = 0,
N											BusCallback pgmCbk = NULL,
X											BusCallback pgmCbk = 0,
N											void*	pvwUsrPtr = NULL,
X											void*	pvwUsrPtr = 0,
N											BusCallback pvwCbk = NULL,
X											BusCallback pvwCbk = 0,
N											void*	cutUsrPtr = NULL,
X											void*	cutUsrPtr = 0,
N											ActionCallback cutCbk = NULL,
X											ActionCallback cutCbk = 0,
N											void*	transUsrPtr = NULL,
X											void*	transUsrPtr = 0,
N											ActionCallback transCbk = NULL );
X											ActionCallback transCbk = 0 );
N			
N			
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de cambio de estado de leds
N		 */
N		void setLedUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de cambio de estado de leds
N		 */
N		void* getLedUserPointer() const;
N			
N		/**
N	   * \brief Establece la funcion a llamar cuando exista un nuevo dato a la entrada
N		 */
N		void setLedCallback(LedStateCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay un nuevo dato a la entrada
N		 */
N		LedStateCallback getLedCallback() const;
N											
N											
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de nueva senal en programa
N		 */
N		void setProgramUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de nueva senal en programa
N		 */
N		void* getProgramUserPointer() const;
N		
N		/**
N	   * \brief Establece la funcion a llamar cuando exista un nuevo dato a la entrada
N		 */
N		void setProgramCallback(BusCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay un nuevo dato a la entrada
N		 */
N		BusCallback getProgramCallback() const;
N		
N		
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de nueva senal en previo
N		 */
N		void setPreviewUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de nueva senal en previo
N		 */
N		void* getPreviewUserPointer() const;
N							
N		/**
N	   * \brief Establece la funcion a llamar cuando exista un nuevo dato a la entrada
N		 */
N		void setPreviewCallback(BusCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay un nuevo dato a la entrada
N		 */
N		BusCallback getPreviewCallback() const;
N
N
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de corte
N		 */
N		void setCutUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de corte
N		 */
N		void* getCutUserPointer() const;
N							
N		/**
N	   * \brief Establece la funcion a llamar cuando hay corte
N		 */
N		void setCutCallback(ActionCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay corte
N		 */
N		ActionCallback getCutCallback() const;	
N		
N		
N		/**
N	   * \brief Establece el puntero que acompaa a las llamadas de transicion
N		 */
N		void setTransitionUserPointer(void* usrPtr);
N		
N		/**
N	   * \brief Devuelve el puntero que acompaa a las llamadas de transicion
N		 */
N		void* getTransitionUserPointer() const;
N							
N		/**
N	   * \brief Establece la funcion a llamar cuando hay transicion
N		 */
N		void setTransitionCallback(ActionCallback cbk);
N		
N		/**
N	   * \brief Devuelve la funcion que se llama cuando hay transicion
N		 */
N		ActionCallback getTransitionCallback() const;	
N											
N											
N			
N		/**
N		 * \brief Procesa el nuevo estado de los botones
N		 */
N		void process(ButtonState buttonState);
N		
N		
N		
N	private:		
N		void*							m_ledUserPtr;
N		LedStateCallback	m_ledCallback;
N	
N		void*							m_programUserPtr;
N		BusCallback				m_programCallback;
N	
N		void*							m_previewUserPtr;
N		BusCallback				m_previewCallback;
N	
N		void*							m_cutUserPtr;
N		ActionCallback		m_cutCallback;
N	
N		void*							m_transitionUserPtr;
N		ActionCallback		m_transitionCallback;
N	
N		ButtonState				m_lastState;
N		size_t						m_program;
N		size_t						m_preview;
N	
N};
N
N#endif //MIXER_CONTROLLER_H_INCLUDED
L 2 "MixerController.cpp" 2
N
N/**
N * \brief Conforma los pulsos de entrada
N * \param prev: Estado antiguo de las senhales
N * \param next: Siguiente estado de las senhales
N * \returns Los bits que hayan cambiado de 0 a 1
N */
Ntemplate<size_t C>
Nstatic std::bitset<C> getRisingEdge(const std::bitset<C>& prev, const std::bitset<C>& next) {
N	return ~prev & next;
N}
N
N
N/**
N * \brief devuelve el indice primer bit a uno
N * \param bs: conjunto de bits donde buscar
N * \param first: primer indice de donde se empieza a buscar. 0 = LSB
N * \param last: ultimo indice (sin incluir) donde se finaliza la busqueda. 0 = LSB
N * \returns indice del primer 1, last en caso de no haber ninguno
N */
Ntemplate<size_t C>
Nstatic size_t firstOne(const std::bitset<C>& bs, size_t first, size_t last) {
N	while(first < last && !bs.test(first)) ++first;
N	return first;
N}
N
N
N
N
NMixerController::MixerController(	void* ledUsrPtr,
N																	LedStateCallback ledCbk,
N																	void*	pgmUsrPtr,
N																	BusCallback pgmCbk,
N																	void*	pvwUsrPtr,
N																	BusCallback pvwCbk,
N																	void*	cutUsrPtr,
N																	ActionCallback cutCbk,
N																	void*	transUsrPtr,
N																	ActionCallback transCbk																	)
N	: m_ledUserPtr(ledUsrPtr)
N	, m_ledCallback(ledCbk)
N	, m_programUserPtr(pgmUsrPtr)
N	, m_programCallback(pgmCbk)
N	, m_previewUserPtr(pvwUsrPtr)
N	, m_previewCallback(pvwCbk)
N	,	m_cutUserPtr(cutUsrPtr)
N	, m_cutCallback(cutCbk)
N	, m_transitionUserPtr(transUsrPtr)
N	, m_transitionCallback(transCbk)
N	, m_program(8)
N	, m_preview(8)
N{
N}
N	
N
N
Nvoid MixerController::setLedUserPointer(void* usrPtr) {
N	m_ledUserPtr = usrPtr;
N}
N
Nvoid* MixerController::getLedUserPointer() const {
N	return m_ledUserPtr;
N}
N
Nvoid MixerController::setLedCallback(LedStateCallback cbk) {
N	m_ledCallback = cbk;
N}
N	
NMixerController::LedStateCallback MixerController::getLedCallback() const {
N	return m_ledCallback;
N}
N									
N
Nvoid MixerController::setProgramUserPointer(void* usrPtr) {
N	m_programUserPtr = usrPtr;
N}
N
Nvoid* MixerController::getProgramUserPointer() const {
N	return m_programUserPtr;
N}
N
Nvoid MixerController::setProgramCallback(BusCallback cbk) {
N	m_programCallback = cbk;
N}
N
NMixerController::BusCallback MixerController::getProgramCallback() const {
N	return m_programCallback;
N}
N	
N
Nvoid MixerController::setPreviewUserPointer(void* usrPtr) {
N	m_previewUserPtr = usrPtr;
N}
N
Nvoid* MixerController::getPreviewUserPointer() const {
N	return m_previewUserPtr;
N}
N					
Nvoid MixerController::setPreviewCallback(BusCallback cbk) {
N		m_previewCallback = cbk;
N}
N
NMixerController::BusCallback MixerController::getPreviewCallback() const {
N	return m_previewCallback;
N}
N
N
Nvoid MixerController::setCutUserPointer(void* usrPtr) {
N	m_cutUserPtr = usrPtr;
N}
N
Nvoid* MixerController::getCutUserPointer() const {
N	return m_cutUserPtr;
N}
N					
Nvoid MixerController::setCutCallback(ActionCallback cbk) {
N		m_cutCallback = cbk;
N}
N
NMixerController::ActionCallback MixerController::getCutCallback() const {
N	return m_cutCallback;
N}
N
N
Nvoid MixerController::setTransitionUserPointer(void* usrPtr) {
N	m_transitionUserPtr = usrPtr;
N}
N
Nvoid* MixerController::getTransitionUserPointer() const {
N	return m_transitionUserPtr;
N}
N					
Nvoid MixerController::setTransitionCallback(ActionCallback cbk) {
N		m_transitionCallback = cbk;
N}
N
NMixerController::ActionCallback MixerController::getTransitionCallback() const {
N	return m_transitionCallback;
N}
N
N
N
Nvoid MixerController::process(ButtonState buttonState) {	
N	//La entrada se encuentra en activo bajo por las resistencias pullup
N	buttonState.flip(); //Cambia a activo alto (negar)
N	
N	//Obtiene los botones que estan en flanco de subida
N	const ButtonState risingEdge = getRisingEdge(m_lastState, buttonState);
N	m_lastState = buttonState;
N	
N	
N	//Obtine los nuevos indices. Encontrar cero ya que los pulsadores estn pullup
N	const size_t newPgm = firstOne(risingEdge, BUTTON_INDEX_PROGRAM0, BUTTON_INDEX_PROGRAM0 + PROGRAM_CNT) - BUTTON_INDEX_PROGRAM0;
N	const size_t newPvw = firstOne(risingEdge, BUTTON_INDEX_PREVIEW0, BUTTON_INDEX_PREVIEW0 + PREVIEW_CNT) - BUTTON_INDEX_PREVIEW0;
N	
N	
N	//Si ha cambiado alguno de ellos llamar a la rutina correspondiente
N	bool updateLeds = false;
N	if(newPgm < PROGRAM_CNT) {
N		//Se ha pulsado algun boton de programa. Si es el mismo desactivar, si no, cambiar
N		updateLeds = true;
N		m_program = (m_program != newPgm) ? newPgm : NO_SIGNAL;
N		
N		//Llamar a la rutina de atencion correspondiente
N		if(m_programCallback) {
N			m_programCallback(m_programUserPtr, m_program);
N		}
N	}
N	if(newPvw < PREVIEW_CNT) {
N		//Se ha pulsado algun boton de previo. Si es el mismo desactivar, si no, cambiar
N		updateLeds = true;
N		m_preview = (m_preview != newPvw) ? newPvw : NO_SIGNAL;
N		
N		//Llamar a la rutina de atencion correspondiente
N		if(m_previewCallback) {
N			m_previewCallback(m_previewUserPtr, m_preview);
N		}
N	}
N	if(risingEdge.test(BUTTON_INDEX_CUT)) {
N		updateLeds = true;
N		std::swap(m_program, m_preview);
N		
N		//Llamar a la rutina de atencion correspondiente
N		if(m_cutCallback) {
N			m_cutCallback(m_cutUserPtr);
N		}
N	}
N	if(risingEdge.test(BUTTON_INDEX_TRANSITION)) {
N		updateLeds = true;
N		std::swap(m_program, m_preview); //TODO llamar cuando se complete la transicion
N		
N		//Llamar a la rutina de atencion correspondiente
N		if(m_transitionCallback) {
N			m_transitionCallback(m_transitionUserPtr);
N		}
N	}
N	
N	
N	//Si el estado de los leds cambia, calcular los nuevos
N	if(updateLeds && m_ledCallback) {
N		LedState ledState;
N		
N		//Calcular los indices de los leds a encender
N		const size_t pgmLed = LED_INDEX_PROGRAM0 + m_program;
N		const size_t pvwLed = LED_INDEX_PREVIEW0 + m_preview;
N		
N		//Solo encender si son validos
N		if(pgmLed < (LED_INDEX_PROGRAM0 + PROGRAM_CNT)) {
N			ledState.set(pgmLed, true);
N		}
N		if(pvwLed < (LED_INDEX_PREVIEW0 + PREVIEW_CNT)) {
N			ledState.set(pvwLed, true);
N		}
N		
N		//Llamar a la funcion
N		m_ledCallback(m_ledUserPtr, ledState);
N	}
N}
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.CC"
N/***************************************************************************
N *
N * string.cc - Definitions for the Standard Library string classes
N *
N * $Id$
N *
N ***************************************************************************
N *
N * Copyright (c) 1994-2001 Rogue Wave Software, Inc.  All Rights Reserved.
N *
N * This computer software is owned by Rogue Wave Software, Inc. and is
N * protected by U.S. copyright laws and other laws and by international
N * treaties.  This computer software is furnished by Rogue Wave Software,
N * Inc. pursuant to a written license agreement and may be used, copied,
N * transmitted, and stored only in accordance with the terms of such
N * license and with the inclusion of the above copyright notice.  This
N * computer software or any other copies thereof may not be provided or
N * otherwise made available to any other person.
N *
N * U.S. Government Restricted Rights.  This computer software is provided
N * with Restricted Rights.  Use, duplication, or disclosure by the
N * Government is subject to restrictions as set forth in subparagraph (c)
N * (1) (ii) of The Rights in Technical Data and Computer Software clause
N * at DFARS 252.227-7013 or subparagraphs (c) (1) and (2) of the
N * Commercial Computer Software--Restricted Rights at 48 CFR 52.227-19,
N * as applicable.  Manufacturer is Rogue Wave Software, Inc., 5500
N * Flatiron Parkway, Boulder, Colorado 80301 USA.
N *
N **************************************************************************/
N
N_RWSTD_NAMESPACE_BEGIN (std)
Xnamespace std {
N
N
N#if    defined (_RWSTD_LLP64_ARCHITECTURE)          \
N    && defined (_RWSTD_NO_STATIC_CONST_MEMBER_INIT) \
N    && defined (_RWBUILD_std)
X#if    0L              && 0L     && 0L
S
Stemplate <class _CharT, class _Traits, class _Allocator>
Sconst _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Sbasic_string<_CharT, _Traits, _Allocator>::npos = size_t(-1);
S
N#elif !defined(_RWSTD_NO_STATIC_CONST_MEMBER_INIT) 
X#elif !0L 
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nconst _TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xconst typename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::npos;
N
N#endif    
N
N
N#ifndef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_RW::__null_ref<_CharT, _Traits, _Allocator>
X__rw::__null_ref<_CharT, _Traits, _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::__nullref;
N
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::_C_string_ref_type *
Xtypename basic_string<_CharT, _Traits, _Allocator>::_C_string_ref_type *
Nbasic_string<_CharT, _Traits, _Allocator>::
N_C_getRep (size_type __cap, size_type __len)
N{
N    _RWSTD_REQUIRES (__cap <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::_C_getRep(size_type, "
N                                   "size_type)"), __cap, max_size ()));
X    (__cap <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __cap, max_size ());
N
N    _RWSTD_REQUIRES (__len <= __cap,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::_C_getRep(size_type, "
N                                   "size_type)"), __len, __cap));
X    (__len <= __cap) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __len, __cap);
N
N    if (!__cap) {
N        _RWSTD_ASSERT (!__len);
X        ((void)0);
N
N#ifndef _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N        return &__nullref;
N
N#else   // if defined (_RWSTD_NO_COLLAPSE_TEMPLATE_STATICS)
S
S        return _RWSTD_REINTERPRET_CAST (_C_string_ref_type*, &_RW::__nullref);
S
N#endif   // _RWSTD_NO_COLLAPSE_TEMPLATE_STATICS
N
N    }
N
N    // allocate, initialize the __string_ref, and initialize each character
N    _C_string_ref_type * __ret =
N    _RWSTD_REINTERPRET_CAST (_C_string_ref_type*,
N            _RWSTD_VALUE_ALLOC (_C_value_alloc_type,
N                                allocate (__cap + sizeof (_C_string_ref_type) /
N                                          sizeof (value_type) + 2)));
X    reinterpret_cast< _C_string_ref_type* >(allocator_type::allocate (__cap + sizeof (_C_string_ref_type) / sizeof (value_type) + 2));
N
N    // avoid copy construction (mutex isn't copy-constructible)
N    // _C_ref_alloc_type (*this).construct (__ret, _C_string_ref_type ());
N    new (__ret) _C_string_ref_type ();
N
N#ifndef _RWSTD_NO_STRING_REF_COUNT
N
N    // set initial reference count to 1
N    __ret->_C_init (1, __cap, __len);
N
N#else   // if defined (_RWSTD_NO_STRING_REF_COUNT)
S
S    // initial reference count is 0 (ref counting disabled)
S    __ret->_C_init (0, __cap, __len);
S
N#endif   // _RWSTD_NO_STRING_REF_COUNT
N
N
N    _RWSTD_VALUE_ALLOC (_C_value_alloc_type, construct (__ret->data () + __len,
N        value_type ()));
X    allocator_type::construct (__ret->data () + __len, value_type ());
N
N    return __ret;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const basic_string &__s, 
N              size_type __pos, size_type __n, const allocator_type& __alloc)
N    : allocator_type (__alloc)
N{
N    _RWSTD_REQUIRES (__pos <= __s.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::basic_string(const "
N                                   "basic_string&, size_type, size_type)"),
N                      __pos, __s.size ()));
X    (__pos <= __s . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, __s . size ());
N
N    size_type __slen = __s.size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N    size_type __nlen =  __n == npos ? 0 : __n;
N    size_type __maxlen = __nlen > __rlen ? __nlen : __rlen; 
N    if (__maxlen)
N        _C_data = _C_allocate (0, __maxlen, __rlen);
N    else
N        _C_data = _C_getRep (__maxlen,__rlen)->data();
N
N    traits_type::copy(_C_data, &__s._C_data[__pos], __rlen);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nvoid basic_string<_CharT, _Traits, _Allocator>::
N_C_initn (size_type __n, value_type __c)
N{
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::_C_initn(size_type, "
N                                   "value_type)"), __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N   
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    while (__n--)
N        traits_type::assign (_C_data [__n], __c);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const_pointer __s, size_type __n, const allocator_type& __alloc)
N    : allocator_type (__alloc)
N{
N    // extension: if `s' is 0 then `n' unitialized elements are allocated
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::basic_string(const_pointer,"
N                                   "size_type, const allocator_type&)"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N    
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    if (__s)
N        traits_type::copy (_C_data, __s, __n);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const_pointer __s, const allocator_type& __alloc)
N    : allocator_type(__alloc)
N{     
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    size_type __n = traits_type::length (__s);
N
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    traits_type::copy (_C_data, __s, __n);
N}
N
N
N#ifndef _RWSTD_NO_MEMBER_TEMPLATES
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Ntemplate <class _InputIterator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (_InputIterator __first, _InputIterator __last, 
N              const allocator_type &__alloc)
N    : allocator_type (__alloc),
N      _C_data (_C_null ())
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N
N    replace (_C_make_iter (_C_data), _C_make_iter (_C_data), __first, __last);
N}
N
N#endif   // _RWSTD_NO_MEMBER_TEMPLATES
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nbasic_string (const_pointer __first, const_pointer __last, 
N              const allocator_type& __alloc)
N    : allocator_type (__alloc)
N{
N    _RWSTD_ASSERT_RANGE (__first, __last);
X    ((void)0);
N    _RWSTD_ASSERT (__first <= __last);
X    ((void)0);
N
N    size_type __n = __last - __first;
N
N    _C_data = __n ? _C_allocate (0, __n, __n) : _C_null ();
N
N    traits_type::copy (_C_data, __first, __n);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::operator= (const basic_string &__rhs)
N{
N    if (__rhs._C_pref ()->_C_ref_count () > 0) {
N        __rhs._C_pref ()->_C_inc_ref ();
N        _C_unlink ();
N        _C_data = __rhs._C_data;
N    }
N    else if (this != &__rhs)
N        replace (0, size (), __rhs.data (), __rhs.size ());
N
N    return *this;
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::operator= (const_pointer __rhs)
N{
N    _RWSTD_ASSERT (__rhs != 0);
X    ((void)0);
N
N    size_type __len = traits_type::length (__rhs);
N
N    if (0 == __len) {
N        if (_C_pref ()->_C_ref_count () == 1) {
N            _C_pref ()->_C_size = 0;
N            traits_type::assign (_C_data [0], value_type ());
N        }
N        else {
N            _C_unlink();
N            _C_data = _C_null ();
N        }
N        return *this;
N    }
N
N    return replace (0, size (), __rhs, __len);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Nappend (const basic_string &__str, size_type __pos, size_type __n)
N{
N    _RWSTD_REQUIRES (__pos <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::append(const basic_string&,"
N                                   " size_type, size_type)"),
N                      __pos, __str.size ()));
X    (__pos <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, __str . size ());
N
N    size_type __slen = __str.size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N
N
N    _RWSTD_REQUIRES (size () <= max_size () - __rlen,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::append(const basic_string&,"
N                                   " size_type, size_type)"),
N                      size (), max_size () - __rlen));
X    (size () <= max_size () - __rlen) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size (), max_size () - __rlen);
N
N    replace(size(), 0, __str.c_str(), __str.size(), __pos, __n);
N
N    return *this;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Nassign (const basic_string &__str, size_type __pos, size_type __n)
N{
N    _RWSTD_REQUIRES (__pos <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::assign(basic_string&, "
N                                   "size_type, size_type)"),
N                      __pos, __str.size ()));
X    (__pos <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, __str . size ());
N
N    size_type __slen = __str.size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N    return replace(0, size(), __str, __pos, __rlen);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Ninsert (size_type __pos1, const basic_string& __str, 
N        size_type  __pos2,  size_type         __n)
N{
N    _RWSTD_REQUIRES (__pos1 <= size() && __pos2 <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, const "
N                                   "basic_string&, size_type, size_type)"), 
N                      __pos1 > size() ? __pos1:__pos2, __str.size ()));
X    (__pos1 <= size() && __pos2 <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos1 > size() ? __pos1:__pos2, __str . size ());
N    
N    size_type __slen = __str.size() - __pos2;
N    size_type __rlen = __n < __slen ? __n : __slen; 
N
N    _RWSTD_REQUIRES (size () <= max_size () - __rlen,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, const "
N                                   "basic_string&, size_type, size_type)"), 
N                      size (), max_size () - __rlen));
X    (size () <= max_size () - __rlen) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size (), max_size () - __rlen);
N
N    return replace(__pos1, 0, __str, __pos2, __n);
N}
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Ninsert (size_type __pos1, const basic_string &__str)
N{
N    _RWSTD_REQUIRES (__pos1 <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, const "
N                                   "basic_string&)"), __pos1, size ()));
X    (__pos1 <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos1, size ());
N    
N    _RWSTD_REQUIRES (size() <= max_size() - __str.size(),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::insert(size_type, "
N                                   "const basic_string&)"),
N                      size (), max_size () - __str.size ()));
X    (size() <= max_size() - __str . size()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size (), max_size () - __str . size ());
N
N    return replace(__pos1, 0, __str);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::iterator 
Xtypename basic_string<_CharT, _Traits, _Allocator>::iterator 
Nbasic_string<_CharT, _Traits, _Allocator>::
Nreplace (size_type __pos1, size_type __n1, const_pointer __cs, 
N         size_type __cslen, size_type __pos2, size_type __n2)
N{
N    _RWSTD_REQUIRES (__pos1 <= size () && __pos2 <= __cslen,
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::replace(size_type, size_type,"
N                                   " const_pointer, size_type, size_type, "
N                                   "size_type)"), 
N                      __pos1 > size() ? __pos1 : __pos2,
N                      size () > __cslen ? size () : __cslen));
X    (__pos1 <= size () && __pos2 <= __cslen) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos1 > size() ? __pos1 : __pos2, size () > __cslen ? size () : __cslen);
N
N    size_type __slen = size() - __pos1;
N    size_type __xlen = __n1 < __slen ? __n1 : __slen; 
N    size_type __clen = __cslen - __pos2;
N    size_type __rlen = __n2 < __clen ? __n2 : __clen; 
N
N    _RWSTD_REQUIRES (size () - __xlen <= max_size () - __rlen,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::replace(size_type, size_type,"
N                                   " const_pointer, size_type, size_type, "
N                                   "size_type)"), 
N                      size () - __xlen, max_size() - __rlen));
X    (size () - __xlen <= max_size () - __rlen) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size () - __xlen, max_size() - __rlen);
N
N    size_type __len = size() - __xlen + __rlen;  // final string length
N
N    if (!__len) {
N        // Special case a substitution that leaves the string empty.
N        _C_unlink ();
N        _C_data = _C_null ();
N    }
N    else {
N        // Length of bit at end of string
N        size_type __rem = size () - __xlen - __pos1;
N        // Check for shared representation, insufficient capacity, 
N        //  or overlap copy.
N        if (   _C_pref()->_C_ref_count () > 1
N            || capacity () < __len
N            || __cs && __cs >= data () && __cs < data () + size ()) {
N            // Need to allocate a new reference.
N            size_t __new_capacity = max (_RW::__rw_new_capacity (size(), this),
X            size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
N                                         size_t (__len));
N            _C_string_ref_type * __temp = _C_getRep(__new_capacity, __len);
N            if (__pos1)
N                traits_type::copy (__temp->data (), _C_data, __pos1);
N
N            if (__rlen)
N                traits_type::copy (__temp->data() + __pos1,
N                                   __cs + __pos2, __rlen);
N
N            if (__rem)
N                traits_type::copy (__temp->data() + __pos1 + __rlen,
N                                   _C_data + __pos1 + __n1, __rem);
N            _C_unlink();
N            _C_data = __temp->data();
N        }
N        else {
N            // Current reference has enough room.
N            if (__rem)
N                traits_type::move (_C_data + __pos1 + __rlen,
N                                   _C_data + __pos1 + __n1, __rem);
N
N            if (__rlen)
N                traits_type::move (_C_data + __pos1, __cs + __pos2, __rlen);
N
N            traits_type::assign (_C_data [_C_pref()->_C_size = __len],
N                                 value_type ());
N        }
N    }
N    return _C_make_iter (_C_data + __pos1);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>&
Nbasic_string<_CharT, _Traits, _Allocator>::
Nreplace (size_type __pos, size_type __n, size_type __n2, value_type __c)
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string:::replace(size_type, "
N                                   "size_type, size_type, value_type)"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N    
N    size_type __slen = size() - __pos;
N    size_type __xlen = __n < __slen ? __n : __slen; 
N
N    _RWSTD_REQUIRES (size() - __xlen < max_size () - __n2,
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::replace(size_type, "
N                                   "size_type, size_type, value_type)"), 
N                      size () - __xlen, max_size () - __n2));
X    (size() - __xlen < max_size () - __n2) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size () - __xlen, max_size () - __n2);
N    
N    size_type __len = size() - __xlen + __n2;  // Final string length.
N
N    if (!__len)
N    {
N      // Special case a substitution that leaves the string empty.
N      _C_unlink();
N      _C_data = _C_null ();
N    }
N    else
N    {
N      size_type __rem = size () - __xlen - __pos; // length of bit at the end
N      // Check for shared representation, insufficient capacity, 
N      if ( (_C_pref()->_C_ref_count() > 1) || (capacity() < __len))
N      {
N        // Need to allocate a new reference.
N          size_t __new_capacity = max (_RW::__rw_new_capacity (size(), this),
X          size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
N                                       size_t (__len));
N        _C_string_ref_type * __temp = _C_getRep(__new_capacity, __len);
N        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
N        if (__n2) traits_type::assign(__temp->data()+__pos, __n2, __c);
N        if (__rem)
N            traits_type::copy (__temp->data () + __pos + __n2,
N                               _C_data + __pos + __n, __rem);
N        _C_unlink();
N        _C_data = __temp->data();
N      }
N      else
N      {
N        // Current reference has enough room.
N        if (__rem) 
N            traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, __rem);
N        if (__n2)
N            traits_type::assign(_C_data+__pos, __n2, __c);
N        traits_type::assign (_C_data [_C_pref()->_C_size = __len],
N                             value_type ());
N      }
N    }
N    return *this;
N}
N
N
N#if     !defined (_RWSTD_NO_MEMBER_TEMPLATES)   \
N     && !defined (_RWSTD_NO_CLASS_PARTIAL_SPEC)
X#if     !0L        && !0L
N
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIter>
Nbasic_string<_CharT, _Traits, _Allocator>& 
Nbasic_string<_CharT, _Traits, _Allocator>::
Nreplace (iterator __first1, iterator __last1,
N         _InputIter __first2, _InputIter __last2, _RWSTD_DISPATCH_INT (false))
X         _InputIter __first2, _InputIter __last2, const __rw::__rw_select < false > *)
N{
N    _RWSTD_ASSERT_RANGE (__first1, _C_make_iter (_C_data + size ()));
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first2, __last2);
X    ((void)0);
N
N     // use a (probably) faster algorithm if possible
N     if (__is_bidirectional_iterator(_RWSTD_ITERATOR_CATEGORY (_InputIter,
N                                                               __last2)))
X     if (__is_bidirectional_iterator(typename std::iterator_traits< _InputIter > ::iterator_category ()))
N         return __replace_aux (__first1, __last1, __first2, __last2);
N
N     for ( ; __first2 != __last2; ++__first1, ++__first2) {
N
N         size_type __off = __first1 - _C_make_iter (_C_data);
N
N         _RWSTD_REQUIRES (__off <= max_size(),
N                          (_RWSTD_ERROR_LENGTH_ERROR,
N                           _RWSTD_FUNC ("basic_string::replace(iterator, "
N                                        "iterator, InputIterator, "
N                                        "InputIterator)"),
N                           __first1 - _C_make_iter (_C_data), max_size ()));
X         (__off <= max_size()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __first1 - _C_make_iter (_C_data), max_size ());
N         
N         // extend the string if necessary
N         if (__first1 == __last1) {
N             // compute the size of new buffer
N             size_t __new_cap = _RW::__rw_new_capacity (size (), this);
X             size_t __new_cap = __rw::__rw_new_capacity (size (), this);
N             size_t __delta   = __new_cap - size ();
N
N             // allocate a new buffer
N             _C_string_ref_type *__tmp = _C_getRep (__new_cap, __new_cap);
N
N             // copy data from old to new, leaving a hole for additions
N             traits_type::copy (__tmp->data (), _C_data, __off);
N             traits_type::copy (__tmp->data () + __off + __delta,
N                                _C_data + __off,
N                                _C_make_iter (_C_data + size ()) - __last1);
N             _C_unlink ();
N             _C_data  = __tmp->data ();
N             __first1 = _C_make_iter (_C_data + __off);
N             __last1  = __first1 + __delta;
N         }
N
N         // copy data over
N         traits_type::assign (*__first1, *__first2);
N     }
N
N     if (__first1 != __last1)
N         replace (__first1 - _C_make_iter (_C_data), __last1 - __first1,
N                  0, value_type ());
N
N     return *this;
N}
N
N// Special function for random access and bi-directional iterators
N// Avoids the possibility of multiple allocations
N// We still have to copy characters over one at a time.
Ntemplate<class _CharT, class _Traits, class _Allocator>
Ntemplate<class _InputIterator>
Nbasic_string<_CharT, _Traits, _Allocator>& 
Nbasic_string<_CharT, _Traits, _Allocator>::
N__replace_aux (iterator __first1, iterator __last1, 
N               _InputIterator __first2, _InputIterator __last2)
N{
N    _RWSTD_ASSERT_RANGE (__first1, _C_make_iter (_C_data + size ()));
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first1, __last1);
X    ((void)0);
N    _RWSTD_ASSERT_RANGE (__first2, __last2);
X    ((void)0);
N
N    difference_type __n2  = _DISTANCE (__first2, __last2, __n2);
X    difference_type __n2  = std::distance (__first2, __last2);
N    size_type       __n   = __last1 - __first1;
N    size_type       __pos = __first1 - _C_make_iter (_C_data);
N
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE,
N                      _RWSTD_FUNC ("basic_string::__replace_aux(iterator, "
N                                   "iterator, InputIterator, InputIterator)"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    size_type __slen = size() - __pos;
N    size_type __xlen = __n < __slen ? __n : __slen; 
N
N    _RWSTD_REQUIRES (size () - __xlen < max_size() - __n2,
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::__replace_aux(iterator, "
N                                   "iterator, InputIterator, InputIterator)"),
N                      size () - __xlen, max_size () - __n2));
X    (size () - __xlen < max_size() - __n2) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", size () - __xlen, max_size () - __n2);
N
N    size_type __len = size() - __xlen + __n2;  // Final string length.
N
N    if (!__len) {
N        // Special case a substitution that leaves the string empty.
N        _C_unlink();
N        _C_data = _C_null ();
N    }
N    else {
N      size_type __d = 0;
N      size_type __rem = size() - __xlen - __pos; // length of bit at the end
N      // Check for shared representation, insufficient capacity, 
N      if ( (_C_pref()->_C_ref_count () > 1) || (capacity() < __len))
N      {
N        // Need to allocate a new reference.
N        size_t __new_capacity = max (_RW::__rw_new_capacity (size(), this),
X        size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
N                                     size_t (__len));
N        _C_string_ref_type * __temp = _C_getRep(__new_capacity, __len);
N        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
N        for (__d = 0; __d < (size_type)__n2; __d++)
N            traits_type::assign (*(__temp->data()+__pos+__d), *__first2++);
N        if (__rem)
N            traits_type::copy (__temp->data () + __pos + __n2,
N                               _C_data + __pos + __n, __rem);
N        _C_unlink();
N        _C_data = __temp->data();
N      }
N      else
N      {
N        // Current reference has enough room.
N        if (__rem)  
N          traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, __rem);
N        for (__d = 0; __d < (size_type)__n2; __d++)
N            traits_type::assign (*(_C_data+__pos+__d), *__first2++);
N        traits_type::assign (_C_data[_C_pref()->_C_size = __len],
N                             value_type());
N      }
N    }
N    return *this;
N}
N
N#endif // _RWSTD_NO_MEMBER_TEMPLATES
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Ncopy (pointer __s, size_type __n, size_type __pos) const
N{
N    _RWSTD_REQUIRES (__pos <= size(),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::copy(pointer, size_type, "
N                                   "size_type)"), __pos, size ()));
X    (__pos <= size()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    size_type __slen = size() - __pos;
N    size_type __rlen = __n < __slen ? __n : __slen;
N    traits_type::copy(__s, _C_data+__pos, __rlen);
N    return __rlen;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    for (size_type xpos = __pos; (xpos + __n) <= size() ; xpos++)
N    {
N      if (!traits_type::compare(_C_data+xpos, __s, __n))
N        return xpos;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nrfind (const_pointer __s,  size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::rfind(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (size() < __n)
N      return npos;
N    
N    size_type __slen = size() -__n;
N    size_type xpos_start = __slen < __pos ? __slen : __pos; 
N
N    for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
N    {
N      if (!traits_type::compare(_C_data+xpos-1, __s, __n))
N        return xpos-1;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_of (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR,
N                      _RWSTD_FUNC ("basic_string::find_first_of(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    for (size_type xpos = __pos; xpos < size() ; xpos++)
N    {
N      for (size_type __i = 0; __i < __n ; __i++)
N        if (traits_type::eq(_C_data[xpos], __s[__i]))
N          return xpos;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_last_of (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find_last_of(const_pointer, "
N                                   "size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    if (size())
N    {
N      size_type __slen = size() -1;
N      size_type xpos_start = __pos < __slen ? __pos : __slen; 
N      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
N      {
N        for(size_type __i = 0; __i < __n ; __i++)
N          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
N            return xpos-1;
N      } 
N    }
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_first_not_of (const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find_first_not_of("
N                                  "const_pointer, size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N
N    for (size_type xpos = __pos; xpos < size() ; xpos++)
N    {
N      bool found = false;
N      for (size_type __i = 0; __i < __n ; __i++)
N      {
N        if (traits_type::eq(_C_data[xpos], __s[__i]))
N        {
N          found = true;
N          break;
N        }
N      }
N      if (!found)
N        return xpos;
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
N_TYPENAME basic_string<_CharT, _Traits, _Allocator>::size_type
Xtypename basic_string<_CharT, _Traits, _Allocator>::size_type
Nbasic_string<_CharT, _Traits, _Allocator>::
Nfind_last_not_of(const_pointer __s, size_type __pos, size_type __n) const
N{
N    _RWSTD_ASSERT(__s != 0);
X    ((void)0);
N
N    _RWSTD_REQUIRES (__n <= max_size (),
N                     (_RWSTD_ERROR_LENGTH_ERROR, 
N                      _RWSTD_FUNC ("basic_string::find_last_not_of("
N                                  "const_pointer, size_type, size_type) const"),
N                      __n, max_size ()));
X    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());
N    
N    if (size())
N    {
N      size_type __slen = size() -1;
N      size_type xpos_start = __pos < __slen ? __pos : __slen; 
N      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
N      {
N        bool found = false;
N        for (size_type __i = 0; __i < __n ; __i++)
N        {
N          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
N          {
N            found = true;
N            break;
N          }
N        }
N        if (!found)
N          return xpos-1;
N      }
N    }
N
N    return npos;
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>
Nbasic_string<_CharT, _Traits, _Allocator>::
Nsubstr (size_type __pos, size_type __n) const
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::substr(size_type, size_type) "
N                                   "const"), __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    size_type __slen = size() -__pos;
N    size_type __rlen = __n < __slen ? __n : __slen;
N    return basic_string (_C_data + __pos, __rlen);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint basic_string<_CharT, _Traits, _Allocator>::
Ncompare (size_type __pos1, size_type __n1, 
N         const basic_string& __str, 
N         size_type __pos2, size_type __n2) const
N{
N    _RWSTD_REQUIRES (__pos2 <= __str.size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::compare(size_type, size_type,"
N                                   "const basic_string&, size_type, size_type) "
N                                   "const"), __pos2, __str.size ()));
X    (__pos2 <= __str . size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos2, __str . size ());
N
N//  "reduce" __n2 if necessary, where
N//  "reduce" := Ensure __pos2+__n2 < __str.size() so we can call a function that
N//              doesn't check this same inequality.
N
N    if(__str.size() - __pos2 < __n2)
N      __n2 = __str.size() - __pos2;
N
N//  compare(size_type, size_type, char*, size_type) will both
N//   (i) check pos1 to make sure it's less than size() and
N//  (ii) "reduce" __n1 if necessary
N
N    return compare(__pos1, __n1, __str.c_str()+__pos2, __n2);
N}
N
N
Ntemplate <class _CharT, class _Traits, class _Allocator>
Nint basic_string<_CharT, _Traits, _Allocator>::
Ncompare (size_type __pos, size_type __n1,
N         const_pointer __s, size_type __n2) const
N{
N    _RWSTD_REQUIRES (__pos <= size (),
N                     (_RWSTD_ERROR_OUT_OF_RANGE, 
N                      _RWSTD_FUNC ("basic_string::compare(size_type, size_type,"
N                                   " const const_pointer, size_type) const"),
N                      __pos, size ()));
X    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());
N
N    if(size() - __pos < __n1)
N      __n1 = size() - __pos;
N    size_type __rlen = __n1 < __n2 ? __n1 : __n2; 
N    int __res = traits_type::compare(_C_data+__pos,__s, __rlen);
N
N    if (__res == 0)
N      __res = (__n1 < __n2) ? -1 : (__n1 != __n2);
N
N    return __res;
N}
N
N
N_RWSTD_NAMESPACE_END   // std
X}   
N
