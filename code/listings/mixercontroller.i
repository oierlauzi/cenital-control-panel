# 1 "MixerController.cpp"
# 1 "mbed/mbed_config.h"












# 1 "MixerController.cpp"
# 1 "MixerController.h"



# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"





























 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\iosfwd"





























 




# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"































 




# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"































 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/config.h"
 
 



# 32 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/config.h"

# 39 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"

















 

 

 
# 67 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"

 








# 83 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"

 

 


 





 






     




# 115 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"

 




 







# 136 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"

































 



 







      


    
   







# 213 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"

   
# 222 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_config.h"


   
   
   
   
   











# 38 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"








# 62 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"













# 107 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"


# 116 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"


# 124 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"



# 181 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"



































   
   
   
# 225 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"
   








# 250 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




















 

# 287 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




















































# 356 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




# 369 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"
























# 402 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"

# 413 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"





# 428 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"
     
     
     























# 490 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"


























# 523 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"



# 542 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"










# 559 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"







# 572 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"

# 580 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"










   
# 599 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"





# 617 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"






















# 654 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"








# 671 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"



   
   























# 706 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




   
   
# 723 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




# 733 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




# 743 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"

# 757 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"












# 776 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"





namespace __rw {

template <bool __b>
struct __rw_compile_assert;

template< >
struct __rw_compile_assert<true> { enum { _C_ok }; };





void 
__rw_assert_fail (const char *__expr,
                       const char *__file, int __line, const char *__func);

}   




# 809 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"

 



# 822 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"










namespace __rw {




template <bool __b>
struct __rw_select { };

template< >
struct __rw_select<true> { };





}   


# 856 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"







   
# 873 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"

# 880 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




# 893 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"




# 909 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"






























# 946 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"


# 956 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"






# 968 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"


# 976 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"


# 1003 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"










# 1022 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"



namespace std {
}   

# 1035 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_defs.h"



# 36 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\iosfwd"









   
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cwchar"



 





 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\wchar.h"
 
 




 













        namespace std {
        extern "C" {





      



        typedef unsigned int size_t;    






# 52 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\wchar.h"


      
      typedef int wint_t;    





         
        
 



# 74 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\wchar.h"




     
     

     



        typedef struct __va_list __va_list;










     

     
      typedef struct __FILE FILE;





    




 





    











 
    typedef struct __mbstate_t {
        unsigned int __state, __state2;
    } mbstate_t;

    


 
    struct tm;
            
    extern __declspec(__nothrow) size_t wcsftime(wchar_t * __restrict  , size_t  ,
                       const wchar_t * __restrict  , const struct tm * __restrict  ) __attribute__((__nonnull__(1,3,4)));


    

 
#pragma __printf_args
    int swprintf(wchar_t * __restrict  , size_t  ,
                 const wchar_t * __restrict  , ...) __attribute__((__nonnull__(3)));
#pragma __printf_args
    int vswprintf(wchar_t * __restrict  , size_t  ,
                  const wchar_t * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));
#pragma __scanf_args
    int swscanf(const wchar_t * __restrict  ,
                const wchar_t * __restrict  , ...) __attribute__((__nonnull__(1,2)));
#pragma __scanf_args
    int vswscanf(const wchar_t * __restrict  ,
                 const wchar_t * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));


#pragma __printf_args
    int fwprintf(struct __FILE * __restrict  ,
                 const wchar_t * __restrict  , ...) __attribute__((__nonnull__(1,2)));
#pragma __printf_args
    int vfwprintf(struct __FILE * __restrict  ,
                  const wchar_t * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
#pragma __scanf_args
    int fwscanf(struct __FILE * __restrict  ,
                const wchar_t * __restrict  , ...) __attribute__((__nonnull__(1,2)));
#pragma __scanf_args
    int vfwscanf(struct __FILE * __restrict  ,
                 const wchar_t * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));


#pragma __printf_args
    int wprintf(const wchar_t * __restrict  , ...) __attribute__((__nonnull__(1)));
#pragma __printf_args
    int vwprintf(const wchar_t * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
#pragma __scanf_args
    int wscanf(const wchar_t * __restrict  , ...) __attribute__((__nonnull__(1)));
#pragma __scanf_args
    int vwscanf(const wchar_t * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));

    

 
    wint_t fgetwc(struct __FILE *  ) __attribute__((__nonnull__(1)));
    wchar_t *fgetws(wchar_t * __restrict  , int  , struct __FILE * __restrict  ) __attribute__((__nonnull__(1,3)));
    wint_t fputwc(wchar_t  , struct __FILE *  ) __attribute__((__nonnull__(2)));
    int fputws(const wchar_t * __restrict  , struct __FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
    int fwide(struct __FILE *  , int  ) __attribute__((__nonnull__(1)));
    wint_t getwc(struct __FILE *  ) __attribute__((__nonnull__(1)));
    wint_t getwchar(void);
    wint_t putwc(wchar_t  , struct __FILE *  ) __attribute__((__nonnull__(2)));
    wint_t putwchar(wchar_t  );
    wint_t ungetwc(wint_t  , struct __FILE *  ) __attribute__((__nonnull__(2)));


    wint_t btowc(int  );
    wint_t wctob(int  );
    int mbsinit(const mbstate_t *  );
    size_t mbrlen(const char * __restrict  , size_t  ,
                  mbstate_t * __restrict  );
    size_t mbrtowc(wchar_t * __restrict  ,
                   const char * __restrict  ,
                   size_t  , mbstate_t * __restrict  );
    size_t wcrtomb(char * __restrict  , wchar_t  ,
                   mbstate_t * __restrict  );
    size_t mbsrtowcs(wchar_t * __restrict  ,
                     const char ** __restrict  ,
                     size_t  , mbstate_t * __restrict  ) __attribute__((__nonnull__(2)));
    size_t wcsrtombs(char * __restrict  ,
                     const wchar_t ** __restrict  ,
                     size_t  , mbstate_t * __restrict  ) __attribute__((__nonnull__(2)));
    size_t _mbsnrtowcs(wchar_t * __restrict  ,
                       const char ** __restrict  ,
                       size_t  ,
                       size_t  , mbstate_t * __restrict  ) __attribute__((__nonnull__(2)));
    size_t _wcsnrtombs(char * __restrict  ,
                       const wchar_t ** __restrict  ,
                       size_t  ,
                       size_t  , mbstate_t * __restrict  ) __attribute__((__nonnull__(2)));

    size_t mbsnrtowcs(wchar_t * __restrict  ,
                      const char ** __restrict  ,
                      size_t  ,
                      size_t  , mbstate_t * __restrict  ) __attribute__((__nonnull__(2)));
    size_t wcsnrtombs(char * __restrict  ,
                      const wchar_t ** __restrict  ,
                      size_t  ,
                      size_t  , mbstate_t * __restrict  ) __attribute__((__nonnull__(2)));


    

 
    double wcstod(const wchar_t *  , wchar_t **  ) __attribute__((__nonnull__(1)));
    float wcstof(const wchar_t *  , wchar_t **  ) __attribute__((__nonnull__(1)));
    long double wcstold(const wchar_t *  , wchar_t **  ) __attribute__((__nonnull__(1)));
    long int wcstol(const wchar_t *  , wchar_t ** ,
                    int  ) __attribute__((__nonnull__(1)));
    unsigned long int wcstoul(const wchar_t *  ,
                              wchar_t **  , int  ) __attribute__((__nonnull__(1)));

    long long int wcstoll(const wchar_t * __restrict  ,
                          wchar_t ** __restrict  , int  ) __attribute__((__nonnull__(1)));
    unsigned long long int wcstoull(const wchar_t * __restrict  ,
                                    wchar_t ** __restrict  ,
                                    int  ) __attribute__((__nonnull__(1)));


    

 
    wchar_t *wcscpy(wchar_t * __restrict  ,
                    const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcsncpy(wchar_t * __restrict  ,
                     const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
    wchar_t *wmemcpy(wchar_t * __restrict  ,
                     const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
    wchar_t *wmemmove(wchar_t * __restrict  ,
                      const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcscat(wchar_t * __restrict  ,
                    const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcsncat(wchar_t * __restrict  ,
                     const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
    int wcscmp(const wchar_t * __restrict  ,
               const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    int wcsncmp(const wchar_t * __restrict  ,
                const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
    int wcscasecmp(const wchar_t * __restrict  ,
                   const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    int wcsncasecmp(const wchar_t * __restrict  ,
                    const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
    int wcscoll(const wchar_t * __restrict  ,
                const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    size_t wcsxfrm(wchar_t * __restrict  ,
                   const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
    int wmemcmp(const wchar_t * __restrict  ,
                const wchar_t * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
    size_t wcscspn(const wchar_t * __restrict  ,
                   const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    size_t wcsspn(const wchar_t * __restrict  ,
                  const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    wchar_t *wcstok(wchar_t * __restrict  ,
                    const wchar_t * __restrict  ,
                    wchar_t ** __restrict  ) __attribute__((__nonnull__(2,3)));
    size_t wcslen(const wchar_t * __restrict  ) __attribute__((__nonnull__(1)));
    wchar_t *wmemset(wchar_t * __restrict  , wchar_t  , size_t  ) __attribute__((__nonnull__(1)));


    




 
    const wchar_t *wcschr(const wchar_t * __restrict  , wchar_t  ) __attribute__((__nonnull__(1)));
    const wchar_t *wcspbrk(const wchar_t * __restrict  ,
                           const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    const wchar_t *wcsrchr(const wchar_t * __restrict  , wchar_t  ) __attribute__((__nonnull__(1)));
    const wchar_t *wcsstr(const wchar_t * __restrict  ,
                          const wchar_t * __restrict  ) __attribute__((__nonnull__(1,2)));
    const wchar_t *wmemchr(const wchar_t * __restrict  , wchar_t  ,
                           size_t  ) __attribute__((__nonnull__(1)));

    extern "C++" wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
    extern "C++" inline wchar_t *wcschr(wchar_t * __restrict __s, wchar_t __c)
      { return const_cast<wchar_t *>(wcschr(const_cast<const wchar_t *>(__s), __c)); }
    extern "C++" wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
    extern "C++" inline wchar_t *wcspbrk(wchar_t * __restrict __s1, const wchar_t * __restrict __s2)
      { return const_cast<wchar_t *>(wcspbrk(const_cast<const wchar_t *>(__s1), __s2)); }
    extern "C++" wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c) __attribute__((__nonnull__(1)));
    extern "C++" inline wchar_t *wcsrchr(wchar_t * __restrict __s, wchar_t __c)
      { return const_cast<wchar_t *>(wcsrchr(const_cast<const wchar_t *>(__s), __c)); }
    extern "C++" wchar_t *wcsstr(wchar_t * __restrict __s1,
                          const wchar_t * __restrict __s2) __attribute__((__nonnull__(1,2)));
    extern "C++" inline wchar_t *wcsstr(wchar_t * __restrict __s1,
                          const wchar_t * __restrict __s2)
      { return const_cast<wchar_t *>(wcsstr(const_cast<const wchar_t *>(__s1), __s2)); }
    extern "C++" wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
                                  size_t __n) __attribute__((__nonnull__(1)));
    extern "C++" inline wchar_t *wmemchr(wchar_t * __restrict __s, wchar_t __c,
                                  size_t __n)
    { return const_cast<wchar_t *>(wmemchr(const_cast<const wchar_t *>(__s), __c, __n)); }
# 354 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\wchar.h"


         }   
      }   







# 450 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\wchar.h"

 

# 18 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cwchar"


# 26 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cwchar"
  


# 47 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\iosfwd"

# 58 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\iosfwd"

# 91 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\iosfwd"


namespace std {


template <class _TypeT>
class allocator;

template<class _CharT>
struct char_traits;

template< >
struct char_traits<char>;



template< >
struct char_traits<wchar_t>;




template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ios;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_streambuf;


template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_istream;


template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ostream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT> > 
class basic_stringbuf;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT>  > 
class basic_istringstream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT> > 
class basic_ostringstream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_filebuf;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ifstream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ofstream;

template<class _CharT,
         class _Traits = char_traits<_CharT> > 
class ostreambuf_iterator;

template<class _CharT,
         class _Traits = char_traits<_CharT> > 
class istreambuf_iterator;


template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_iostream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_fstream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT>  > 
class basic_stringstream;




typedef basic_ios<char>                                    ios;
typedef basic_streambuf<char>                              streambuf;
typedef basic_istream<char>                                istream;
typedef basic_ostream<char>                                ostream;
typedef basic_stringbuf<char>                              stringbuf;
typedef basic_istringstream<char>                          istringstream;
typedef basic_ostringstream<char>                          ostringstream;
typedef basic_filebuf<char>                                filebuf;
typedef basic_ifstream<char>                               ifstream;
typedef basic_ofstream<char>                               ofstream;
typedef basic_fstream<char>                                fstream;
typedef basic_iostream<char>                               iostream;
typedef basic_stringstream<char>                           stringstream;



typedef basic_ios<wchar_t>                                 wios;
typedef basic_streambuf<wchar_t>                           wstreambuf;
typedef basic_istream<wchar_t>                             wistream;
typedef basic_ostream<wchar_t>                             wostream;
typedef basic_stringbuf<wchar_t>                           wstringbuf;
typedef basic_istringstream<wchar_t>                       wistringstream;
typedef basic_ostringstream<wchar_t>                       wostringstream;
typedef basic_filebuf<wchar_t>                             wfilebuf;
typedef basic_ifstream<wchar_t>                            wifstream;
typedef basic_ofstream<wchar_t>                            wofstream;
typedef basic_fstream<wchar_t>                             wfstream;
typedef basic_iostream<wchar_t>                            wiostream;
typedef basic_stringstream<wchar_t>                        wstringstream;



# 257 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\iosfwd"



template <class _StateT>
class fpos;



typedef fpos<mbstate_t>                                    streampos;
typedef fpos<mbstate_t>                                    wstreampos;

}   




# 37 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"





























 




# 36 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"





























 




# 36 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_math.h"































 




# 38 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_math.h"








# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cmath"



 





 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"




 





 












 






   









 






# 61 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"

# 75 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"







   




 















 
# 112 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"











 


      extern "C" {


extern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
extern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
    




 

extern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
extern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
     
     

inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
{
    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
}
inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
{
    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
}
     
     

inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
{
    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
}
inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
{
    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
}
     
     

inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
{
    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
    return (__f == 8) || (__f == 2);  
}
inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
{
    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
    return (__f == 8) || (__f == 2);  
}
    


 

inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
{
    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
}
inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
{
    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
}
     
     

inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
{
    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
    return (__xe != 0xff) && (__xe != 0);
}
inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
{
    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
    return (__xe != 0x7ff) && (__xe != 0);
}
     
     

inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
{
    return (*(unsigned *)&(__x)) >> 31;
}
inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
{
    return (*(1 + (unsigned *)&(__x))) >> 31;
}
     
     


      }  






      namespace std {

        extern "C" {










   
  typedef float float_t;
  typedef double double_t;
# 251 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"



extern const int math_errhandling;
# 261 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"

extern __declspec(__nothrow) double acos(double  );
    
    
    
extern __declspec(__nothrow) double asin(double  );
    
    
    
    

extern __declspec(__nothrow) __attribute__((const)) double atan(double  );
    
    

extern __declspec(__nothrow) double atan2(double  , double  );
    
    
    
    

extern __declspec(__nothrow) double cos(double  );
    
    
    
    
extern __declspec(__nothrow) double sin(double  );
    
    
    
    

extern void __use_accurate_range_reduction(void);
    
    

extern __declspec(__nothrow) double tan(double  );
    
    
    
    

extern __declspec(__nothrow) double cosh(double  );
    
    
    
    
extern __declspec(__nothrow) double sinh(double  );
    
    
    
    
    

extern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
    
    

extern __declspec(__nothrow) double exp(double  );
    
    
    
    
    

extern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
    
    
    
    
    
    

extern __declspec(__nothrow) double ldexp(double  , int  );
    
    
    
    
extern __declspec(__nothrow) double log(double  );
    
    
    
    
    
extern __declspec(__nothrow) double log10(double  );
    
    
    
extern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
    
    
    
    

extern __declspec(__nothrow) double pow(double  , double  );
    
    
    
    
    
    
extern __declspec(__nothrow) double sqrt(double  );
    
    
    




    inline double _sqrt(double __x) { return sqrt(__x); }




    inline float _sqrtf(float __x) { return (float)sqrt(__x); }

    



 

extern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
    
    
extern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
    
    

extern __declspec(__nothrow) __attribute__((const)) double floor(double  );
    
    

extern __declspec(__nothrow) double fmod(double  , double  );
    
    
    
    
    

    









 



extern __declspec(__nothrow) double acosh(double  );
    

 
extern __declspec(__nothrow) double asinh(double  );
    

 
extern __declspec(__nothrow) double atanh(double  );
    

 
extern __declspec(__nothrow) double cbrt(double  );
    

 
inline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
    

 
{
    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
    return __x;
}
inline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
    

 
{
    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
    return __x;
}
extern __declspec(__nothrow) double erf(double  );
    

 
extern __declspec(__nothrow) double erfc(double  );
    

 
extern __declspec(__nothrow) double expm1(double  );
    

 



    

 






# 479 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"


extern __declspec(__nothrow) double hypot(double  , double  );
    




 
extern __declspec(__nothrow) int ilogb(double  );
    

 
extern __declspec(__nothrow) int ilogbf(float  );
    

 
extern __declspec(__nothrow) int ilogbl(long double  );
    

 







    

 





    



 





    



 





    

 





    



 





    



 





    



 





    

 





    

 





    


 

extern __declspec(__nothrow) double lgamma (double  );
    


 
extern __declspec(__nothrow) double log1p(double  );
    

 
extern __declspec(__nothrow) double logb(double  );
    

 
extern __declspec(__nothrow) float logbf(float  );
    

 
extern __declspec(__nothrow) long double logbl(long double  );
    

 
extern __declspec(__nothrow) double nextafter(double  , double  );
    


 
extern __declspec(__nothrow) float nextafterf(float  , float  );
    


 
extern __declspec(__nothrow) long double nextafterl(long double  , long double  );
    


 
extern __declspec(__nothrow) double nexttoward(double  , long double  );
    


 
extern __declspec(__nothrow) float nexttowardf(float  , long double  );
    


 
extern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
    


 
extern __declspec(__nothrow) double remainder(double  , double  );
    

 
extern __declspec(__nothrow) __attribute__((const)) double rint(double  );
    

 
extern __declspec(__nothrow) double scalbln(double  , long int  );
    

 
extern __declspec(__nothrow) float scalblnf(float  , long int  );
    

 
extern __declspec(__nothrow) long double scalblnl(long double  , long int  );
    

 
extern __declspec(__nothrow) double scalbn(double  , int  );
    

 
extern __declspec(__nothrow) float scalbnf(float  , int  );
    

 
extern __declspec(__nothrow) long double scalbnl(long double  , int  );
    

 




    

 



 
extern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
inline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
extern __declspec(__nothrow) float sinf(float  );
extern __declspec(__nothrow) float cosf(float  );
extern __declspec(__nothrow) float tanf(float  );
extern __declspec(__nothrow) float acosf(float  );
extern __declspec(__nothrow) float asinf(float  );
extern __declspec(__nothrow) float atanf(float  );
extern __declspec(__nothrow) float atan2f(float  , float  );
extern __declspec(__nothrow) float sinhf(float  );
extern __declspec(__nothrow) float coshf(float  );
extern __declspec(__nothrow) float tanhf(float  );
extern __declspec(__nothrow) float expf(float  );
extern __declspec(__nothrow) float logf(float  );
extern __declspec(__nothrow) float log10f(float  );
extern __declspec(__nothrow) float powf(float  , float  );
extern __declspec(__nothrow) float sqrtf(float  );
extern __declspec(__nothrow) float ldexpf(float  , int  );
extern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
extern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
extern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
extern __declspec(__nothrow) float fmodf(float  , float  );
extern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));

 
 













 
__declspec(__nothrow) long double acosl(long double );
__declspec(__nothrow) long double asinl(long double );
__declspec(__nothrow) long double atanl(long double );
__declspec(__nothrow) long double atan2l(long double , long double );
__declspec(__nothrow) long double ceill(long double );
__declspec(__nothrow) long double cosl(long double );
__declspec(__nothrow) long double coshl(long double );
__declspec(__nothrow) long double expl(long double );
__declspec(__nothrow) long double fabsl(long double );
__declspec(__nothrow) long double floorl(long double );
__declspec(__nothrow) long double fmodl(long double , long double );
__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
__declspec(__nothrow) long double ldexpl(long double , int );
__declspec(__nothrow) long double logl(long double );
__declspec(__nothrow) long double log10l(long double );
__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
__declspec(__nothrow) long double powl(long double , long double );
__declspec(__nothrow) long double sinl(long double );
__declspec(__nothrow) long double sinhl(long double );
__declspec(__nothrow) long double sqrtl(long double );
__declspec(__nothrow) long double tanl(long double );
__declspec(__nothrow) long double tanhl(long double );





 
extern __declspec(__nothrow) float acoshf(float  );
__declspec(__nothrow) long double acoshl(long double );
extern __declspec(__nothrow) float asinhf(float  );
__declspec(__nothrow) long double asinhl(long double );
extern __declspec(__nothrow) float atanhf(float  );
__declspec(__nothrow) long double atanhl(long double );
__declspec(__nothrow) long double copysignl(long double , long double );
extern __declspec(__nothrow) float cbrtf(float  );
__declspec(__nothrow) long double cbrtl(long double );
extern __declspec(__nothrow) float erff(float  );
__declspec(__nothrow) long double erfl(long double );
extern __declspec(__nothrow) float erfcf(float  );
__declspec(__nothrow) long double erfcl(long double );
extern __declspec(__nothrow) float expm1f(float  );
__declspec(__nothrow) long double expm1l(long double );
extern __declspec(__nothrow) float log1pf(float  );
__declspec(__nothrow) long double log1pl(long double );
extern __declspec(__nothrow) float hypotf(float  , float  );
__declspec(__nothrow) long double hypotl(long double , long double );
extern __declspec(__nothrow) float lgammaf(float  );
__declspec(__nothrow) long double lgammal(long double );
extern __declspec(__nothrow) float remainderf(float  , float  );
__declspec(__nothrow) long double remainderl(long double , long double );
extern __declspec(__nothrow) float rintf(float  );
__declspec(__nothrow) long double rintl(long double );



# 875 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"






  extern "C++" {
    inline int (fpclassify)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_fpclassifyf(__x) : __ARM_fpclassify(__x)); }
    inline bool (isfinite)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isfinitef(__x) : __ARM_isfinite(__x)); }
    inline bool (isgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x20000000)); }
    inline bool (isgreaterequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x30000000) == 0x20000000) : ((__ARM_dcmp4((__x), (__y)) & 0x30000000) == 0x20000000)); }
    inline bool (isinf)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isinff(__x) : __ARM_isinf(__x)); }
    inline bool (isless)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xf0000000) == 0x80000000) : ((__ARM_dcmp4((__x), (__y)) & 0xf0000000) == 0x80000000)); }
    inline bool (islessequal)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0xc0000000) != 0) : ((__ARM_dcmp4((__x), (__y)) & 0xc0000000) != 0)); }
    inline bool (islessgreater)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? __ARM_islessgreaterf((__x), (__y)) : __ARM_islessgreater((__x), (__y))); }
    inline bool (isnan)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnanf(__x) : __ARM_isnan(__x)); }
    inline bool (isnormal)(double __x) { return ((sizeof(__x) == sizeof(float)) ? __ARM_isnormalf(__x) : __ARM_isnormal(__x)); }
    inline bool (isunordered)(double __x, double __y) { return (((sizeof(__x) == sizeof(float)) && (sizeof(__y) == sizeof(float))) ? ((__ARM_fcmp4((__x), (__y)) & 0x10000000) == 0x10000000) : ((__ARM_dcmp4((__x), (__y)) & 0x10000000) == 0x10000000)); }

  }



  extern "C++" {
    inline float abs(float __x)   { return fabsf(__x); }
    inline float acos(float __x)  { return acosf(__x); }
    inline float asin(float __x)  { return asinf(__x); }
    inline float atan(float __x)  { return atanf(__x); }
    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
    inline float ceil(float __x)  { return ceilf(__x); }
    inline float cos(float __x)   { return cosf(__x); }
    inline float cosh(float __x)  { return coshf(__x); }
    inline float exp(float __x)   { return expf(__x); }
    inline float fabs(float __x)  { return fabsf(__x); }
    inline float floor(float __x) { return floorf(__x); }
    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
    inline float log(float __x)   { return logf(__x); }
    inline float log10(float __x) { return log10f(__x); }
    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
    inline float pow(float __x, float __y)      { return powf(__x,__y); }
    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
    inline float sin(float __x)   { return sinf(__x); }
    inline float sinh(float __x)  { return sinhf(__x); }
    inline float sqrt(float __x)  { return sqrtf(__x); }
    inline float _sqrt(float __x) { return _sqrtf(__x); }
    inline float tan(float __x)   { return tanf(__x); }
    inline float tanh(float __x)  { return tanhf(__x); }

    inline double abs(double __x) { return fabs(__x); }
    inline double pow(double __x, int __y)
                { return pow(__x, (double) __y); }


    inline long double abs(long double __x)
                { return (long double)fabsl(__x); }
    inline long double acos(long double __x)
                { return (long double)acosl(__x); }
    inline long double asin(long double __x)
                { return (long double)asinl(__x); }
    inline long double atan(long double __x)
                { return (long double)atanl(__x); }
    inline long double atan2(long double __y, long double __x)
                { return (long double)atan2l(__y, __x); }
    inline long double ceil(long double __x)
                { return (long double)ceill( __x); }
    inline long double cos(long double __x)
                { return (long double)cosl(__x); }
    inline long double cosh(long double __x)
                { return (long double)coshl(__x); }
    inline long double exp(long double __x)
                { return (long double)expl(__x); }
    inline long double fabs(long double __x)
                { return (long double)fabsl(__x); }
    inline long double floor(long double __x)
                { return (long double)floorl(__x); }
    inline long double fmod(long double __x, long double __y)
                { return (long double)fmodl(__x, __y); }
    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
    inline long double frexp(long double __x, int* __p)
                { return (long double)frexpl(__x, __p); }
    inline long double ldexp(long double __x, int __exp)
                { return (long double)ldexpl(__x, __exp); }
    inline long double log(long double __x)
                { return (long double)logl(__x); }
    inline long double log10(long double __x)
                { return (long double)log10l(__x); }
    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
    inline long double modf(long double __x, long double* __p)
                { return (long double)modfl(__x, __p); }
    inline long double pow(long double __x, long double __y)
                { return (long double)powl(__x, __y); }
    inline long double pow(long double __x, int __y)
                { return (long double)powl(__x, __y); }
    inline long double sin(long double __x)
                { return (long double)sinl(__x); }
    inline long double sinh(long double __x)
                { return (long double)sinhl(__x); }
    inline long double sqrt(long double __x)
                { return (long double)sqrtl(__x); }
    inline long double _sqrt(long double __x)
                { return (long double)_sqrt((double) __x); }
    inline long double tan(long double __x)
                { return (long double)tanl(__x); }
    inline long double tanh(long double __x)
                { return (long double)tanhl(__x); }



    inline float acosh(float __x) { return acoshf(__x); }
    inline float asinh(float __x) { return asinhf(__x); }
    inline float atanh(float __x) { return atanhf(__x); }
    inline float cbrt(float __x) { return cbrtf(__x); }
    inline float erf(float __x) { return erff(__x); }
    inline float erfc(float __x) { return erfcf(__x); }
    inline float expm1(float __x) { return expm1f(__x); }
    inline float log1p(float __x) { return log1pf(__x); }
    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
    inline float lgamma(float __x) { return lgammaf(__x); }
    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
    inline float rint(float __x) { return rintf(__x); }


# 1084 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"

  }



        }   
      }   







# 1317 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\math.h"





 
# 18 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cmath"


# 26 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cmath"



 

# 47 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_math.h"













# 37 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"

# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cfloat"



 





 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\float.h"
 
 
 
 





 











      namespace std {

        extern "C" {




 
 


     
# 40 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\float.h"
    








 




     


    
 





    











 


 
 




     




     
     




     
     




     



     
     




     




     




     



 

extern "C" {

unsigned _controlfp(unsigned, unsigned);
unsigned _clearfp(void);
unsigned _statusfp(void);

}








 

# 151 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\float.h"










 








        }   
      }   











 

# 18 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cfloat"


# 26 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cfloat"
  


# 39 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\climits"



 





 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits.h"
 
 
 





 






     

     

     

     
# 30 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits.h"
       

       






# 45 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits.h"
     
     


     

     

     

     

     

     





     





     





     


       

       

       




 

# 17 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\climits"



# 40 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"
# 41 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"






















 




# 83 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"

# 99 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"
  












# 125 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"


# 133 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"







# 146 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"

# 155 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"




# 185 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"
















# 250 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"















namespace std {


enum float_round_style
{
    round_indeterminate       = -1,
    round_toward_zero         =  0,
    round_to_nearest          =  1,
    round_toward_infinity     =  2,
    round_toward_neg_infinity =  3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent        =  0,
    denorm_present       =  1
};

template <class _TypeT>
class numeric_limits
{
public:
    
    
    

    static const bool is_specialized = false;

    static _TypeT min ()  { return 0; }
    static _TypeT max ()  { return 0; }

    static const int digits = 0;
    static const int digits10 = 0;

    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;

    static const int radix = 0;

    static _TypeT epsilon ()  { return 0; }
    static _TypeT round_error ()  { return 0; }

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;

    static _TypeT infinity ()  { return 0; }
    static _TypeT quiet_NaN ()  { return 0; }
    static _TypeT signaling_NaN ()  { return 0; }
    static _TypeT denorm_min ()  { return 0; }

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};


}   





namespace std {



template< > class numeric_limits<float> { public:

    static const bool is_specialized = (true);

    static float min ()  { return 1.175494351e-38F; }
    static float max ()  { return 3.40282347e+38F; }

    static const int digits = (24);
    static const int digits10 = (6);

    static const bool is_signed = (true);
    static const bool is_integer = (false);
    static const bool is_exact = (false);
    static const int radix = (2);

    static float epsilon ()  { return 1.19209290e-7F; }
    static float round_error ()  { return 0.5F; }

    static const int min_exponent = ((-125));
    static const int min_exponent10 = ((-37));
    static const int max_exponent = (128);
    static const int max_exponent10 = (38);

    static const bool has_infinity = (true);
    static const bool has_quiet_NaN = (true);
    static const bool has_signaling_NaN = (true);
    static const float_denorm_style has_denorm = (denorm_absent);

    static const bool has_denorm_loss = (false);










    static float infinity ()  { return __ESCAPE__(0f_7F800000); } 
    static float quiet_NaN ()  { return __ESCAPE__(0f_7FC00000); } 
    static float signaling_NaN ()  { return __ESCAPE__(0f_7F800001); } 

    static float denorm_min ()  { return 1.175494351e-38F; } 

    static const bool is_iec559 = (false);    
    static const bool is_bounded = (true);
    static const bool is_modulo = (false);               

    static const bool traps = (true);                    
    static const bool tinyness_before = (false);          

    static const float_round_style  round_style;

     
    typedef double _C_convertible;

};   



template< > class numeric_limits<double> { public:

    static const bool is_specialized = (true);

    static double min ()  { return 2.22507385850720138e-308; }
    static double max ()  { return 1.79769313486231571e+308; }

    static const int digits = (53);
    static const int digits10 = (15);

    static const bool is_signed = (true);
    static const bool is_integer = (false);
    static const bool is_exact = (false);
    static const int radix = (2);

    static double epsilon ()  { return 2.2204460492503131e-16; }
    static double round_error ()  { return 0.5; }

    static const int min_exponent = ((-1021));
    static const int min_exponent10 = ((-307));
    static const int max_exponent = (1024);
    static const int max_exponent10 = (308);

    static const bool has_infinity = (true);
    static const bool has_quiet_NaN = (true);
    static const bool has_signaling_NaN = (true);
    static const float_denorm_style has_denorm = (denorm_absent);

    static const bool has_denorm_loss = (false);






    static double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
    static double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
    static double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   

    static double denorm_min ()  { return 2.22507385850720138e-308; }

    static const bool is_iec559 = (false);
    static const bool is_bounded = (true);
    static const bool is_modulo = (false);              

    static const bool traps = (true);                   
    static const bool tinyness_before = (false);         

    static const float_round_style  round_style;

     
    typedef long double _C_convertible;

};   





template< > class numeric_limits<long double> { public:

    static const bool is_specialized = (true);

    static long double min ()  { return 2.22507385850720138e-308L; } 
    static long double max ()  { return 1.79769313486231571e+308L; } 

    static const int digits = (53);
    static const int digits10 = (15);

    static const bool is_signed = (true);
    static const bool is_integer = (false);
    static const bool is_exact = (false);
    static const int radix = (2);

    static long double epsilon ()  { return 2.2204460492503131e-16L; } 
    static long double round_error ()  { return 0.5L; }

    static const int min_exponent = ((-1021));
    static const int min_exponent10 = ((-307));
    static const int max_exponent = (1024);
    static const int max_exponent10 = (308);

    static const bool has_infinity = (true);
    static const bool has_quiet_NaN = (true);
    static const bool has_signaling_NaN = (true);
    static const float_denorm_style has_denorm = (denorm_indeterminate);

    static const bool has_denorm_loss = (false);






    static long double infinity ()  { return __ESCAPE__(0d_7FF0000000000000); }   
    static long double quiet_NaN ()  { return __ESCAPE__(0d_7FF8000000000000); }   
    static long double signaling_NaN ()  { return __ESCAPE__(0d_7FF0000000000001); }   

    static long double denorm_min ()  { return 2.22507385850720138e-308L; }

    static const bool is_iec559 = (false);
    static const bool is_bounded = (true);
    static const bool is_modulo = (false);         

    static const bool traps = (true);              
    static const bool tinyness_before = (false);    

    static const float_round_style  round_style;


     
    typedef long double _C_convertible;

};    
















# 546 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"

















template< > class numeric_limits<char> { public: static const bool is_specialized = (true); static char min ()  { return 0; } static char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static char epsilon ()  { return 0; } static char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static char infinity ()  { return 0; } static char quiet_NaN ()  { return 0; } static char signaling_NaN ()  { return 0; } static char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };


template< > class numeric_limits<unsigned char> { public: static const bool is_specialized = (true); static unsigned char min ()  { return 0; } static unsigned char max ()  { return 255; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))); static const int digits10 = (((((1 == (255) ? 1 : (8 * sizeof (unsigned char) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned char epsilon ()  { return 0; } static unsigned char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned char infinity ()  { return 0; } static unsigned char quiet_NaN ()  { return 0; } static unsigned char signaling_NaN ()  { return 0; } static unsigned char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 255); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };

template< > class numeric_limits<signed char> { public: static const bool is_specialized = (true); static signed char min ()  { return (-128); } static signed char max ()  { return 127; } static const bool is_signed = ((-128) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))); static const int digits10 = (((((1 == (127) ? 1 : (8 * sizeof (signed char) - (((-128)) != 0)))) * 301) / 1000)); static const int radix = (2); static signed char epsilon ()  { return 0; } static signed char round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static signed char infinity ()  { return 0; } static signed char quiet_NaN ()  { return 0; } static signed char signaling_NaN ()  { return 0; } static signed char denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 127); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };

template< > class numeric_limits<short int> { public: static const bool is_specialized = (true); static short int min ()  { return (-0x8000); } static short int max ()  { return 0x7fff; } static const bool is_signed = ((-0x8000) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))); static const int digits10 = (((((1 == (0x7fff) ? 1 : (8 * sizeof (short int) - (((-0x8000)) != 0)))) * 301) / 1000)); static const int radix = (2); static short int epsilon ()  { return 0; } static short int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static short int infinity ()  { return 0; } static short int quiet_NaN ()  { return 0; } static short int signaling_NaN ()  { return 0; } static short int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };


template< > class numeric_limits<unsigned short> { public: static const bool is_specialized = (true); static unsigned short min ()  { return 0; } static unsigned short max ()  { return 65535; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))); static const int digits10 = (((((1 == (65535) ? 1 : (8 * sizeof (unsigned short) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned short epsilon ()  { return 0; } static unsigned short round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned short infinity ()  { return 0; } static unsigned short quiet_NaN ()  { return 0; } static unsigned short signaling_NaN ()  { return 0; } static unsigned short denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 65535); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };

template< > class numeric_limits<int> { public: static const bool is_specialized = (true); static int min ()  { return (~0x7fffffff); } static int max ()  { return 0x7fffffff; } static const bool is_signed = ((~0x7fffffff) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))); static const int digits10 = (((((1 == (0x7fffffff) ? 1 : (8 * sizeof (int) - (((~0x7fffffff)) != 0)))) * 301) / 1000)); static const int radix = (2); static int epsilon ()  { return 0; } static int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static int infinity ()  { return 0; } static int quiet_NaN ()  { return 0; } static int signaling_NaN ()  { return 0; } static int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffff); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };


template< > class numeric_limits<unsigned int> { public: static const bool is_specialized = (true); static unsigned int min ()  { return 0; } static unsigned int max ()  { return 0xffffffffU; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffU) ? 1 : (8 * sizeof (unsigned int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned int epsilon ()  { return 0; } static unsigned int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned int infinity ()  { return 0; } static unsigned int quiet_NaN ()  { return 0; } static unsigned int signaling_NaN ()  { return 0; } static unsigned int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffU); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };

template< > class numeric_limits<long int> { public: static const bool is_specialized = (true); static long int min ()  { return (~0x7fffffffL); } static long int max ()  { return 0x7fffffffL; } static const bool is_signed = ((~0x7fffffffL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffL) ? 1 : (8 * sizeof (long int) - (((~0x7fffffffL)) != 0)))) * 301) / 1000)); static const int radix = (2); static long int epsilon ()  { return 0; } static long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static long int infinity ()  { return 0; } static long int quiet_NaN ()  { return 0; } static long int signaling_NaN ()  { return 0; } static long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };


template< > class numeric_limits<unsigned long int> { public: static const bool is_specialized = (true); static unsigned long int min ()  { return 0; } static unsigned long int max ()  { return 0xffffffffUL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffUL) ? 1 : (8 * sizeof (unsigned long int) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned long int epsilon ()  { return 0; } static unsigned long int round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned long int infinity ()  { return 0; } static unsigned long int quiet_NaN ()  { return 0; } static unsigned long int signaling_NaN ()  { return 0; } static unsigned long int denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffUL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };














# 604 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"
                        
# 615 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"


template< > class numeric_limits<wchar_t> { public: static const bool is_specialized = (true); static wchar_t min ()  { return ( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)); } static wchar_t max ()  { return ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255)); } static const bool is_signed = (( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128)) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))); static const int digits10 = (((((1 == (( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))) ? 1 : (8 * sizeof (wchar_t) - ((( wchar_t (-1) > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-0x8000) : sizeof (wchar_t) == sizeof (int) ? (~0x7fffffff) : sizeof (wchar_t) == sizeof (long) ? (~0x7fffffffL) : (-128))) != 0)))) * 301) / 1000)); static const int radix = (2); static wchar_t epsilon ()  { return 0; } static wchar_t round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static wchar_t infinity ()  { return 0; } static wchar_t quiet_NaN ()  { return 0; } static wchar_t signaling_NaN ()  { return 0; } static wchar_t denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != ( wchar_t (-1) > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 65535 : sizeof (wchar_t) == sizeof (int) ? 0xffffffffU : sizeof (wchar_t) == sizeof (long) ? 0xffffffffUL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 0x7fff : sizeof (wchar_t) == sizeof (int) ? 0x7fffffff : sizeof (wchar_t) == sizeof (long) ? 0x7fffffffL : 255))); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };












template< > class numeric_limits<bool> { public: static const bool is_specialized = (true); static bool min ()  { return false; } static bool max ()  { return true; } static const bool is_signed = (false != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))); static const int digits10 = (((((1 == (true) ? 1 : (8 * sizeof (bool) - ((false) != 0)))) * 301) / 1000)); static const int radix = (2); static bool epsilon ()  { return 0; } static bool round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static bool infinity ()  { return 0; } static bool quiet_NaN ()  { return 0; } static bool signaling_NaN ()  { return 0; } static bool denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != true); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };















# 654 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\limits"
       










template< > class numeric_limits<__int64> { public: static const bool is_specialized = (true); static __int64 min ()  { return (~0x7fffffffffffffffLL); } static __int64 max ()  { return 0x7fffffffffffffffLL; } static const bool is_signed = ((~0x7fffffffffffffffLL) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))); static const int digits10 = (((((1 == (0x7fffffffffffffffLL) ? 1 : (8 * sizeof (__int64) - (((~0x7fffffffffffffffLL)) != 0)))) * 301) / 1000)); static const int radix = (2); static __int64 epsilon ()  { return 0; } static __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static __int64 infinity ()  { return 0; } static __int64 quiet_NaN ()  { return 0; } static __int64 signaling_NaN ()  { return 0; } static __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0x7fffffffffffffffLL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef __int64 _C_convertible; };


template< > class numeric_limits<unsigned __int64> { public: static const bool is_specialized = (true); static unsigned __int64 min ()  { return 0; } static unsigned __int64 max ()  { return 0xffffffffffffffffULL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = ((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))); static const int digits10 = (((((1 == (0xffffffffffffffffULL) ? 1 : (8 * sizeof (unsigned __int64) - ((0) != 0)))) * 301) / 1000)); static const int radix = (2); static unsigned __int64 epsilon ()  { return 0; } static unsigned __int64 round_error ()  { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned __int64 infinity ()  { return 0; } static unsigned __int64 quiet_NaN ()  { return 0; } static unsigned __int64 signaling_NaN ()  { return 0; } static unsigned __int64 denorm_min ()  { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0xffffffffffffffffULL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned __int64 _C_convertible; };











}   








# 37 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_algobase.h"













































 




# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\utility"








































 




# 47 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\utility"


namespace std {







namespace rel_ops {


template <class _TypeT>
inline bool operator!= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__x == __y);
}

template <class _TypeT>
inline bool operator> (const _TypeT& __x, const _TypeT& __y)
{
    return __y < __x;
}

template <class _TypeT>
inline bool operator<= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__y < __x);
}

template <class _TypeT>
inline bool operator>= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__x < __y);
}


}   






template <class _TypeT, class _TypeU>
struct pair
{
    typedef _TypeT first_type;
    typedef _TypeU second_type;

    first_type  first;
    second_type second;

    pair (const first_type &__x, const second_type &__y)
        : first (__x), second (__y) { }

    pair ()

        : first ( ), second () { }




    pair (const pair &__rhs): first (__rhs.first), second (__rhs.second) { }



    template <class _TypeX, class _TypeY>
    pair (const pair <_TypeX, _TypeY> &__rhs) 
        : first (__rhs.first), second (__rhs.second) { }



};


template <class _TypeT, class _TypeU>
inline bool
operator== (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return __x.first == __y.first && __x.second == __y.second; 
}


template <class _TypeT, class _TypeU>
inline bool
operator!= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return !(__x == __y);
}


template <class _TypeT, class _TypeU>
inline bool
operator< (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return    __x.first < __y.first
           || (!(__y.first < __x.first) && __x.second < __y.second); 
}


template <class _TypeT, class _TypeU>
inline bool
operator> (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return __y < __x;
}


template <class _TypeT, class _TypeU>
inline bool
operator>= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return !(__x < __y);
}


template <class _TypeT, class _TypeU>
inline bool
operator<= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{ 
    return !(__y < __x);
}


template <class _TypeT, class _TypeU>
inline pair<_TypeT, _TypeU>
make_pair (const _TypeT &__x, const _TypeU &__y)
{
    return pair<_TypeT, _TypeU>(__x, __y);
}


}   




# 52 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_algobase.h"










namespace std {



template <class _TypeT>
inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b)
{
    return __b < __a ? __b : __a;
}

template <class _TypeT, class _Compare>
inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
{
    return __cmp (__b, __a) ? __b : __a;
}



template <class _TypeT>
inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b)
{
    return  __a < __b ? __b : __a;
}


template <class _TypeT, class _Compare>
inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b, _Compare __cmp)
{
    return __cmp (__a, __b) ? __b : __a;
}



template <class _InputIter, class _OutputIter>
inline _OutputIter
copy (_InputIter __first, _InputIter __last, _OutputIter __res)
{
    ((void)0);

    for (; __first != __last; ++__first,++__res)
        *__res = *__first;
    return __res;
}



template <class _BidirIter1, class _BidirIter2>
inline _BidirIter2
copy_backward (_BidirIter1 __first, _BidirIter1 __last, _BidirIter2 __res)
{
    ((void)0);

    while (__first != __last)
        *--__res = *--__last;
    return __res;
}



template <class _FwdIter, class _TypeT>
inline void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
{
    ((void)0);

    for (;__first != __last; ++__first)
        *__first = __value;
}


template <class _OutputIter, class _Size, class _TypeT>
inline void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value)
{
    for (;__n > 0;--__n, ++__first)
        *__first = __value;
}


}   

namespace __rw {


template <class _TypeT>
struct __rw_lt
{
    bool operator() (const _TypeT &__lhs, const _TypeT &__rhs) const {
        return __lhs < __rhs;
    }
};






# 169 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_algobase.h"



template <class _TypeT, class _TypeU>
inline void __rw_swap (_TypeT& __a, _TypeU& __b)
{
    
    _TypeT __tmp = __a;
    __a = __b;
    __b = __tmp;
}


}   


namespace std {



template <class _TypeT>
inline void swap (_TypeT& __a, _TypeT& __b)
{
    
    _TypeT __tmp = __a;
    __a = __b;
    __b = __tmp;
}



template <class _FwdIter1, class _FwdIter2>
inline void iter_swap (_FwdIter1 __a, _FwdIter2 __b)
{
    
    
    __rw::__rw_swap (*__a, *__b);
}



template <class _InputIter1, class _InputIter2>
inline pair<_InputIter1, _InputIter2>
mismatch (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
{
    ((void)0);

    while (__first1 != __last1 && *__first1 == *__first2) {
        ++__first1;
        ++__first2;
    }
    return pair<_InputIter1, _InputIter2> (__first1, __first2);
}


template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline pair<_InputIter1, _InputIter2>
mismatch (_InputIter1 __first1, _InputIter1 __last1,
          _InputIter2 __first2, _BinaryPredicate __pred)
{
    ((void)0);

    while (__first1 != __last1 && __pred (*__first1, *__first2)) {
        ++__first1;
        ++__first2;
    }
    return pair<_InputIter1, _InputIter2> (__first1, __first2);
}



template <class _InputIter1, class _InputIter2>
inline bool
equal (_InputIter1 __first1, _InputIter1 __last1, _InputIter2 __first2)
{
    return __last1 == std::mismatch (__first1, __last1, __first2).first;
}


template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
inline bool equal (_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _BinaryPredicate __pred)
{
    return __last1 == std::mismatch (__first1, __last1,
                                      __first2, __pred).first;
}



template <class _InputIter1, class _InputIter2>
bool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2);


template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                             _InputIter2 __first2, _InputIter2 __last2,
                             _Compare __comp);

}   









# 39 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"












































 




# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterbase.h"












































 




# 51 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterbase.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstddef"



 





 






# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"
 






 

 
 
 





 









        namespace std {

        extern "C" {







  typedef signed int ptrdiff_t;



  



    typedef unsigned int size_t;    
# 57 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"

# 82 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"



    




   




  typedef long double max_align_t;



         }   
      }   




# 114 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"



 

# 19 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstddef"


# 27 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstddef"
  



# 52 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterbase.h"


namespace std {



template <class _Iterator>
struct iterator_traits
{
    typedef typename _Iterator::value_type        value_type;
    typedef typename _Iterator::difference_type   difference_type;
    typedef typename _Iterator::pointer           pointer;
    typedef typename _Iterator::reference         reference;
    typedef typename _Iterator::iterator_category iterator_category;
};



struct input_iterator_tag { };
struct output_iterator_tag { };
struct forward_iterator_tag : public input_iterator_tag { };
struct bidirectional_iterator_tag : public forward_iterator_tag { };
struct random_access_iterator_tag : public bidirectional_iterator_tag { };




template <class _TypeT>
struct iterator_traits<_TypeT*>
{
    typedef _TypeT                     value_type;
    typedef ptrdiff_t                  difference_type;
    typedef value_type*                pointer;
    typedef value_type&                reference;
    typedef random_access_iterator_tag iterator_category;
};


template <class _TypeT>
struct iterator_traits<const _TypeT*>
{
    typedef _TypeT                     value_type;
    typedef ptrdiff_t                  difference_type;
    typedef const value_type*          pointer;
    typedef const value_type&          reference;
    typedef random_access_iterator_tag iterator_category;
};





template <class _Category, class _TypeT,  
          class _Distance = ptrdiff_t, 
          class _Pointer = _TypeT*, 
          class _Reference = _TypeT& >
struct iterator
{
    typedef _TypeT     value_type;
    typedef _Distance  difference_type;
    typedef _Pointer   pointer;
    typedef _Reference reference;
    typedef _Category  iterator_category;
};



template <class _TypeT>
inline random_access_iterator_tag __iterator_category (const _TypeT*)
{
    return random_access_iterator_tag ();
}


template <class _Category, class _TypeT, class _Distance, 
          class _Pointer, class _Reference> 
inline _Category
__iterator_category (const iterator<_Category, _TypeT,
                                    _Distance, _Pointer, _Reference>&)
{
    typedef typename iterator<_Category, _TypeT, _Distance, _TypeT*,
                               _TypeT&>::iterator_category _IterCategory;

    return _IterCategory ();
}


template <class _Tag>
inline bool __is_input_iterator (_Tag)
{
    return false;
}


template <class _Tag>
inline bool __is_bidirectional_iterator (_Tag)
{
    return false;
}


template <class _Tag>
inline bool __is_random_access_iterator (_Tag)
{
    return false;
}


template< > 
inline bool __is_input_iterator (input_iterator_tag)
{
    return true;
}


template< > 
inline bool __is_bidirectional_iterator (bidirectional_iterator_tag)
{
    return true;
}


template< > 
inline bool __is_bidirectional_iterator (random_access_iterator_tag)
{
    return true;
}


template< > 
inline bool __is_random_access_iterator (random_access_iterator_tag)
{
    return true;
}




template <class _Iterator>
inline typename iterator_traits<_Iterator>::value_type*
__value_type (const _Iterator*)
{ 
    return 0;
}

# 215 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterbase.h"




template <class _Iterator>
inline typename iterator_traits<_Iterator>::difference_type*
__distance_type (_Iterator)
{ 
    return 0;
}

# 243 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterbase.h"




template <class _InputIterator, class _Distance>
inline void __advance (_InputIterator &__it, _Distance __n, input_iterator_tag)
{
    ((void)0);

    while (__n > 0) {
        --__n;
        ++__it;
    }
}


template <class _ForwardIterator, class _Distance>
inline void __advance (_ForwardIterator &__it, _Distance __n,
                       forward_iterator_tag)
{
    __advance (__it, __n, input_iterator_tag ());
}


template <class _BidirectionalIterator, class _Distance>
inline void __advance (_BidirectionalIterator &__it, _Distance __n, 
                       bidirectional_iterator_tag)
{
    if (__n > 0)
        __advance (__it, __n, input_iterator_tag ());
    else
        while (__n) {
            ++__n;
            --__it;
        }
}


template <class _RandomAccessIterator, class _Distance>
inline void __advance (_RandomAccessIterator& __it, _Distance __n, 
                       random_access_iterator_tag)
{
    __it += __n;
}



template <class _InputIterator, class _Distance>
inline void advance (_InputIterator& __it, _Distance __n)
{
    __advance (__it, __n, typename std::iterator_traits< _InputIterator > ::iterator_category ());
}


template <class _InputIterator, class _Distance>
inline void __distance (const _InputIterator &__first,
                        const _InputIterator &__last,
                        _Distance            &__n,
                        input_iterator_tag)
{
    for (_InputIterator __it = __first; __it != __last; ++__it)
        ++__n;
}


template <class _ForwardIterator, class _Distance>
inline void __distance (const _ForwardIterator &__first,
                        const _ForwardIterator &__last,
                        _Distance              &__n,
                        forward_iterator_tag)
{
    __distance (__first, __last, __n, input_iterator_tag ());
}

template <class _BidirectionalIterator, class _Distance>
inline void __distance (const _BidirectionalIterator &__first,
                        const _BidirectionalIterator &__last, 
                        _Distance                    &__n,
                        bidirectional_iterator_tag)
{
    __distance (__first, __last, __n, input_iterator_tag ());
}


template <class _RandomAccessIterator, class _Distance>
inline void __distance (const _RandomAccessIterator &__first,
                        const _RandomAccessIterator &__last, 
                        _Distance                   &__n,
                        random_access_iterator_tag)
{
    __n = __last - __first;
}





template <class _ForwardIterator>
inline typename iterator_traits<_ForwardIterator>::difference_type
distance (const _ForwardIterator &__first, const _ForwardIterator &__last)
{
    typename iterator_traits<_ForwardIterator>::difference_type __n = 0;

    __distance (__first, __last, __n,
                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());

    return __n;
}






template <class _ForwardIterator, class _Distance>
inline void distance (const _ForwardIterator &__first,
                      const _ForwardIterator &__last,
                      _Distance              &__n)
{
    __distance (__first, __last, __n,
                typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
}




}   


namespace __rw {




template <class _ForwardIterator, class _Distance>
inline _Distance
__rw_distance (const _ForwardIterator &__first,
               const _ForwardIterator &__last,
               _Distance               __n)
{
    std::__distance (__first, __last, __n,
                      typename std::iterator_traits< _ForwardIterator > ::iterator_category ());
    return __n;
}


} 


# 744 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterbase.h"




# 51 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"
# 52 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"

# 54 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"


namespace std {







# 77 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"




template <class _Iterator>
class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category, 
                      typename iterator_traits<_Iterator>::value_type, 
                      typename iterator_traits<_Iterator>::difference_type,
                      typename iterator_traits<_Iterator>::pointer, 
                      typename iterator_traits<_Iterator>::reference>
{
    typedef iterator_traits<_Iterator>  traits_type;
public:
    typedef typename traits_type::difference_type difference_type;
    typedef typename traits_type::value_type value_type;
    typedef typename traits_type::pointer pointer;
    typedef typename traits_type::reference reference;

# 113 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"

    typedef _Iterator iterator_type;

    reverse_iterator () { }

    explicit reverse_iterator (iterator_type __rhs) : current (__rhs) { }
 




      template <class _TypeU>
      reverse_iterator (const reverse_iterator<_TypeU>& __rhs)
          : current (__rhs.base ()) { }

# 138 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"


    iterator_type base () const {
        return current;
    }

    reference operator* () const {
        iterator_type __tmp = base ();
        return *--__tmp;
    }

    pointer operator->() const { return & * *this; };

    reverse_iterator& operator++ () {
        return --current, *this;
    }

    reverse_iterator operator++ (int) {
        reverse_iterator __tmp = *this;
        ++*this;
        return __tmp;
    }

    reverse_iterator& operator-- () {
        return ++current, *this;
    }

    reverse_iterator operator-- (int) {
        reverse_iterator __tmp = *this;
        --*this;
        return __tmp;
    }

    reverse_iterator& operator+= (difference_type __n) {
        return current -= __n, *this;
    }

    reverse_iterator& operator-= (difference_type __n) {
        return *this += -__n;
    }

    reverse_iterator operator+ (difference_type __n) const {
        return reverse_iterator (*this) += __n;
    }

    reverse_iterator operator- (difference_type __n) const {
        return reverse_iterator (*this) -= __n;
    }

    reference operator[] (difference_type __n) const {
        return *(*this + __n);
    }

protected:

    iterator_type current;
};


template <class _Iterator>
inline bool operator== (const reverse_iterator <_Iterator> & __x,
                        const reverse_iterator <_Iterator> & __y)
{
    return __x.base () == __y.base ();
}


template <class _Iterator>
inline bool operator< (const reverse_iterator <_Iterator> & __x,
                       const reverse_iterator <_Iterator> & __y)
{
    return __y.base() < __x.base();
}


template <class _Iterator>
inline bool operator!= (const reverse_iterator <_Iterator> & __x, 
                        const reverse_iterator <_Iterator> & __y)
{
    return !(__x == __y);
}


template <class _Iterator>
inline bool operator> (const reverse_iterator <_Iterator> & __x, 
                       const reverse_iterator <_Iterator> & __y)
{
    return __y < __x;
}


template <class _Iterator>
inline bool operator<= (const reverse_iterator <_Iterator> & __x,
                        const reverse_iterator <_Iterator> & __y)
{
    return !(__y < __x);
}


template <class _Iterator>
inline bool operator>= (const reverse_iterator <_Iterator> & __x, 
                        const reverse_iterator <_Iterator> & __y)
{
    return !(__x < __y);
}


template <class _Iterator>
inline typename iterator_traits<_Iterator> ::difference_type
operator- (const reverse_iterator <_Iterator> & __x, 
           const reverse_iterator <_Iterator> & __y)
{
    return __y.base () - __x.base ();
}


template <class _Iterator>
inline reverse_iterator <_Iterator>
operator+ (typename iterator_traits<_Iterator> ::difference_type __n, 
           const reverse_iterator <_Iterator> &     __x)
{
    return __x + __n;
}



# 377 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"


# 391 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_iterator.h"


template <class _Container>
class back_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    explicit back_insert_iterator (container_type& __rhs)
        : container (&__rhs) { }

    back_insert_iterator&
    operator= (typename container_type::const_reference __x) {
        return container->push_back (__x), *this;
    }

    back_insert_iterator& operator*  () {
        return *this;
    }

    back_insert_iterator& operator++ () {
        return *this;
    }

    back_insert_iterator operator++ (int) {
        return *this;
    }

protected:

    container_type* container;
};


template <class _Container>
inline back_insert_iterator<_Container> back_inserter (_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}


template <class _Container>
class front_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    explicit front_insert_iterator (container_type& __rhs)
        : container (&__rhs) { }

    front_insert_iterator&
    operator= (typename container_type::const_reference __x) { 
        return container->push_front (__x), *this;
    }

    front_insert_iterator& operator* () {
        return *this;
    }

    front_insert_iterator& operator++ () {
        return *this;
    }

    front_insert_iterator operator++ (int) {
        return *this;
    }

protected:

    container_type* container;
};


template <class _Container>
inline front_insert_iterator<_Container> front_inserter (_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}


template <class _Container>
class insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    insert_iterator (container_type                    &__x,
                     typename container_type::iterator __it)
      : iter (__it), container (&__x) { }

    insert_iterator&
    operator= (typename container_type::const_reference __x) { 
        iter = container->insert (iter, __x);
        return ++iter, *this;
    }

    insert_iterator& operator* () {
        return *this;
    }

    insert_iterator& operator++ () {
        return *this;
    }

    insert_iterator& operator++ (int) {
        return *this;
    }

protected:

    typename container_type::iterator iter;
    container_type*                    container;
};


template <class _Container, class _Iterator>
inline insert_iterator<_Container> inserter (_Container& __x, _Iterator __it)
{
    typedef typename _Container::iterator _Iter;

    return insert_iterator<_Container> (__x, _Iter (__it));
}


}   



# 40 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"































 




# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"










































  




# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\new"



 





 

 


 

# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"
 






 

 
 
 





 





# 103 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stddef.h"




      using ::std::size_t;
      using ::std::ptrdiff_t;

        using ::std::max_align_t;






 

# 21 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\new"





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\exception"



 





 





 


 

namespace std {

 


  class exception {
  public:
    exception() throw();
    exception(const exception&) throw();
    exception& operator=(const exception&) throw();
    virtual ~exception() throw();
    virtual const char* what() const throw();
  };

  class bad_exception : public exception {
  public:
    bad_exception() throw();
    bad_exception(const bad_exception&) throw();
    bad_exception& operator=(const bad_exception&) throw();
    virtual ~bad_exception() throw();
    virtual const char* what() const throw();
  };



  typedef void (*terminate_handler)();
  extern terminate_handler set_terminate(terminate_handler) throw();

  typedef void (*unexpected_handler)();
  extern unexpected_handler set_unexpected(unexpected_handler) throw();

  void terminate();
  void unexpected();

  extern bool uncaught_exception() throw();

}   









# 28 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\new"



namespace std {





  typedef unsigned int size_t;    


 


  class bad_alloc : public exception {
  public:
    bad_alloc() throw();
    bad_alloc(const bad_alloc&) throw();
    bad_alloc& operator=(const bad_alloc&) throw();
    virtual ~bad_alloc() throw();
    virtual const char* what() const throw();
  };

  class bad_array_new_length : public bad_alloc {
  public:
    bad_array_new_length() throw();
    virtual ~bad_array_new_length() throw();
  };



  typedef void (*new_handler)();
  new_handler set_new_handler(new_handler) throw();
  struct nothrow_t { };
  
  
  extern const nothrow_t nothrow;


}   








 
void *operator new(std::size_t) throw(std::bad_alloc);

 
void operator delete(void*) throw ();

 
void *operator new(std::size_t, const std::nothrow_t&) throw();

 
void operator delete(void*, const std::nothrow_t&) throw();

 
inline void *operator new(std::size_t, void* __ptr) throw() { return __ptr; }

 
inline void operator delete(void*, void*) throw() {   }


 
void *operator new[](std::size_t) throw(std::bad_alloc);

 
void operator delete[](void*) throw ();

 
inline void *operator new[](std::size_t, void* __ptr) throw() { return __ptr; }

 
inline void operator delete[](void*, void*) throw() {   }

 
void *operator new[](std::size_t,
                     const std::nothrow_t&) throw();

 
void operator delete[](void*,
                       const std::nothrow_t&) throw();


 

# 49 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"
# 50 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"

# 52 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_mutex.h"





































































 




# 76 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_mutex.h"

# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstring"



 





 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string.h"
 
 
 
 




 








 













        namespace std {

        extern "C" {





  



    typedef unsigned int size_t;    
# 54 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string.h"




extern __declspec(__nothrow) void *memcpy(void * __restrict  ,
                    const void * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) void *memmove(void *  ,
                    const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
   







 
extern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
   





 

extern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
   






 






 

extern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
   





 
extern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   





 
extern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   







 

extern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
   













 



extern __declspec(__nothrow) const void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
extern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
extern "C++" inline void *memchr(void * __s, int __c, size_t __n)
    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }



   





 


extern __declspec(__nothrow) const char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
extern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
extern "C++" inline char *strchr(char * __s, int __c)
    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }



   




 

extern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   




 


extern __declspec(__nothrow) const char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
extern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
extern "C++" inline char *strpbrk(char * __s1, const char * __s2)
    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }



   




 


extern __declspec(__nothrow) const char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
extern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
extern "C++" inline char *strrchr(char * __s, int __c)
    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }



   





 

extern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   



 


extern __declspec(__nothrow) const char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
extern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
extern "C++" inline char *strstr(char * __s1, const char * __s2)
    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }



   





 

extern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
extern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));

extern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));

   

































 

extern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
   



 
extern __declspec(__nothrow) char *strerror(int  );
   





 
extern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
   



 

extern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   
















 

extern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
   






















 

extern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
    














































 


         }   
      }   



# 502 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string.h"



 

# 18 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstring"


# 26 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstring"
  


# 78 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_mutex.h"

# 1217 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_mutex.h"


namespace __rw {


template <class _TypeT, class _TypeU>
inline
_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
{
    _TypeT __tmp = __t;
    __t = __u;
    return __tmp;
}




struct __rw_mutex_base
{
    void _C_acquire () { }

    void _C_release () { }
};


struct  __rw_mutex: public __rw_mutex_base
{
};


struct __rw_guard
{
    __rw_guard (__rw_mutex_base&) { }

    __rw_guard (__rw_mutex_base*) { }

    __rw_mutex_base* _C_set (__rw_mutex_base*) {
        return 0;
    }
};


struct __rw_synchronized
{
    
    static __rw_mutex _C_mutex;

    void _C_lock () { }

    void _C_unlock () { }

    __rw_guard _C_guard () {
        return __rw_guard (_C_mutex);
    }
};


}   





namespace __rw {



template <class _TypeT, class _TypeU>
inline
_TypeT __rw_ordinary_exchange (_TypeT &__t, const _TypeU &__u)
{
    _TypeT __tmp = __t;
    __t = __u;
    return __tmp;
}

}   




# 53 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"
# 54 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"


namespace __rw {


 void* __rw_allocate (std::size_t, int = 0);
 void  __rw_deallocate (void*, std::size_t, int = 0);





template <class _Container>
inline std::size_t __rw_new_capacity (std::size_t __size, const _Container*)
{
    std::size_t __cap = static_cast< std::size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));


    return (__size += std::size_t (32)) > __cap ? __size : __cap;
}


template <class _TypeT>
inline void __rw_destroy (_TypeT &__ref)
{
    __ref.~_TypeT ();
}


template <class _TypeT, class _TypeU>
inline void __rw_construct (_TypeT* __p, const _TypeU& __val)
{
    new (__p) _TypeT (__val);
}


template <class _ForwardIterator> 
void __rw_destroy (_ForwardIterator __first, _ForwardIterator __last)
{
    for (; __first != __last; ++__first)
        __rw_destroy (*__first);
}





template <class _TypeT> 
inline void __rw_destroy (_TypeT**, _TypeT**)
{ }




}   


namespace std {


template <class _TypeT> class
allocator;


template< >
class allocator<void>
{
public:
    typedef void*       pointer;
    typedef const void* const_pointer;
    typedef void        value_type;
   



    template <class _TypeU> 
    struct rebind {
        typedef allocator<_TypeU> other;
    };


    
};


template <class _TypeT>
class allocator
{
public:
    typedef std::size_t    size_type;
    typedef ptrdiff_t           difference_type;
    typedef _TypeT              value_type;
    typedef value_type*         pointer;
    typedef const value_type*   const_pointer;
    typedef value_type&         reference;
    typedef const value_type&   const_reference;

    allocator ()  { }

    allocator (const allocator &__rhs)  {
        
        ((void)&__rhs);
    }



    template <class _TypeU> 
    struct rebind {
        typedef allocator<_TypeU> other;
    };

    template <class _TypeU>
    allocator (const allocator<_TypeU>&)  { }

    template <class _TypeU>
    allocator&
    operator= (const allocator<_TypeU>&)  { 
        return *this; 
    }




    pointer address (reference __x) const { 
        return &__x; 
    }

    const_pointer address (const_reference __x) const { 
        return &__x;
    }

    pointer allocate (size_type __n, allocator<void>::const_pointer = 0) {


        return static_cast< pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));




    }


    void deallocate (pointer __p, size_type __n)



    {
        __rw::__rw_deallocate (__p, __n);
    }

    
    size_type max_size () const  { 
        return size_type (~0) / sizeof (value_type) ?
            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
    }

    void construct (pointer __p, const_reference __val) {
        __rw::__rw_construct (__p, __val);
    }
    
    void destroy (pointer __p) {
        ((void)0);
        __rw::__rw_destroy (*__p);
    }
};







template <class _TypeT>
class allocator<const _TypeT>
{
public:
    typedef std::size_t    size_type;
    typedef ptrdiff_t           difference_type;
    typedef const _TypeT        value_type;
    typedef const value_type*   pointer;
    typedef const value_type*   const_pointer;
    typedef const value_type&   reference;
    typedef const value_type&   const_reference;

    allocator ()  { }

    allocator (const allocator &__rhs)  {
        
        ((void)&__rhs);
    }



    template <class _TypeU> 
    struct rebind {
        typedef allocator<_TypeU> other;
    };

    template <class _TypeU>
    allocator (const allocator<_TypeU>&)  { }

    template <class _TypeU>
    allocator& operator= (const allocator<_TypeU>&)  { 
        return *this; 
    }



    const_pointer address (const_reference __x) const { 
        return &__x;
    }

    const_pointer
    allocate (size_type __n, allocator<void>::const_pointer = 0) { 


        return static_cast< const_pointer >(__rw::__rw_allocate (__n * sizeof (value_type)));





    }


    void deallocate (const_pointer __p, size_type __n  )



    {
        __rw::__rw_deallocate (const_cast< _TypeT* >(__p), __n);
    }

    
    size_type max_size () const  { 
        return ~size_type (0) / sizeof (value_type) ?
            size_type (size_type (~0) / sizeof (value_type)) : size_type (1);
    }

    void construct (const_pointer __p, const_reference __val) {
        __rw::__rw_construct (const_cast< _TypeT* >(__p), __val);
    }
    
    void destroy (const_pointer __p) {
        ((void)0);
        __rw::__rw_destroy (const_cast< _TypeT& >(*__p));
    }
};
















# 405 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"


template <class _TypeT, class _TypeU>
inline bool
operator== (const allocator<_TypeT>&, const allocator<_TypeU>&)  
{
    return true;
}




template <class _TypeT, class _TypeU>
inline bool
operator!= (const allocator<_TypeT>& __x,
            const allocator<_TypeU>& __y)  
{
    return !(__x == __y);
}





template <class _OutputIterator, class _TypeT>
class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
    _OutputIterator _C_iter;
public:

    
    typedef _OutputIterator iterator_type;

    
    explicit raw_storage_iterator (iterator_type __x) : _C_iter (__x) { }

    
    raw_storage_iterator& operator* () {
        return *this;
    }

    
    raw_storage_iterator& operator= (const _TypeT& __rhs) {
        ::new (&(*_C_iter)) _TypeT (__rhs);
        return *this;
    }

    
    raw_storage_iterator& operator++ () {
        ++_C_iter;
        return *this;
    }

    
    raw_storage_iterator operator++ (int) {
        raw_storage_iterator __tmp = *this;
        ++*this;
        return __tmp;
    }
};


}   


namespace __rw {




template <class _TypeT>
class __rw_indestructible
{
    union _C_data_t {
        char        _C_data;      
        long double _C_padding;   
    };

    enum { _C_n = 1 + sizeof (_TypeT) / sizeof (_C_data_t) };

    _C_data_t _C_data [_C_n];     

public:
    typedef _TypeT            value_type;
    typedef value_type&       reference;
    typedef const value_type& const_reference;
    typedef value_type*       pointer;
    typedef const value_type* const_pointer;

    

    
    operator reference () {
        return reinterpret_cast< reference >(*_C_data);
    }

    operator const_reference () const {
        return reinterpret_cast< const_reference >(*_C_data);
    }

    
    pointer operator& () {
        
        

        return &(reference)*this;
    }
    
    
    const_pointer operator& () const {
        
        

        return &(const_reference)*this;
    }
};




inline  char* __rw_get_static_buf ()
{
    typedef char _CharBuf [4096 + 1];

    
    static __rw_indestructible<_CharBuf> __buffer;

    return static_cast< char* >(__buffer);
}







inline  std::pair<void*, std::size_t>
__rw_reallocate_temp_buffer (void *__p, std::size_t __size)
{
    
    
    

    static unsigned long __busy  ;   

    unsigned long __cntr = ++(__busy);

    static char *__buffer = __rw_get_static_buf ();

    if (__p == (void*)__buffer) {
        __p    = 0;
        __size = 0;

        
        --(__busy);
    }
    else
        ::operator delete (__p);

    if (__size == 0) {
        
        --(__busy);
    }
    else if (__size > 4096 || __cntr > 1) {
         {
            __p = ::operator new (__size);
        }
        while (0) {
            __p    = 0;
            __size = 0;
        }

        
        --(__busy);
    }
    else {
        __p = __buffer;

        
    }

    return std::pair<void*, std::size_t>(__p, __size);
}

# 596 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"

}   


namespace std {











template <class _TypeT, class _Distance>
inline pair<_TypeT*, _Distance> get_temporary_buffer (_Distance __n, _TypeT*)
{
    pair<void*, size_t> __pair =
        __rw::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));

    return make_pair (static_cast< _TypeT* >(__pair . first),
                      _Distance (__pair.second / sizeof (_TypeT)));
}





template <class _TypeT>
inline pair<_TypeT*, ptrdiff_t> get_temporary_buffer (ptrdiff_t __n)
{
    return get_temporary_buffer (__n, (_TypeT*)0);
}





template <class _TypeT>
inline void return_temporary_buffer (_TypeT *__p)
{
    __rw::__rw_reallocate_temp_buffer (__p, 0);
}



template <class _InputIterator, class _ForwardIterator>
inline
_ForwardIterator uninitialized_copy (_InputIterator   __first,
                                     _InputIterator   __last,
                                     _ForwardIterator __res)
{
    _ForwardIterator __start = __res;

     {
        for (; __first != __last; ++__first, ++__res)
            __rw::__rw_construct (&*__res, *__first);
    }
    while (0) {
        __rw::__rw_destroy (__start, __res);
        ((void)0);
    }

    return __res;
}





template <class _InputIterator, class _ForwardIterator, class _Allocator>
inline
_ForwardIterator uninitialized_copy (_InputIterator   __first,
                                     _InputIterator   __last,
                                     _ForwardIterator __res,
                                     _Allocator&      __alloc)
{
    _ForwardIterator __start = __res;

     {
        for (; __first != __last; ++__first, ++__res)
            __alloc.construct (&*__res, *__first);
    }
    while (0) {
        for (; __start != __res; ++__start)
            __alloc.destroy (&*__start);
        ((void)0);
    }

    return __res;
}





template <class _ForwardIterator, class _TypeT>
inline
void uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last,
                         const _TypeT& __x)
{
    _ForwardIterator __start = __first;

     {
        for (; __first != __last; ++__first)
            __rw::__rw_construct (&*__first, __x);
    }
    while (0) {
        __rw::__rw_destroy (__start, __first);
        ((void)0);
    }
}



template <class _ForwardIterator, class _Size, class _TypeT>
inline
void uninitialized_fill_n (_ForwardIterator __first, _Size __n,
                           const _TypeT& __x)
{
    _ForwardIterator __start = __first;

     {
        for (; __n; --__n, ++__first)
            __rw::__rw_construct (&*__first, __x);
    }
    while (0) {
        __rw::__rw_destroy (__start, __first);
        ((void)0);
    }
}





template <class _ForwardIter, class _Size, class _TypeT, class _Allocator>
inline
void uninitialized_fill_n (_ForwardIter __first, _Size __n,
                           const _TypeT& __x, _Allocator& __alloc)
{
    _ForwardIter __start = __first;

     {
        for (; __n; --__n, ++__first)
            __alloc.construct (&*__first, __x);
    }
    while (0) {
        for (; __start != __first; ++__start)
            __alloc.destroy (&*__start);
        ((void)0);
    }
}

# 805 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\memory"




template<class _TypeT>
class auto_ptr;




template <class _TypeT>
class auto_ptr_ref 
{
public:
    auto_ptr<_TypeT>& _C_ptr;

    auto_ptr_ref (auto_ptr<_TypeT>& __rhs) : _C_ptr (__rhs) { }
};


template<class _TypeT>
class auto_ptr
{
public:
    typedef _TypeT element_type;

    explicit auto_ptr (element_type* __p = 0) 
     : _C_ptr (__p) { }

    auto_ptr (auto_ptr& __rhs) 
     : _C_ptr (__rhs.release ()) { }

    auto_ptr& operator= (auto_ptr& __rhs)  { 
        reset (__rhs.release ());
        return *this;
    }

    
    auto_ptr&
    operator= (auto_ptr_ref<element_type> __rhs)  {
        reset (__rhs._C_ptr.release ());
        return *this;
    }



    template <class _TypeU>
    operator auto_ptr_ref<_TypeU>()  {
        return auto_ptr_ref<_TypeU>(*this);
    }

    template <class _TypeU> 
    operator auto_ptr<_TypeU>()  {
        return auto_ptr<_TypeU>(release ());
    }

    template <class _TypeU>
    auto_ptr (auto_ptr<_TypeU>& __rhs) 
    : _C_ptr (__rhs.release ()) { }

    template <class _TypeU>
    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs)   { 
        reset (__rhs.release ());
        return *this;
    }




    ~auto_ptr ()  {
        delete _C_ptr;
    }

    element_type* get () const  {
        return _C_ptr;
    }

    element_type& operator* () const  {
        ((void)0);
        return *get (); 
    }

    element_type* operator-> () const { return & * *this; }


    element_type* release ()  { 
        element_type* __tmp = _C_ptr;
        _C_ptr = 0;
        return __tmp; 
    }

    void reset (element_type* __p = 0)  { 
        if (_C_ptr != __p) {
            delete _C_ptr;
            _C_ptr = __p;
        }
    }

    auto_ptr (auto_ptr_ref<element_type> __r) 
    : _C_ptr (__r._C_ptr.release ()) { }

private:
    element_type* _C_ptr;
};


}   




# 38 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"
# 39 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"































 




# 38 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"

# 40 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstdio"



 





 





# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdio.h"
 
 
 





 






 







 




  
 










      namespace std {

        extern "C" {





  



    typedef unsigned int size_t;    









 
 

 



    typedef struct __va_list __va_list;






   




 




typedef struct __fpos_t_struct {
    unsigned __int64 __pos;
    



 
    struct {
        unsigned int __state1, __state2;
    } __mbstate;
} fpos_t;
   


 


   

 

typedef struct __FILE FILE;
   






 

# 136 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdio.h"


extern FILE __stdin, __stdout, __stderr;
extern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;

# 166 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdio.h"
    

    

    





     



   


 


   


 

   



 

   


 




   


 





    


 






extern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
   








 
extern __declspec(__nothrow) FILE *tmpfile(void);
   




 
extern __declspec(__nothrow) char *tmpnam(char *  );
   











 

extern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
   







 
extern __declspec(__nothrow) int fflush(FILE *  );
   







 
extern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
                           const char * __restrict  ) __attribute__((__nonnull__(1,2)));
   








































 
extern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
                    const char * __restrict  ,
                    FILE * __restrict  ) __attribute__((__nonnull__(2,3)));
   








 
extern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
                    char * __restrict  ) __attribute__((__nonnull__(1)));
   




 
extern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
                   char * __restrict  ,
                   int  , size_t  ) __attribute__((__nonnull__(1)));
   















 
#pragma __printf_args
extern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   


















 
#pragma __printf_args
extern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 
#pragma __printf_args
extern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   




 
#pragma __printf_args
extern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   



 
#pragma __printf_args
extern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   






 
#pragma __printf_args
extern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 

#pragma __printf_args
extern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(3)));


#pragma __printf_args
extern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(3)));
   















 

#pragma __printf_args
extern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
                      const char * __restrict  , ...) __attribute__((__nonnull__(3)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   






























 
#pragma __scanf_args
extern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   






 
#pragma __scanf_args
extern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
   



 
#pragma __scanf_args
extern __declspec(__nothrow) int sscanf(const char * __restrict  ,
                    const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   








 
#pragma __scanf_args
extern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
                     const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
   



 

 
extern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
extern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));

extern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
extern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
extern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));

extern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
   



 
extern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
                    const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int vsprintf(char * __restrict  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   






 
extern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));

extern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));
   







 

extern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
                      const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   



 
extern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
                     const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1,2)));
   



 
extern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
                      const char * __restrict  , __va_list  ) __attribute__((__nonnull__(3)));
   



 

#pragma __printf_args
extern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
extern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));

#pragma __printf_args
extern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
extern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
   








 

extern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
   







 
extern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
                    FILE * __restrict  ) __attribute__((__nonnull__(1,3)));
   










 
extern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   







 
extern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
   




 
extern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
   







 

    inline int getchar() { return getc((& ::std:: __stdin)); }




   





 
extern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
   









 
extern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   





 

    inline int putchar(int __c) { return putc(__c, (& ::std:: __stdout)); }




   



 
extern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
   





 
extern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
   






















 

extern __declspec(__nothrow) size_t fread(void * __restrict  ,
                    size_t  , size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,4)));
   











 

extern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
                    size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,3)));
   











 

extern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
                    size_t  , size_t  , FILE * __restrict  ) __attribute__((__nonnull__(1,4)));
   







 

extern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
   








 
extern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
   














 
extern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
   










 
extern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
   











 
extern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
   





 

extern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
   




 

extern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
   


 
extern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
   


 
extern __declspec(__nothrow) void perror(const char *  );
   









 

extern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
    
 

extern __declspec(__nothrow) void __use_no_semihosting_swi(void);
extern __declspec(__nothrow) void __use_no_semihosting(void);
    





 


        }   
      }   







# 1021 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdio.h"



 

# 18 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstdio"


# 26 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\cstdio"



# 41 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
# 42 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
# 43 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"










namespace std {




typedef long streamsize;
typedef long streamoff;





 

template <class _StateT>
class fpos
{
public:

    typedef _StateT  state_type;

    fpos (streamoff __off = 0) 
        : _C_pos (__off),
          _C_state ()
        {
    }

    fpos (streamoff __off, state_type __state) 
        : _C_pos (__off),
          _C_state (__state)
        { }

    operator streamoff () const {
        return _C_pos;
    }

    fpos (const fpos&);

    fpos& operator= (const fpos&);

    state_type state () const {
        return _C_state;
    }

    void state (state_type __state) {
        _C_state = __state;
    }

    
    fpos operator- (const fpos &__off) const {
        return fpos (*this) -= __off;
    }

    fpos operator+ (const fpos &__off) const {
        return fpos (*this) += __off;
    }

    fpos& operator-= (const fpos &__off) {
        return _C_pos -= __off._C_pos, *this;
    }

    fpos& operator+= (const fpos &__off) {
        return _C_pos += __off._C_pos, *this;
    }

    fpos operator- (streamoff __off) const {
        return fpos (*this) -= __off;
    }

    fpos operator+ (streamoff __off) const {
        return fpos (*this) += __off;
    }

    fpos& operator-= (streamoff __off) {
        return _C_pos -= __off, *this;
    }

    fpos& operator+= (streamoff __off) {
        return _C_pos += __off, *this;
    }

    
    bool operator== (const fpos& __rhs) const; 

    bool operator< (const fpos& __rhs) const {
        return _C_pos < __rhs._C_pos;
    }

    bool operator<= (const fpos& __rhs) const {
        return !(__rhs < *this);
    }

    bool operator>= (const fpos& __rhs) const {
        return !(*this < __rhs);
    }

    bool operator!= (const fpos& __rhs) const {
        return !(*this == __rhs);
    }

    bool operator> (const fpos& __rhs) const {
        return __rhs < *this;
    }

    bool operator== (streamoff __rhs) const {
        return _C_pos == __rhs;
    }

    bool operator< (streamoff __rhs) const {
        return _C_pos < __rhs;
    }

    bool operator<= (streamoff __rhs) const {
        return _C_pos <= __rhs;
    }

    bool operator>= (streamoff __rhs) const {
        return _C_pos >= __rhs;
    }

    bool operator> (streamoff __rhs) const {
        return _C_pos > __rhs;
    }

    bool operator!= (streamoff __rhs) const {
        return !(_C_pos == __rhs);
    }

private:

    streamoff   _C_pos;     
    state_type  _C_state;   
};


template <class _StateT> 
inline
fpos<_StateT>::fpos(const fpos<_StateT>& __rhs)
{
    _C_pos    = __rhs._C_pos;
    _C_state  = __rhs._C_state;
}


template <class _StateT>
inline fpos<_StateT>& 
fpos<_StateT>::operator= (const fpos<_StateT>& __rhs)
{
    if (&__rhs != this) {
        _C_pos    = __rhs._C_pos;
        _C_state  = __rhs._C_state;
    }
    return *this;
}


template <class _StateT>
inline bool 
fpos<_StateT>::operator== (const fpos<_StateT>& __rhs) const
{ 
    return    _C_pos == __rhs._C_pos



    ;
}


template <class  _CharT> 
struct char_traits 
{
    typedef _CharT                   char_type;
    typedef int                      int_type;
    typedef streamoff                off_type;
    typedef mbstate_t                state_type;
    typedef fpos<state_type>         pos_type;

    static int_type eof () {
        return (-1);
    }

    static void assign (char_type& __c1, const char_type& __c2) {
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        std::size_t __n) {
        std::size_t __i = 0;
        while (__i < __n) { 
            if (!eq (__s1[__i], __s2[__i])) {
                return lt (__s1[__i], __s2[__i]) ? -1 : 1;
            }
            ++__i;
        }
        return 0;
    }
        
    static std::size_t length (const char_type *__s) {
        std::size_t __len = 0;
        while (!eq (*__s++, char_type ()))
            ++__len;
        return __len;
    }
 
    static const char_type* 
    find (const char_type* __s, std::size_t __n, const char_type& __a) {
        while (__n-- > 0 && !eq (*__s, __a) )
            ++__s;
        return  eq (*__s, __a) ? __s : 0;
    }

    static char_type* move (char_type* __s1, const char_type* __s2,
                            std::size_t __n) {
        if (__s1 < __s2)
            copy (__s1, __s2, __n);
        else if (__s1 > __s2) {
            __s1 += __n;
            __s2 += __n;
            for (std::size_t __i = 0; __i < __n; ++__i) 
                assign (*--__s1, *--__s2);
        }
        return __s1;
    }

    static char_type* copy (char_type *__dst, const char_type *__src,
                             std::size_t __n) {
        memcpy (__dst, __src, __n * sizeof (char_type));
        return __dst;
    }

    static char_type*  assign (char_type* __s, std::size_t __n, char_type __a) {
        char_type* __tmp = __s;
        while (__n-- > 0) 
            assign (*__tmp++, __a);
        return __s;
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }

    static char_type to_char_type (const int_type& __c) {
        return __c;
    }
      
    static int_type to_int_type (const char_type& __c) {
        return __c;
    }
};



template< >  
struct char_traits<char> 
{
    typedef char                      char_type;
    typedef int              int_type;
    typedef streamoff                 off_type; 
    typedef mbstate_t                 state_type;
    typedef fpos<state_type>          pos_type;

    static int_type eof () {
        return (-1);
    }

    static void assign (char_type& __c1, const char_type& __c2){
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        std::size_t __n) {
        return memcmp (__s1, __s2, __n);
    }

    static const char_type* find (const char_type* __s, 
                                  std::size_t __n, const char_type& __a) {
        return (char_type*) memchr (__s, __a, __n);
    }

    static std::size_t length (const char_type *__s) {
        return strlen (__s);
    }

    static char_type * move (char_type* __s1, const char_type* __s2,
                             std::size_t __n) {

        memmove (__s1, __s2, __n);
# 370 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
        return __s1;
    }

    static char_type *copy (char_type *__dst, const char_type *__src,
                             std::size_t __n){
        memcpy (__dst, __src, __n); 
        return __dst;
    }

    static char_type* assign (char_type* __s, std::size_t __n, char_type __a) {
        memset (__s, __a, __n);
        return __s;
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }
                        
    static char_type to_char_type (const int_type& __c) {
        return static_cast< char_type >(__c);
    }
      
    static int_type to_int_type (const char_type& __c) {
        
        return static_cast< unsigned char >(__c);
    }
};





template< >  
struct char_traits<wchar_t> 
{
    typedef wchar_t                   char_type;
    typedef int             int_type;
    typedef streamoff                 off_type;
    typedef mbstate_t                 state_type;
    typedef fpos<state_type>          pos_type;





    static int_type eof () {
        return int_type (((::std:: wint_t)-1));
    }

    static void assign (char_type& __c1, const char_type& __c2) {
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        std::size_t __n) {

        return wmemcmp (__s1, __s2, __n);
# 449 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
    }

    static std::size_t length (const char_type *__s) {

        
        return wcslen (const_cast< char_type* >(__s));
# 461 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
    }
      
    static const char_type* find (const char_type* __s, std::size_t __n, 
                                  const char_type& __a)           {

        return static_cast< const char_type* >(wmemchr (__s, __a, __n));





    }

    static char_type * copy (char_type *__dst, const char_type *__src,
                             std::size_t __n) {
        memcpy (__dst, __src, __n * sizeof (char_type));
        return __dst;
    }
      
    static char_type * move (char_type* __s1, const char_type* __s2,
                             std::size_t __n) {

        wmemmove (__s1, __s2, __n);
# 494 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
        return __s1;
    }

    static char_type* assign (char_type* __s, std::size_t __n, char_type __a){

        wmemset (__s, __a, __n);





        return __s;
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }

    static char_type to_char_type (const int_type& __c) {
        return __c;
    }
      
    static int_type to_int_type (const char_type& __c) {
        return __c;
    }
};




}   


namespace __rw {




template <class _CharT, class _Traits> 
struct rw_traits
{
    static const _CharT* find (const _CharT* __s, const _CharT* __v) { 
        std::size_t __slen = _Traits::length (__s);
        std::size_t __vlen = _Traits::length (__v);
        for (std::size_t __j = 0; (__j + __vlen) <= __slen ; ++__j) {
            bool __found = true;
            for (std::size_t __i = 0; __i < __vlen ; ++__i) {
                if (!_Traits::eq (__s[__j + __i], __v[__i])) {
                    __found = false;
                    break;
                }
            }
            if (__found)
                return &__s[__j];
        }
        return 0;
    }

    static const _CharT* rfind (const _CharT* __s, _CharT __v, std::size_t __pos) {
        for  (const _CharT* __p = __s + __pos; __p >= __s; --__p) {
            if (_Traits::eq (*__p, __v))
                return __p;
        }
        return 0;       
    }

    static std::size_t find_first_of (const _CharT* __s, const _CharT* __v) {
        const _CharT* __p = __s;
        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
            for (const _CharT* __q = __v; !_Traits::eq (*__q, _CharT ()); ++__q)
                if (_Traits::eq (*__p, *__q))
                    return __p - __s;
        }
        return  __p - __s;
    }

    static std::size_t find_first_not_of (const _CharT* __s, const _CharT* __v) {
        bool __found;
        const _CharT* __p = __s;
        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
            __found = false;
            for (const _CharT* __q = __v;
                 !_Traits::eq (*__q, _CharT ()); ++__q){
                if (_Traits::eq (*__p, *__q)){
                    __found = true; 
                    break;
                }  
            }
            if (!__found)      
                return __p - __s;
        }
        return  __p-__s;
    }
};


template< > 
struct rw_traits<char, std::char_traits<char> >
{
    static const char* find (const char* __s, const char* __v) {
        return std::strstr (__s, __v);
    }

    static const char* rfind (const char* __s, char __v, std::size_t __pos) { 
        const char* __p = __s + __pos;
        while (__p >= __s)
        {
            if (std::char_traits<char>::eq (*__p, __v))
                return __p;
            __p--; 
        }
        return 0;       
    }

    static std::size_t find_first_of (const char* __s, const char* __v) {
        return std::strcspn (__s, __v);
    }

    static std::size_t find_first_not_of (const char* __s, const char* __v) {
        return std::strspn (__s, __v);
    }

};


template< > 
struct rw_traits<wchar_t, std::char_traits<wchar_t> >
{
    static const wchar_t* find (const wchar_t* __s, const wchar_t* __v) {

        return std::wcsstr (__s, __v);
# 646 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_traits.h"
    }

    static const wchar_t* rfind (const wchar_t* __s, wchar_t __v, 
                                std::size_t __pos) { 
        const wchar_t* __p = __s + __pos;
        while (__p >= __s) {
            if (std::char_traits<wchar_t>::eq (*__p, __v))
                return __p;
            __p--;
        }
        return 0;       
    }

    static std::size_t find_first_of (const wchar_t* __s, const wchar_t* __v) {
        return std::wcscspn (__s, __v);
    }

    static std::size_t find_first_not_of (const wchar_t* __s, const wchar_t* __v) {
        return std::wcsspn (__s, __v);
    }

};


}   




# 40 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"
# 41 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"


namespace std {




# 55 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"


template< class _CharT,
          class _Traits = char_traits<_CharT>, 
          class _Allocator = allocator<_CharT> >
class basic_string;


}   


namespace __rw {


# 75 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"






# 88 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"


template <class _CharT, class _Traits , class _Allocator>
struct __string_ref
{
    typedef _CharT                                            char_type;
    typedef _Allocator                                        allocator_type;
    typedef typename allocator_type::size_type               size_type;
    typedef std::basic_string<_CharT, _Traits, _Allocator>   string_type;

# 130 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"

    void _C_init (size_type __ref, size_type __cap, size_type __size) {


        _C_refs = __ref - 1;




        _C_cap  = __cap;
        _C_size = __size;
    }

    void _C_destroy () { }



    size_type _C_ref_count () const {


        return this->_C_refs + 1;



    }

    void _C_set_ref_count (size_type __ref) { 



        if (this != (void*)&string_type::__nullref)
            __rw::__rw_atomic_exchange ((this->_C_refs), (__ref - 1), false);





    }

    void _C_inc_ref () { 



        if (this != (void*)&string_type::__nullref)
            ++(this->_C_refs);



    }

    size_type _C_dec_ref () {



        if (this != (void*)&string_type::__nullref)
            return 1 + --(this->_C_refs);

        return 1;




    }

    size_type size () const {
        return this->_C_size;
    }

    size_type capacity () const {
        return this->_C_cap;
    }

    char_type* data () {
        return reinterpret_cast< char_type* >(this + 1);
    }

    const char_type* data () const {
        return reinterpret_cast< const char_type* >(this + 1);
    }



# 219 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_strref.h"

    long      _C_refs;      
                            



    size_type _C_cap;       

    union {
        size_type _C_size;  
        _CharT    _C_dummy; 
    };
};




template <class _CharT, class _Traits , class _Allocator>
struct __null_ref
    : __string_ref<_CharT, _Traits , _Allocator>
{
    
    _CharT _C_eos;
};


}   




# 41 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"
# 42 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_error.h"































 





   
# 40 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_error.h"

namespace __rw {



void  __rw_throw (int, ...);

extern "C" {








extern void  (*__rw_throw_proc)(int, char*);

}   

}   





   
   
   




   
   




   










# 100 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_error.h"













# 137 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\rw/_error.h"








# 43 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"


namespace std {


template <class _CharT, class _Traits, class _Allocator>
class basic_string: private _Allocator
{
public:

    typedef _Traits                               traits_type;
    typedef typename traits_type::char_type      value_type;
    typedef _Allocator                            allocator_type;

private:

    typedef __rw::__string_ref<value_type, traits_type, allocator_type>
     _C_string_ref_type;

    typedef  allocator_type          
        _C_value_alloc_type;
    typedef  typename allocator_type::template rebind < _C_string_ref_type > ::other  
        _C_ref_alloc_type;
      
public:

    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;

# 93 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

    typedef pointer                        iterator;
    typedef const_pointer                  const_iterator;

    iterator _C_make_iter (pointer __ptr) {
        return __ptr;
    }

    const_iterator _C_make_iter (const_pointer __ptr) const {
        return __ptr;
    }






    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator>       reverse_iterator;
# 122 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"




    static const size_type npos = size_type(-1);


    explicit
    basic_string (const allocator_type &__alloc = allocator_type ())
        : allocator_type (__alloc), _C_data (_C_null ()) { }

    
    basic_string (const basic_string&);

    basic_string (const basic_string&, size_type, size_type = npos, 
                  const allocator_type& = allocator_type ());

    basic_string (const_pointer, size_type, 
                  const allocator_type& = allocator_type ());

    basic_string (const_pointer, const allocator_type& = allocator_type ());




    
    
    
    

    template <class _InputIterator>
    basic_string (_InputIterator, _InputIterator, 
                  const allocator_type& = allocator_type ());

    basic_string (int __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }

    basic_string (unsigned int __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
      : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }

    basic_string (long __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }

    basic_string (unsigned long __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }

    basic_string (short __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }

    basic_string (unsigned short __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }

    basic_string (char __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }

    basic_string (unsigned char __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {  
        _C_initn (static_cast< size_type >(__n), __c);  
    }




    basic_string (wchar_t __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }






    basic_string (bool __n, value_type __c, 
                  const allocator_type& __alloc = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (static_cast< size_type >(__n), __c);
    }




# 236 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"


    basic_string (const_pointer, const_pointer, 
                  const allocator_type& = allocator_type ());

    ~basic_string () {
        _C_unlink();
    }

    basic_string& operator= (const basic_string&);
    basic_string& operator= (const_pointer __s);

    basic_string& operator= (value_type __c) {
        return replace (0, size(), 1, __c);
    }

    iterator begin () {
        _C_cow ();
        _C_pref ()->_C_set_ref_count (0);   
        return _C_make_iter (_C_data);
    }

    const_iterator begin () const {
        return _C_make_iter (_C_data);
    }

    iterator end () {
        
        return begin () + size ();
    }

    const_iterator end () const {
        return _C_make_iter (_C_data + size ());
    }

    reverse_iterator rbegin () {
        return reverse_iterator (end ());
    }

    const_reverse_iterator rbegin () const {
        return const_reverse_iterator (end ());
    }

    reverse_iterator rend () {
        return reverse_iterator (begin ());
    }

    const_reverse_iterator rend () const {
        return const_reverse_iterator (begin ());
    }

    size_type size () const {
        return _C_pref()->_C_size;
    }

    size_type length () const {
        return size ();
    }

    size_type max_size () const {
        return size_type (npos) - sizeof (_C_string_ref_type) - 2U;
    }

    void resize (size_type, value_type);

    void resize (size_type __n) {
        resize (__n, value_type ()); 
    }

    size_type capacity () const {
        return _C_pref ()->capacity ();
    }

    void reserve (size_type = 0);

    void clear () {
        erase ();
    }

    bool empty () const  {
        return size () == 0;
    }

    const_reference operator[] (size_type) const;
    reference       operator[] (size_type);

    const_reference at (size_type) const;
    reference       at (size_type);

    basic_string& operator+= (const basic_string &__s) {
        return append (__s);
    }

    basic_string& operator+= (const_pointer __s) {
        return append (__s);
    }

    basic_string& operator+= (value_type __c) {
        return append (size_type (1), __c);
    }

    basic_string& append (const basic_string&, size_type, size_type);

    basic_string& append (const basic_string &__str);

    basic_string& append (const_pointer __s, size_type __n) {
        return replace (size (), 0, __s, __n, 0, __n), *this;
    }

    basic_string& append (const_pointer __s) {
        return replace (size (), 0, __s);
    }




    template<class _InputIterator>
    basic_string& append (_InputIterator __first, _InputIterator __last) {
        
        
        
        return append (__first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
    }

    template<class _InputIterator>
    basic_string& append (_InputIterator __first, _InputIterator __last,
                          const __rw::__rw_select < false > *) {
        return replace (_C_make_iter (_C_data + size ()),
                        _C_make_iter (_C_data + size ()),
                        __first, __last), *this;
    }

    basic_string& append (size_type __n, value_type __c,
                          const __rw::__rw_select < true > *) {
        
        return replace (size (), 0, __n, __c);
    }

# 382 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

    basic_string& append (size_type __n, value_type __c) {
        return replace (size (), 0, __n, __c);
    }

    void push_back (value_type __c) {
        append (size_type (1), __c);
    }

    basic_string& assign (const basic_string &__str) {
        return *this = __str;
    }

    basic_string& assign (const basic_string&, size_type, size_type);

    basic_string& assign (const_pointer __s, size_type __n) {
        return replace (0, size (), __s, __n, 0, __n), *this;
    }

    basic_string& assign (const_pointer __s) {
        return *this = __s;
    }





    template<class _InputIterator>
    basic_string& assign (_InputIterator __first, _InputIterator __last) {
        
        
        
        return assign (__first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
    }

    template<class _InputIterator>
    basic_string& assign (_InputIterator __first, _InputIterator __last,
                          const __rw::__rw_select < false > *) {
        
        
        return replace (_C_make_iter (_C_data),
                        _C_make_iter (_C_data + size ()), __first, __last);
    }

    basic_string& assign (size_type __n, value_type __c,
                          const __rw::__rw_select < true > *) {
        
        return replace (0, size (), __n, __c);
    }

# 441 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

    basic_string& assign (size_type __n, value_type __c) {
        return replace (0, size (), __n, __c);
    }

    basic_string& insert (size_type, const basic_string&);
    basic_string& insert (size_type, const basic_string&,
                          size_type, size_type);

    basic_string& insert (size_type __pos, const_pointer __s, size_type __n) {
        return replace (__pos, 0, __s, __n, 0, __n), *this;
    }

    basic_string& insert (size_type __pos, const_pointer __s) {
        return insert (__pos, __s, traits_type::length (__s));
    }

    
    iterator insert (iterator __pos, value_type __c) {
        ((void)0);
        size_type __inx = __pos - _C_make_iter (_C_data);
        return insert (__inx, &__c, 1), begin () + __inx;
    }





    template<class _InputIterator>
    void insert (iterator __p,
                 _InputIterator __first, _InputIterator __last) {
        
        
        
        
        insert (__p, __first, __last, ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
    }

    void insert (iterator __p, const_iterator __first, const_iterator __last) {
        iterator __begin = _C_make_iter (_C_data);
        iterator __end   = _C_make_iter (_C_data + size ());
        ((void)0);
        if (__first >= __begin && __first <= __end)
            insert (__p - __begin, basic_string (__first, __last));
        else
            replace (__p, __p, __first, __last);
    }

    void insert (iterator __p, iterator __first, iterator __last) {
        insert (__p, const_iterator (__first), const_iterator (__last));
    }

    template <class _InputIterator>
    void insert (iterator __p, _InputIterator __first, _InputIterator __last,
                 const __rw::__rw_select < false > *) {
        
        
        replace (__p, __p, __first, __last);
    }

    void insert (iterator __p, size_type __n, value_type __c,
                 const __rw::__rw_select < true > *) {
        
        replace (__p - _C_make_iter (_C_data), 0, __n, __c);
    }

# 515 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"
    

    void insert (iterator __p, size_type __n, value_type __c) {
        replace (__p - _C_make_iter (_C_data), 0, __n, __c);
    }

    basic_string& insert (size_type __pos, size_type __n, value_type __c) {
        return replace (__pos, 0, __n, __c);
    }

    basic_string& erase (size_type = 0, size_type = npos);

    iterator erase (iterator __it) { 
        return replace (__it - _C_make_iter (_C_data), 1,
                        const_pointer (0), 0, 0, 0);
    }

    iterator erase (iterator __first, iterator __last) {  
        return replace (__first - _C_make_iter (_C_data), __last - __first,
                        const_pointer (0), 0, 0, 0);
    }

private:  

    iterator replace (size_type, size_type, const_pointer,
                      size_type, size_type, size_type);

    iterator __replace_aux (size_type pos1, size_type __n1,
                            const basic_string &__str,
                            size_type pos2 = 0,
                            size_type __n2   = npos) {
        return replace (pos1, __n1, __str.c_str(), __str.size(), pos2, __n2);
    }




    template<class _InputIterator>
    basic_string& __replace_aux (iterator       first1,
                                 iterator       last1, 
                                 _InputIterator first2,
                                 _InputIterator last2);



  public:

    basic_string& replace (size_type pos1, size_type __n1,
                           const basic_string &__s,
                           size_type pos2, size_type __n2) {
        replace (pos1, __n1, __s.c_str (), __s.size (), pos2, __n2);
        return *this;
    }

    basic_string& replace (size_type __pos, size_type __n,
                           const basic_string &__s) {
        return replace (__pos, __n, __s, 0, __s.size ());
    }


    basic_string& replace (size_type __pos, size_type __n1, const_pointer __s,
                           size_type __n2) {
        return replace (__pos, __n1, __s, __n2, 0, __n2), *this;
    }

    basic_string& replace (size_type __pos, size_type __n, const_pointer __s) {
        return replace (__pos, __n, __s, traits_type::length (__s));
    }

    basic_string& replace (size_type, size_type, size_type, value_type);

    basic_string& replace (iterator __first, iterator __last,
                           const basic_string &__str) {
        return replace (__first - _C_make_iter (_C_data),
                        __last - __first, __str);
    }

    basic_string& replace (iterator __first, iterator __last,
                           const_pointer __s, size_type __n) {
        replace (__first - _C_make_iter (_C_data), __last - __first,
                 __s, __n, 0, __n);
        return *this;;
    }

    basic_string&
    replace (iterator __first, iterator __last, const_pointer __s) {
        return replace (__first, __last, __s, traits_type::length(__s));
    }





    template<class _InputIterator>
    basic_string& replace (iterator, iterator,
                           _InputIterator, _InputIterator,
                           const __rw::__rw_select < false > *);


    basic_string& replace (iterator __first, iterator __last,
                           size_type __n, value_type __c,
                           const __rw::__rw_select < true > *) {
        
        return replace (__first - _C_make_iter (_C_data), __last - __first,
                        __n, __c);
    }

    template<class _InputIterator>
    basic_string& replace (iterator __first1, iterator __last1,
                           _InputIterator __first2, _InputIterator __last2) {
        
        
        
        
        return replace (__first1, __last1, __first2, __last2,
                        ((__rw::__rw_select<numeric_limits< _InputIterator > ::is_integer> *)0));
    }

# 642 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

    basic_string& replace (iterator __first, iterator __last,
        size_type __n, value_type __c) {

        
        return replace (__first - _C_make_iter (_C_data), __last - __first,
                        __n, __c);
    }

    size_type copy (pointer, size_type, size_type = 0) const;



    basic_string copy () const {
        return basic_string (data (), data () + size ());
    }



    void swap (basic_string &__s) {
        if (get_allocator () == __s.get_allocator ()) {
            pointer __temp = _C_data;
            _C_data = __s._C_data;
            __s._C_data = __temp;
        }
        else {
            basic_string __tmp = *this;
            *this = __s;
            __s = __tmp;
        }
    }

    
    
    
    const_pointer c_str () const {
        return _C_data;
    }

    const_pointer data () const {
        return _C_data;
    }

    allocator_type get_allocator() const {
        return *this;
    }

    
    size_type find (const basic_string &__str, size_type __pos = 0) const {
        return find (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find (const_pointer, size_type, size_type) const;

    
    size_type find (const_pointer, size_type = 0) const;

    
    size_type find (value_type, size_type = 0) const;

    
    size_type rfind (const basic_string &__str, size_type __pos = npos) const {
        return rfind (__str.c_str (), __pos, __str.size ());
    }

    
    size_type rfind (const_pointer, size_type, size_type) const;

    
    size_type rfind (const_pointer __s, size_type __pos = npos) const {
        return rfind (__s, __pos, traits_type::length (__s));
    }

    
    size_type rfind (value_type, size_type = npos) const;

    
    size_type find_first_of (const basic_string &__str,
                             size_type __pos = 0) const {
        return find_first_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_first_of (const_pointer, size_type, size_type) const;

    
    size_type find_first_of (const_pointer, size_type = 0) const;

    
    size_type find_first_of (value_type __c, size_type __pos = 0) const {
        return find (__c, __pos);
    }

    
    size_type find_last_of (const basic_string &__str,
                            size_type __pos = npos) const {
        return find_last_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_last_of (const_pointer, size_type, size_type) const;

    
    size_type find_last_of (const_pointer __s, size_type __pos = npos) const {
        return find_last_of (__s, __pos, traits_type::length (__s));
    }

    
    size_type find_last_of (value_type __c, size_type __pos = npos) const {
        return rfind (__c, __pos);
    }

    
    size_type find_first_not_of (const basic_string &__str, 
                                 size_type __pos = 0) const {
        return find_first_not_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_first_not_of (const_pointer, size_type,
                                 size_type) const;

    
    size_type find_first_not_of (const_pointer, size_type = 0) const;

    
    size_type find_first_not_of (value_type, size_type = 0) const;

    
    size_type find_last_not_of (const basic_string &__str, 
                                size_type __pos = npos) const {
        return find_last_not_of (__str.c_str (), __pos, __str.size ());
    }

    
    size_type find_last_not_of (const_pointer, size_type, size_type) const;

    
    size_type find_last_not_of (const_pointer __s,
                                size_type __pos = npos) const {
        return find_last_not_of (__s, __pos, traits_type::length (__s));
    }

    
    size_type find_last_not_of (value_type, size_type = npos) const;
  
    
    basic_string substr (size_type = 0, size_type = npos) const;
  
    int compare (const basic_string &__str) const;

    int compare (size_type __pos, size_type __n, const basic_string &__str) const {
        return compare (__pos, __n, __str.c_str(), __str.size());
    }

    int compare (size_type, size_type, const basic_string&, 
                size_type, size_type) const;

    int compare (const_pointer __s) const {
        return compare (0, size (), __s, traits_type::length(__s));
    }

    
    int compare (size_type __pos, size_type __n, const_pointer __s) const {
        return compare(__pos, __n, __s, traits_type::length (__s));
    }

    int compare (size_type, size_type, const_pointer, size_type) const;

protected:

    void _C_cow () {             
        if (_C_pref ()->_C_ref_count() > 1) 
            _C_clone ();
    }

    void _C_cow (size_type __nc) {   
        if (_C_pref ()->_C_ref_count () > 1 || capacity () < __nc)
            _C_clone (__nc);
    }

private:

    void _C_initn (size_type, value_type);

    void _C_clone (size_type __nc = npos);

    _C_string_ref_type* _C_pref () const { 
        return reinterpret_cast< _C_string_ref_type* >(_C_data) - 1; 
    }

    void _C_unlink ();   

    friend struct __rw::__string_ref<value_type, traits_type, allocator_type>;



    static __rw::__null_ref<_CharT, _Traits, _Allocator> __nullref;

    static pointer _C_null () {
        return __nullref.data ();
    }

# 855 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

    _C_string_ref_type * _C_getRep (size_type, size_type);

    
    pointer _C_allocate (size_type __cur, size_type __cap, size_type __size) {
        return _C_getRep (max (size_type (__rw::__rw_new_capacity (__cur, this)),
                               __cap), __size)->data ();
    }

    pointer _C_data;
};


typedef basic_string<char, char_traits<char>, allocator<char> > string;



typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
wstring;




template <class _CharT, class _Traits , class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::_C_unlink()
{
    ((void)0);

    if (data () == _C_null ())
        return;

    if (_C_pref ()->_C_ref_count () == 0 || _C_pref ()->_C_dec_ref () == 0) {
        
        
        size_type __size =
            capacity () + sizeof (_C_string_ref_type) / sizeof (value_type) + 2;

        
        _C_pref ()->_C_destroy ();
        
        _C_ref_alloc_type (*this).destroy (_C_pref ());
        allocator_type::deallocate (reinterpret_cast< pointer >(_C_pref()), __size);



    }
}


template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::
basic_string (const basic_string<_CharT, _Traits, _Allocator> &__s)
    : allocator_type (__s.get_allocator ())
{
    if (__s._C_pref()->_C_ref_count () > 0) {
        _C_data = __s._C_data;
        _C_pref()->_C_inc_ref ();
    }
    else {
        size_type __n = __s.size();
        _C_data  = _C_getRep (__n, __n)->data ();
        traits_type::copy (_C_data, __s.c_str (), __n);
    }
}


template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase (size_type __pos,
                                                  size_type __n)
{
    (__pos <= size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());




    const value_type __tmp =  value_type () ;
    size_type __len = size () - __pos;
    return replace (__pos, __n < __len ? __n : __len, &__tmp, 0);
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference 
basic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos) const
{
# 949 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

    
    return _C_data [__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos)
{
# 968 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

    
    return begin ()[__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at (size_type __pos) const
{
    (__pos < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());




    
    return _C_data [__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at (size_type __pos)
{
    (__pos < size ()) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, size ());




    
    return begin ()[__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::
resize (size_type __n, value_type __c)
{
    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());




    if (__n < size())
        erase (__n, size () - __n);
    else
        replace (size (), 0, __n - size (), __c);
}

template <class _CharT, class _Traits , class _Allocator>
inline void basic_string<_CharT, _Traits, _Allocator>::
reserve (size_type __n)
{
    (__n <= max_size ()) ? (void)0 : __rw::__rw_throw ((0 + 8), "", "", __n, max_size ());




    if (__n > capacity ())
        _C_clone (__n);
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (const_pointer __s, size_type __pos) const
{
    ((void)0);

    
    if (__pos > size ())
        return npos;

    const_pointer __where =
        __rw::rw_traits<value_type, traits_type>::find (_C_data + __pos, __s);
 
   return __where ? __where - _C_data : npos;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (value_type __c, size_type __pos) const
{
    if (__pos > size())
        return npos;

    const_pointer __where =  traits_type::find (_C_data + __pos,
                                                size() - __pos, __c);
    return __where ? __where  - _C_data : npos;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
rfind (value_type __c, size_type __pos) const
{
    if (!size ())
        return npos;

    if (__pos >= size ())
        __pos = size () - 1;   

    const_pointer __where =
        __rw::rw_traits<value_type, traits_type>::rfind (_C_data,
                                                        __c, __pos);
    return __where ? __where - _C_data : npos;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_of (const_pointer __s, size_type __pos) const
{
    ((void)0);

    if (__pos > size())
        return npos;

    typedef __rw::rw_traits<_CharT, _Traits> __rw_traits;

    size_type __i = __rw_traits::find_first_of (_C_data + __pos, __s) + __pos;

    return __i >= size () ? npos : __i;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_not_of (const_pointer __s, size_type __pos) const
{
    ((void)0);

    if (__pos > size())
        return npos;

    typedef __rw::rw_traits<_CharT, _Traits> __rw_traits;
    
    size_type __i = __rw_traits::find_first_not_of(_C_data + __pos, __s)+ __pos;

    return __i >= size () ? npos : __i;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_not_of (value_type __c, size_type __pos) const
{
    return find_first_not_of (&__c, __pos, 1);
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_last_not_of (value_type __c, size_type __pos) const
{




    value_type __tmp [2];
    traits_type::assign (__tmp [0], __c);
    traits_type::assign (__tmp [1], value_type ());


    return find_last_not_of (__tmp, __pos);
}


template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::
_C_clone (size_type __nc  )
{
    size_type __len = size();
    _C_string_ref_type * __temp = _C_getRep (npos == __nc ? size () : __nc,
                                             __len > __nc ? __nc : __len);
    traits_type::copy (__temp->data(), _C_data, size());
    _C_unlink ();
    _C_data = __temp->data ();
}


template <class _CharT, class _Traits, class _Allocator>
inline int
basic_string<_CharT, _Traits, _Allocator>::
compare (const basic_string &__str) const
{
    int __res = traits_type::compare (data (), __str.data (),
                                      std::min (size (), __str.size ()));

    if (0 == __res)
        __res = size () < __str.size () ? -1 : size () != __str.size ();

    return __res;
}


template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::append (const basic_string &__str)
{
    size_type __len = size () + __str.size ();
    if (__len > capacity () || _C_pref ()->_C_ref_count () > 1)
        return append (__str, 0, __str.size ());

    traits_type::copy (_C_data + size (), __str.data (), __str.size () + 1);
    _C_pref ()->_C_size = __len;
    return *this;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator> &__lhs, 
           const basic_string<_CharT, _Traits, _Allocator> &__rhs)
{
    typedef basic_string<_CharT, _Traits, _Allocator> string_type;

    
    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const _CharT*                                    __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (_CharT                                           __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(1, __lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const _CharT*                                    __rhs)
{
    typedef basic_string<_CharT, _Traits, _Allocator> string_type;

    
    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           _CharT                                           __rhs)
{
    typedef basic_string<_CharT, _Traits, _Allocator> string_type;

    
    return string_type (__lhs.data (), __lhs.data () + __lhs.size ()) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return __lhs.size () == __rhs.size () && 0 == __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 == __rhs.compare (__lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return 0 == __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 > __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const _CharT*                                    __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 < __rhs.compare (__lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT*                                    __rhs)
{
    return 0 > __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs < __rhs);
}




template <class _CharT, class _Traits, class _Allocator>
inline void swap (basic_string<_CharT, _Traits, _Allocator>& __a, 
                  basic_string<_CharT, _Traits, _Allocator>& __b)
{
    __a.swap (__b);
}





template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const _CharT*                                    __lhs, 
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
           const _CharT*                                    __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const _CharT*                                    __lhs, 
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs, 
            const _CharT*                                    __rhs)
{
    return !(__lhs < __rhs);
}



template<class _CharT, class _Traits, class _Allocator>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits>&,
            const basic_string<_CharT, _Traits, _Allocator>&);


}   


namespace __rw {

using namespace std;







template <class _CharT, class _Traits, class _Allocator>
inline size_t
__rw_new_capacity (size_t __size,
                   const basic_string<_CharT, _Traits, _Allocator>*)
{
    size_t __cap =
        static_cast< size_t >(((__size) + ((__size) >> 1) + ((__size) >> 3)));

    return (__size += std::size_t (128)) > __cap ? __size : __cap;
}

# 1494 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\string"

}   







namespace std {


typedef void __rw_unused_typedef;




typedef void __rw_unused_typedef;


}   




# 38 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"

# 40 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"
# 41 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"

# 43 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"
# 44 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"


namespace __rw {


std::size_t
__rw_bit_count (const unsigned long*, std::size_t) ;


void __rw_shl (unsigned long*, std::size_t, std::size_t) ;
void __rw_shr (unsigned long*, std::size_t, std::size_t) ;

}   


namespace std {


template <size_t _Size>
class bitset
{
    enum { _C_elembits = 8 * sizeof (unsigned long) };
    enum { _C_nelems   = _Size ? 1 + (_Size - 1) / _C_elembits : 0 };

    
    unsigned long _C_bits [_C_nelems ? _C_nelems : 1];

    bool _C_valid_pos (size_t __pos) const  {
        
        return _Size + 1 > __pos + 1;
    }

public:

    class reference {
        friend class bitset<_Size>;

        bitset<_Size>& _C_ref;
        size_t         _C_pos;

        reference (bitset<_Size> &__r, size_t __p) 
            : _C_ref (__r), _C_pos (__p) { }
    public:

        reference& operator= (bool __val)  {
            return _C_ref.set (_C_pos, __val), *this;
        }

        reference& operator= (const reference &__rhs)  {
            return *this = bool (__rhs);
        }

        bool operator~ () const  {
            return !bool (*this);
        }

        operator bool () const  {
            return const_cast< const bitset<_Size> & >(_C_ref)[_C_pos];
        }

        reference& flip ()  { 
            return _C_ref.flip (_C_pos), *this;
        }
    };

    
    bitset ()  {
        reset ();
    }

    
    bitset (unsigned long __n)  {
        reset ();
        _C_bits [0] =
            __n & (~0UL >> ((_Size > _C_elembits ? 0 :
                             _C_elembits - _Size % _C_elembits) % _C_elembits));
    }



    
    

    
    template <class _CharT, class _Traits, class _Allocator>
    explicit
    bitset (const basic_string<_CharT, _Traits, _Allocator>&,
            typename basic_string<_CharT, _Traits,
                                   _Allocator>::size_type = 0,
            typename basic_string<_CharT, _Traits,
                                   _Allocator>::size_type = string::npos);
# 141 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"


    
    bitset& operator&= (const bitset &__rhs)  {
        for (size_t __i = 0; __i != _C_nelems; ++__i)
            _C_bits [__i] &= __rhs._C_bits [__i];
        return *this;
    }

    
    bitset& operator|= (const bitset &__rhs)  {
        for (size_t __i = 0; __i != _C_nelems; ++__i)
            _C_bits[__i] |= __rhs._C_bits [__i];
        return *this;
    }

    
    bitset& operator^= (const bitset& __rhs)  {
        for (size_t __i = 0; __i != _C_nelems; ++__i)
            _C_bits [__i] ^= __rhs._C_bits [__i];
        return *this;
    }

    
    bitset& operator<<= (size_t) ;

    
    bitset& operator>>= (size_t) ;

    
    bitset& set () ;

    
    bitset& set (size_t, bool = true);

    
    bitset& reset ()  {
        return 1 == _C_nelems ? (void)(_C_bits [0] = 0)
            : (void)memset (_C_bits, 0, sizeof (_C_bits)), *this;
    }

    
    bitset& reset (size_t __pos) {
        return set (__pos, false);
    }

    
    bitset operator~ () const  {
        return bitset (*this).flip ();
    }

    
    bitset& flip ()  {
        for (size_t __i = 0; __i != _C_nelems; __i++) 
            _C_bits [__i] = ~_C_bits [__i];
        _C_bits [_C_nelems - !!_C_nelems] &=
            ~0UL >> (_C_elembits - _Size % _C_elembits) % _C_elembits;
        return *this;
    }

    
    bitset& flip (size_t __pos) {
        (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);




        _C_bits [__pos / _C_elembits] ^= 1UL << __pos % _C_elembits;
        return *this;
    }

    
    bool operator[] (size_t __pos) const  {
        ((void)0);
        return !!(_C_bits [__pos / _C_elembits] & (1UL << __pos % _C_elembits));
    }

    
    reference operator[] (size_t __pos)  {
        ((void)0);
        return reference (*this, __pos); 
    }

    
    unsigned long to_ulong () const;




    
    template <class _CharT, class _Traits, class _Allocator>
    basic_string<_CharT, _Traits, _Allocator> to_string () const;




# 245 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"

    
    size_t count () const  {
        return _Size ? __rw::__rw_bit_count (_C_bits, _C_nelems) : 0;
    }

    
    size_t size () const  {
        return _Size;
    }

    
    bool operator== (const bitset& __rhs) const  {
        for (size_t __i = 0; __i != _C_nelems; ++__i)
            if (_C_bits [__i] != __rhs._C_bits [__i])
                return false;
        return true;
    }

    
    bool operator!= (const bitset& __rhs) const  {
        return !(*this == __rhs);
    }

    
    bool test (size_t __pos) const {
        (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);




        return !!(_C_bits [__pos / _C_elembits] & (1UL << __pos % _C_elembits));
    }

    
    bool any () const  {
        for (size_t __i = 0; __i != _C_nelems; ++__i)
            if (_C_bits [__i])
                return true;
        return false;
    }

    
    bool none () const  {
        return !any ();
    }

    
    bitset operator<< (size_t __pos) const  {
        return bitset (*this) <<= __pos;
    }

    
    bitset operator>> (size_t __pos) const  {
        return bitset (*this) >>= __pos;
    }
};



template <size_t _Size>
inline bitset<_Size>&
bitset<_Size>::set () 
{
    if (_C_nelems == 1)
        _C_bits [0] = ~0;
    else
        memset (_C_bits, ~0, sizeof _C_bits);

    _C_bits [_C_nelems - !!_C_nelems] >>=
        (_C_elembits - _Size % _C_elembits) % _C_elembits;

    return *this;
}



template <size_t _Size>
inline bitset<_Size>&
bitset<_Size>::set (size_t __pos, bool __val)
{
    (_C_valid_pos (__pos)) ? (void)0 : __rw::__rw_throw ((0 + 9), "", "", __pos, _C_nelems);




    if (__val)
        _C_bits [__pos / _C_elembits] |=  (1UL << __pos % _C_elembits);
    else
        _C_bits [__pos / _C_elembits] &= ~(1UL << __pos % _C_elembits);
    return *this;
}



template <size_t _Size>
inline bitset<_Size>&
bitset<_Size>::operator<<= (size_t __n) 
{
    if (_Size > _C_elembits)
        __rw::__rw_shl (_C_bits, _C_nelems, __n);
    else
        _C_bits [0] <<= __n;

    
    if (_Size % _C_elembits) {
        
        _C_bits [_C_nelems - 1] &=
            ~0UL >> (_C_elembits - _Size % _C_elembits) % _C_elembits;
    }
    return *this;
}



template <size_t _Size>
inline bitset<_Size>&
bitset<_Size>::operator>>= (size_t __n) 
{
    if (_Size > _C_elembits)
        __rw::__rw_shr (_C_bits, _C_nelems, __n);
    else
        _C_bits [0] >>= __n;
    return *this;
}



template <size_t _Size>
inline unsigned long
bitset<_Size>::to_ulong () const
{
    
    for (size_t __i = 1; __i + 1 < _C_nelems + 1; ++__i)
        (!_C_bits[__i]) ? (void)0 : __rw::__rw_throw ((0 + 12), "", "");



    return _C_bits [0];
} 






template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string () const 
{
    
    basic_string<_CharT, _Traits, _Allocator> __s ((_CharT*)0, _Size);

    for (size_t __i = 0; __i != _Size; ++__i)
        _Traits::assign (__s [_Size - 1 - __i], (*this)[__i] ? '1' : '0');

    return __s;
}

# 421 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"



template <size_t _Size>
inline bitset<_Size>
operator& (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
{
    return bitset<_Size>(__lhs) &= __rhs;
}



template <size_t _Size>
inline bitset<_Size>
operator| (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
{
    return bitset<_Size>(__lhs) |= __rhs;
}



template <size_t _Size>
inline bitset<_Size> 
operator^ (const bitset<_Size>& __lhs, const bitset<_Size>& __rhs) 
{
    return bitset<_Size>(__lhs) ^= __rhs;
}


}   

namespace __rw {

template <class _CharT, class _Traits, size_t _Size> 
std::basic_istream<_CharT, _Traits>&  
__rw_extract_bitset (std::basic_istream<_CharT, _Traits>&,
                     std::bitset<_Size>&);

}   


namespace std {




template <class _CharT, class _Traits, size_t _Size> 
inline basic_ostream<_CharT,_Traits>&  
operator<< (basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)
{
    return __os << __x. template to_string<_CharT, _Traits, allocator <_CharT> > ();
}



template <class _CharT, class _Traits, size_t _Size> 
inline basic_istream<_CharT,_Traits>&  
operator>> (basic_istream<_CharT, _Traits>& __strm, bitset<_Size>& __x)
{
    return __rw::__rw_extract_bitset (__strm, __x);
}

# 517 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\bitset"


}   









# 5 "MixerController.h"
# 1 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"
 
 





 









     
# 27 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"
     












      namespace std {

          extern "C" {








 

     

     
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       __int64 int64_t;

     
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       __int64 uint64_t;

     

     
     
typedef   signed          char int_least8_t;
typedef   signed short     int int_least16_t;
typedef   signed           int int_least32_t;
typedef   signed       __int64 int_least64_t;

     
typedef unsigned          char uint_least8_t;
typedef unsigned short     int uint_least16_t;
typedef unsigned           int uint_least32_t;
typedef unsigned       __int64 uint_least64_t;

     

     
typedef   signed           int int_fast8_t;
typedef   signed           int int_fast16_t;
typedef   signed           int int_fast32_t;
typedef   signed       __int64 int_fast64_t;

     
typedef unsigned           int uint_fast8_t;
typedef unsigned           int uint_fast16_t;
typedef unsigned           int uint_fast32_t;
typedef unsigned       __int64 uint_fast64_t;

     




typedef   signed           int intptr_t;
typedef unsigned           int uintptr_t;


     
typedef   signed     long long intmax_t;
typedef unsigned     long long uintmax_t;


# 247 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"

# 266 "C:\\Keil_v5\\ARM\\ARMCC\\Bin\\..\\include\\stdint.h"


         }   
      }   





      using ::std::int8_t;
      using ::std::int16_t;
      using ::std::int32_t;
      using ::std::int64_t;
      using ::std::uint8_t;
      using ::std::uint16_t;
      using ::std::uint32_t;
      using ::std::uint64_t;
      using ::std::int_least8_t;
      using ::std::int_least16_t;
      using ::std::int_least32_t;
      using ::std::int_least64_t;
      using ::std::uint_least8_t;
      using ::std::uint_least16_t;
      using ::std::uint_least32_t;
      using ::std::uint_least64_t;
      using ::std::int_fast8_t;
      using ::std::int_fast16_t;
      using ::std::int_fast32_t;
      using ::std::int_fast64_t;
      using ::std::uint_fast8_t;
      using ::std::uint_fast16_t;
      using ::std::uint_fast32_t;
      using ::std::uint_fast64_t;
      using ::std::intptr_t;
      using ::std::uintptr_t;
      using ::std::intmax_t;
      using ::std::uintmax_t;








 
# 6 "MixerController.h"

class MixerController {
	public:
		
		enum ButtonIndices {
			BUTTON_INDEX_PROGRAM0,
			BUTTON_INDEX_PROGRAM1,
			BUTTON_INDEX_PROGRAM2,
			BUTTON_INDEX_PROGRAM3,
			BUTTON_INDEX_PROGRAM4,
			BUTTON_INDEX_PROGRAM5,
			BUTTON_INDEX_PROGRAM6,
			BUTTON_INDEX_PROGRAM7,
			
			BUTTON_INDEX_PREVIEW0,
			BUTTON_INDEX_PREVIEW1,
			BUTTON_INDEX_PREVIEW2,
			BUTTON_INDEX_PREVIEW3,
			BUTTON_INDEX_PREVIEW4,
			BUTTON_INDEX_PREVIEW5,
			BUTTON_INDEX_PREVIEW6,
			BUTTON_INDEX_PREVIEW7,
			
			BUTTON_INDEX_RESERVED0,
			BUTTON_INDEX_RESERVED1,
			BUTTON_INDEX_TRANSITION,
			BUTTON_INDEX_CUT,
			BUTTON_INDEX_RESERVED4,
			BUTTON_INDEX_RESERVED5,
			BUTTON_INDEX_RESERVED6,
			BUTTON_INDEX_RESERVED7,
			
			
			
			BUTTON_INDEX_COUNT
		};
		
		
		enum LedIndices {
			LED_INDEX_PREVIEW0,
			LED_INDEX_PREVIEW1,
			LED_INDEX_PREVIEW2,
			LED_INDEX_PREVIEW3,
			LED_INDEX_PREVIEW4,
			LED_INDEX_PREVIEW5,
			LED_INDEX_PREVIEW6,
			LED_INDEX_PREVIEW7,
			
			LED_INDEX_PROGRAM0,
			LED_INDEX_PROGRAM1,
			LED_INDEX_PROGRAM2,
			LED_INDEX_PROGRAM3,
			LED_INDEX_PROGRAM4,
			LED_INDEX_PROGRAM5,
			LED_INDEX_PROGRAM6,
			LED_INDEX_PROGRAM7,
			
			
			
			LED_INDEX_COUNT
		};
		
		static const size_t PROGRAM_CNT = BUTTON_INDEX_PROGRAM7 - BUTTON_INDEX_PROGRAM0 + 1; 
		static const size_t PREVIEW_CNT = BUTTON_INDEX_PREVIEW7 - BUTTON_INDEX_PREVIEW0 + 1; 
		static const size_t NO_SIGNAL = 0xFFFF;
		
		typedef std::bitset<BUTTON_INDEX_COUNT> ButtonState; 
		typedef std::bitset<LED_INDEX_COUNT> LedState; 
		
		typedef void (*LedStateCallback)(void*, LedState); 
		typedef void (*BusCallback)(void*, size_t); 
		typedef void (*ActionCallback)(void*); 
	
		

 
		MixerController(	void* ledUsrPtr = 0,
											LedStateCallback ledCbk = 0,
											void*	pgmUsrPtr = 0,
											BusCallback pgmCbk = 0,
											void*	pvwUsrPtr = 0,
											BusCallback pvwCbk = 0,
											void*	cutUsrPtr = 0,
											ActionCallback cutCbk = 0,
											void*	transUsrPtr = 0,
											ActionCallback transCbk = 0 );
			
			
		

 
		void setLedUserPointer(void* usrPtr);
		
		

 
		void* getLedUserPointer() const;
			
		

 
		void setLedCallback(LedStateCallback cbk);
		
		

 
		LedStateCallback getLedCallback() const;
											
											
		

 
		void setProgramUserPointer(void* usrPtr);
		
		

 
		void* getProgramUserPointer() const;
		
		

 
		void setProgramCallback(BusCallback cbk);
		
		

 
		BusCallback getProgramCallback() const;
		
		
		

 
		void setPreviewUserPointer(void* usrPtr);
		
		

 
		void* getPreviewUserPointer() const;
							
		

 
		void setPreviewCallback(BusCallback cbk);
		
		

 
		BusCallback getPreviewCallback() const;


		

 
		void setCutUserPointer(void* usrPtr);
		
		

 
		void* getCutUserPointer() const;
							
		

 
		void setCutCallback(ActionCallback cbk);
		
		

 
		ActionCallback getCutCallback() const;	
		
		
		

 
		void setTransitionUserPointer(void* usrPtr);
		
		

 
		void* getTransitionUserPointer() const;
							
		

 
		void setTransitionCallback(ActionCallback cbk);
		
		

 
		ActionCallback getTransitionCallback() const;	
											
											
			
		

 
		void process(ButtonState buttonState);
		
		
		
	private:		
		void*							m_ledUserPtr;
		LedStateCallback	m_ledCallback;
	
		void*							m_programUserPtr;
		BusCallback				m_programCallback;
	
		void*							m_previewUserPtr;
		BusCallback				m_previewCallback;
	
		void*							m_cutUserPtr;
		ActionCallback		m_cutCallback;
	
		void*							m_transitionUserPtr;
		ActionCallback		m_transitionCallback;
	
		ButtonState				m_lastState;
		size_t						m_program;
		size_t						m_preview;
	
};

# 2 "MixerController.cpp"






 
template<size_t C>
static std::bitset<C> getRisingEdge(const std::bitset<C>& prev, const std::bitset<C>& next) {
	return ~prev & next;
}








 
template<size_t C>
static size_t firstOne(const std::bitset<C>& bs, size_t first, size_t last) {
	while(first < last && !bs.test(first)) ++first;
	return first;
}




MixerController::MixerController(	void* ledUsrPtr,
																	LedStateCallback ledCbk,
																	void*	pgmUsrPtr,
																	BusCallback pgmCbk,
																	void*	pvwUsrPtr,
																	BusCallback pvwCbk,
																	void*	cutUsrPtr,
																	ActionCallback cutCbk,
																	void*	transUsrPtr,
																	ActionCallback transCbk																	)
	: m_ledUserPtr(ledUsrPtr)
	, m_ledCallback(ledCbk)
	, m_programUserPtr(pgmUsrPtr)
	, m_programCallback(pgmCbk)
	, m_previewUserPtr(pvwUsrPtr)
	, m_previewCallback(pvwCbk)
	,	m_cutUserPtr(cutUsrPtr)
	, m_cutCallback(cutCbk)
	, m_transitionUserPtr(transUsrPtr)
	, m_transitionCallback(transCbk)
	, m_program(8)
	, m_preview(8)
{
}
	


void MixerController::setLedUserPointer(void* usrPtr) {
	m_ledUserPtr = usrPtr;
}

void* MixerController::getLedUserPointer() const {
	return m_ledUserPtr;
}

void MixerController::setLedCallback(LedStateCallback cbk) {
	m_ledCallback = cbk;
}
	
MixerController::LedStateCallback MixerController::getLedCallback() const {
	return m_ledCallback;
}
									

void MixerController::setProgramUserPointer(void* usrPtr) {
	m_programUserPtr = usrPtr;
}

void* MixerController::getProgramUserPointer() const {
	return m_programUserPtr;
}

void MixerController::setProgramCallback(BusCallback cbk) {
	m_programCallback = cbk;
}

MixerController::BusCallback MixerController::getProgramCallback() const {
	return m_programCallback;
}
	

void MixerController::setPreviewUserPointer(void* usrPtr) {
	m_previewUserPtr = usrPtr;
}

void* MixerController::getPreviewUserPointer() const {
	return m_previewUserPtr;
}
					
void MixerController::setPreviewCallback(BusCallback cbk) {
		m_previewCallback = cbk;
}

MixerController::BusCallback MixerController::getPreviewCallback() const {
	return m_previewCallback;
}


void MixerController::setCutUserPointer(void* usrPtr) {
	m_cutUserPtr = usrPtr;
}

void* MixerController::getCutUserPointer() const {
	return m_cutUserPtr;
}
					
void MixerController::setCutCallback(ActionCallback cbk) {
		m_cutCallback = cbk;
}

MixerController::ActionCallback MixerController::getCutCallback() const {
	return m_cutCallback;
}


void MixerController::setTransitionUserPointer(void* usrPtr) {
	m_transitionUserPtr = usrPtr;
}

void* MixerController::getTransitionUserPointer() const {
	return m_transitionUserPtr;
}
					
void MixerController::setTransitionCallback(ActionCallback cbk) {
		m_transitionCallback = cbk;
}

MixerController::ActionCallback MixerController::getTransitionCallback() const {
	return m_transitionCallback;
}



void MixerController::process(ButtonState buttonState) {	
	
	buttonState.flip(); 
	
	
	const ButtonState risingEdge = getRisingEdge(m_lastState, buttonState);
	m_lastState = buttonState;
	
	
	
	const size_t newPgm = firstOne(risingEdge, BUTTON_INDEX_PROGRAM0, BUTTON_INDEX_PROGRAM0 + PROGRAM_CNT) - BUTTON_INDEX_PROGRAM0;
	const size_t newPvw = firstOne(risingEdge, BUTTON_INDEX_PREVIEW0, BUTTON_INDEX_PREVIEW0 + PREVIEW_CNT) - BUTTON_INDEX_PREVIEW0;
	
	
	
	bool updateLeds = false;
	if(newPgm < PROGRAM_CNT) {
		
		updateLeds = true;
		m_program = (m_program != newPgm) ? newPgm : NO_SIGNAL;
		
		
		if(m_programCallback) {
			m_programCallback(m_programUserPtr, m_program);
		}
	}
	if(newPvw < PREVIEW_CNT) {
		
		updateLeds = true;
		m_preview = (m_preview != newPvw) ? newPvw : NO_SIGNAL;
		
		
		if(m_previewCallback) {
			m_previewCallback(m_previewUserPtr, m_preview);
		}
	}
	if(risingEdge.test(BUTTON_INDEX_CUT)) {
		updateLeds = true;
		std::swap(m_program, m_preview);
		
		
		if(m_cutCallback) {
			m_cutCallback(m_cutUserPtr);
		}
	}
	if(risingEdge.test(BUTTON_INDEX_TRANSITION)) {
		updateLeds = true;
		std::swap(m_program, m_preview); 
		
		
		if(m_transitionCallback) {
			m_transitionCallback(m_transitionUserPtr);
		}
	}
	
	
	
	if(updateLeds && m_ledCallback) {
		LedState ledState;
		
		
		const size_t pgmLed = LED_INDEX_PROGRAM0 + m_program;
		const size_t pvwLed = LED_INDEX_PREVIEW0 + m_preview;
		
		
		if(pgmLed < (LED_INDEX_PROGRAM0 + PROGRAM_CNT)) {
			ledState.set(pgmLed, true);
		}
		if(pvwLed < (LED_INDEX_PREVIEW0 + PREVIEW_CNT)) {
			ledState.set(pvwLed, true);
		}
		
		
		m_ledCallback(m_ledUserPtr, ledState);
	}
}
